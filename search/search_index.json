{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"nemo-simsar \ud83d\udd17 Document your NEMO ocean model simulations and share them with others using git remote repositories. This project is part of the IMMERSE Project funded by the EC. 1. Description \ud83d\udd17 Ocean model simulations that are based on the NEMO ocean modelling framework ( nemo-ocean.eu ) consists of several components: The source code provided by NEMO and by the user (FORTRAN code) Build settings (model components, compiler options) Runtime parameters (FORTRAN and XML namelists) Input data fIles (e.g. grid, bathymetry, boundary conditions, initialisation) While the first two components define a certain \" configuration \", the latter two provide the details for a specific experiment with the said configuration. Both together form a simulation . The recipes and the tools in this project allows users to create a package containing all the necessary information in order to share it with other users intending to reproduce the simulation or to start from this simulation with their own settings. See also the documentation in the doc/ folder for more details. Features \ud83d\udd17 Interactive script in order to create a README file (Markdown format) giving an overview of the simulation's settings and providing instructions how to include it in your own NEMO framework. Recipe to extract and upload a configuration from inside the NEMO framework into a remote git repository 2. Requirements \ud83d\udd17 Assuming you're working on a *nix like system you have to meet the following pre-requisits before running a tool or following a recipe from this project: A working NEMO framework (see nemo-ocean.eu ) A NEMO simulation to share (=configuration + experiment details) git client is installed and working access to a remote git server Python3 including these standard libraries: os , re , subprocess , pathlib , textwrap The following additional Python3 packages must be installed (e.g. with pip or conda or through your favorite package manager): svn ( pypi | anaconda:main ) wget ( pypi | anaconda:main ) GitPython ( pypi | anaconda:main ) Jinja2 ( pypi | anaconda:main ) pycurl ( pypi | anaconda:main ) netcdf4 ( pypi | anaconda:main ) EXAMPLE: Install required Python3 packages pip pip3 install svn wget GitPython Jinja2 pycurl netCDF4 conda Using the conda-forge channel : conda install --channel conda-forge python=3 svn wget gitpython jinja2 pycurl netcdf4 Terms of Use & License Agreement \ud83d\udd17 Before using this software, the user must agree to the license given by the LICENSE file in the project's repository. This software can be used free of charge. 3. Download & Installation \ud83d\udd17 Then change to the directory where you want to keep your local copy of this project, e.g. your $HOME directory and clone it: git clone git@github.com:immerse-project/nemo-simsar.git In order to use the tools from the SIMSAR package, make sure, the full path to nemo-simsar/bin is part of your $PATH environment variable: EXAMPLE: Prepending to $PATH bash # bash-like shell: export PATH = /path/to/nemo-simsar/bin: ${ PATH } csh # or csh: setenv PATH /path/to/nemo-simsar/bin: ${ PATH } Updates \ud83d\udd17 Go into your local copy of the nemo-simsar repository and run git fetch and review any changes before merging manually. See the git documentation on git-fetch for details. git fetch Or, if you're inclined to merge any changes immediately into your local repository, just run a git pull (see git-pull manual): git pull 4. Usage \ud83d\udd17 Please read the User Guide for further instructions how to use SIMSAR since it does not only consist of one single program but is a collection of recipes with a few tools to assist the user. The Introduction tells you about the background and how to use SIMSAR. The Getting Started section provides step-by-step instructions. Testing \ud83d\udd17 Currently, there is no testing implemented. 5. Documentation \ud83d\udd17 See the User Guide in the docs/ folder of this project or visit the webpage nemo-simsar . 6. Support \ud83d\udd17 There is only a limited support during the introduction phase of this package. Please, use the issue reporting on GitHub. 7. Contributing \ud83d\udd17 Please use the collaboration tools provided for the GitHub project IMMERSE-project/nemo-simsar .","title":"HOME"},{"location":"index.html#nemo-simsar","text":"Document your NEMO ocean model simulations and share them with others using git remote repositories. This project is part of the IMMERSE Project funded by the EC.","title":"nemo-simsar"},{"location":"index.html#1-description","text":"Ocean model simulations that are based on the NEMO ocean modelling framework ( nemo-ocean.eu ) consists of several components: The source code provided by NEMO and by the user (FORTRAN code) Build settings (model components, compiler options) Runtime parameters (FORTRAN and XML namelists) Input data fIles (e.g. grid, bathymetry, boundary conditions, initialisation) While the first two components define a certain \" configuration \", the latter two provide the details for a specific experiment with the said configuration. Both together form a simulation . The recipes and the tools in this project allows users to create a package containing all the necessary information in order to share it with other users intending to reproduce the simulation or to start from this simulation with their own settings. See also the documentation in the doc/ folder for more details.","title":"1. Description"},{"location":"index.html#features","text":"Interactive script in order to create a README file (Markdown format) giving an overview of the simulation's settings and providing instructions how to include it in your own NEMO framework. Recipe to extract and upload a configuration from inside the NEMO framework into a remote git repository","title":"Features"},{"location":"index.html#2-requirements","text":"Assuming you're working on a *nix like system you have to meet the following pre-requisits before running a tool or following a recipe from this project: A working NEMO framework (see nemo-ocean.eu ) A NEMO simulation to share (=configuration + experiment details) git client is installed and working access to a remote git server Python3 including these standard libraries: os , re , subprocess , pathlib , textwrap The following additional Python3 packages must be installed (e.g. with pip or conda or through your favorite package manager): svn ( pypi | anaconda:main ) wget ( pypi | anaconda:main ) GitPython ( pypi | anaconda:main ) Jinja2 ( pypi | anaconda:main ) pycurl ( pypi | anaconda:main ) netcdf4 ( pypi | anaconda:main ) EXAMPLE: Install required Python3 packages pip pip3 install svn wget GitPython Jinja2 pycurl netCDF4 conda Using the conda-forge channel : conda install --channel conda-forge python=3 svn wget gitpython jinja2 pycurl netcdf4","title":"2. Requirements"},{"location":"index.html#terms-of-use-license-agreement","text":"Before using this software, the user must agree to the license given by the LICENSE file in the project's repository. This software can be used free of charge.","title":"Terms of Use &amp; License Agreement"},{"location":"index.html#3-download-installation","text":"Then change to the directory where you want to keep your local copy of this project, e.g. your $HOME directory and clone it: git clone git@github.com:immerse-project/nemo-simsar.git In order to use the tools from the SIMSAR package, make sure, the full path to nemo-simsar/bin is part of your $PATH environment variable: EXAMPLE: Prepending to $PATH bash # bash-like shell: export PATH = /path/to/nemo-simsar/bin: ${ PATH } csh # or csh: setenv PATH /path/to/nemo-simsar/bin: ${ PATH }","title":"3. Download &amp; Installation"},{"location":"index.html#updates","text":"Go into your local copy of the nemo-simsar repository and run git fetch and review any changes before merging manually. See the git documentation on git-fetch for details. git fetch Or, if you're inclined to merge any changes immediately into your local repository, just run a git pull (see git-pull manual): git pull","title":"Updates"},{"location":"index.html#4-usage","text":"Please read the User Guide for further instructions how to use SIMSAR since it does not only consist of one single program but is a collection of recipes with a few tools to assist the user. The Introduction tells you about the background and how to use SIMSAR. The Getting Started section provides step-by-step instructions.","title":"4. Usage"},{"location":"index.html#testing","text":"Currently, there is no testing implemented.","title":"Testing"},{"location":"index.html#5-documentation","text":"See the User Guide in the docs/ folder of this project or visit the webpage nemo-simsar .","title":"5. Documentation"},{"location":"index.html#6-support","text":"There is only a limited support during the introduction phase of this package. Please, use the issue reporting on GitHub.","title":"6. Support"},{"location":"index.html#7-contributing","text":"Please use the collaboration tools provided for the GitHub project IMMERSE-project/nemo-simsar .","title":"7. Contributing"},{"location":"INDEX.html","text":"INTRODUCTION \ud83d\udd17 Document and share your NEMO ocean model simulations using remote git repositories This project is part of the EC funded IMMERSE project ( immerse-ocean.eu ) 1. Description \ud83d\udd17 Ocean model simulations that are based on the NEMO ocean modelling framework ( nemo-ocean.eu ) consists of several components: The source code provided by NEMO and by the user (FORTRAN code) Build settings (model components, compiler options) Runtime parameters (FORTRAN and XML namelists) Input data fIles (e.g. grid, bathymetry, boundary conditions, initialisation) While the first two components define a certain \" configuration \", the latter two provide the details for a specific experiment with the said configuration. Both together define a simulation . The recipes and the tools in this project allows users to create a package containing all the necessary information in order to share it with other users intending to reproduce the simulation or to start from this simulation with their own settings. See also the documentation in the doc/ folder for more details. Features \ud83d\udd17 Interactive script in order to create a README file (Markdown format) giving an overview of the simulation's settings and providing instructions how to include it in your own NEMO framework. Recipe to extract and upload a configuration from inside the NEMO framework into a remote git repository 2. Requirements \ud83d\udd17 Assuming you're working on a *nix like system you have to meet the following pre-requisits before running a tool or following a recipe from this project: A working NEMO framework (see nemo-ocean.eu ) A NEMO configuration + experiment details (=simulation) to share A definition list ( input.def ) containing names and remote sources of the citable, version-controlled input data files. See doc/inputfiles.md for details git client is installed and working access to a remote git server Python3 including these standard libraries: os re subprocess pathlib textwrap The following additional Python3 packages must be installed (e.g. with pip or conda or through your favorite package manager): svn ( pip ) wget ( pip ) GitPython ( pip ) Jinja2 ( pip ) pycurl ( pip ) A local copy of this git project. Terms of Use & License Agreement \ud83d\udd17 Before using this software, the user must agree to the license given by the LICENSE file in the project's repository. This software can be used free of charge. 3. Download & Installation \ud83d\udd17 First make sure that the required Python3 packages are installed on your local machine. If you're using pip for example, you can run the following command: pip3 install svn wget GitPython Jinja2 pycurl Then change to the directory where you want to keep your local copy of this project and clone it: git clone git@github.com:immerse-project/nemo-simsar.git Updates \ud83d\udd17 Go into your local copy of the nemo-simsar repository and run git fetch and review any changes before merging manually. git fetch Or, if you're inclined to merge any changes immediately into your local repository, just run a git pull : git pull 4. Usage \ud83d\udd17 Short notes on how to start/use the program and the command syntax (if necessary) The most important tool is the mkReadme script. Make sure, the full path to nemo-simsar/bin is part of your $PATH environment variable: # Bash-like: export PATH = /path/to/nemo-simsar/bin: ${ PATH } # or csh: setenv PATH /path/to/nemo-simsar/bin: ${ PATH } Before you can run the mkReadme tool, make sure, that the following information is available: The NEMO code repository , branch identifier and revision number the simulation's code is based on An input.def file listing file names of the input files used by NEMO and their remote sources as well as references (see the input.def template in the doc/ folder) Then go into your configuration's folder and run mkReadme mkReadme NOTE : If the nemo-simsar/bin is not part of your $PATH variable, run the script using the full path, something like: /home/myname/nemo-simsar/bin/mkReadme The script does not accept any arguments yet (May change in the future). Example \ud83d\udd17 Provide one ore more examples # Example 1: cd $HOME /NEMO/release-4.0/cfg/CrazyWhirl mkReadme Testing \ud83d\udd17 Currently, there is no testing implemented. 5. Documentation \ud83d\udd17 See the files in the doc/ sub-folder of this project. 6. Support \ud83d\udd17 There is only a limited support during the introduction phase of this package. Please, use the issue reporting on GitHub.","title":"INTRODUCTION"},{"location":"INDEX.html#introduction","text":"Document and share your NEMO ocean model simulations using remote git repositories This project is part of the EC funded IMMERSE project ( immerse-ocean.eu )","title":"INTRODUCTION"},{"location":"INDEX.html#1-description","text":"Ocean model simulations that are based on the NEMO ocean modelling framework ( nemo-ocean.eu ) consists of several components: The source code provided by NEMO and by the user (FORTRAN code) Build settings (model components, compiler options) Runtime parameters (FORTRAN and XML namelists) Input data fIles (e.g. grid, bathymetry, boundary conditions, initialisation) While the first two components define a certain \" configuration \", the latter two provide the details for a specific experiment with the said configuration. Both together define a simulation . The recipes and the tools in this project allows users to create a package containing all the necessary information in order to share it with other users intending to reproduce the simulation or to start from this simulation with their own settings. See also the documentation in the doc/ folder for more details.","title":"1. Description"},{"location":"INDEX.html#features","text":"Interactive script in order to create a README file (Markdown format) giving an overview of the simulation's settings and providing instructions how to include it in your own NEMO framework. Recipe to extract and upload a configuration from inside the NEMO framework into a remote git repository","title":"Features"},{"location":"INDEX.html#2-requirements","text":"Assuming you're working on a *nix like system you have to meet the following pre-requisits before running a tool or following a recipe from this project: A working NEMO framework (see nemo-ocean.eu ) A NEMO configuration + experiment details (=simulation) to share A definition list ( input.def ) containing names and remote sources of the citable, version-controlled input data files. See doc/inputfiles.md for details git client is installed and working access to a remote git server Python3 including these standard libraries: os re subprocess pathlib textwrap The following additional Python3 packages must be installed (e.g. with pip or conda or through your favorite package manager): svn ( pip ) wget ( pip ) GitPython ( pip ) Jinja2 ( pip ) pycurl ( pip ) A local copy of this git project.","title":"2. Requirements"},{"location":"INDEX.html#terms-of-use-license-agreement","text":"Before using this software, the user must agree to the license given by the LICENSE file in the project's repository. This software can be used free of charge.","title":"Terms of Use &amp; License Agreement"},{"location":"INDEX.html#3-download-installation","text":"First make sure that the required Python3 packages are installed on your local machine. If you're using pip for example, you can run the following command: pip3 install svn wget GitPython Jinja2 pycurl Then change to the directory where you want to keep your local copy of this project and clone it: git clone git@github.com:immerse-project/nemo-simsar.git","title":"3. Download &amp; Installation"},{"location":"INDEX.html#updates","text":"Go into your local copy of the nemo-simsar repository and run git fetch and review any changes before merging manually. git fetch Or, if you're inclined to merge any changes immediately into your local repository, just run a git pull : git pull","title":"Updates"},{"location":"INDEX.html#4-usage","text":"Short notes on how to start/use the program and the command syntax (if necessary) The most important tool is the mkReadme script. Make sure, the full path to nemo-simsar/bin is part of your $PATH environment variable: # Bash-like: export PATH = /path/to/nemo-simsar/bin: ${ PATH } # or csh: setenv PATH /path/to/nemo-simsar/bin: ${ PATH } Before you can run the mkReadme tool, make sure, that the following information is available: The NEMO code repository , branch identifier and revision number the simulation's code is based on An input.def file listing file names of the input files used by NEMO and their remote sources as well as references (see the input.def template in the doc/ folder) Then go into your configuration's folder and run mkReadme mkReadme NOTE : If the nemo-simsar/bin is not part of your $PATH variable, run the script using the full path, something like: /home/myname/nemo-simsar/bin/mkReadme The script does not accept any arguments yet (May change in the future).","title":"4. Usage"},{"location":"INDEX.html#example","text":"Provide one ore more examples # Example 1: cd $HOME /NEMO/release-4.0/cfg/CrazyWhirl mkReadme","title":"Example"},{"location":"INDEX.html#testing","text":"Currently, there is no testing implemented.","title":"Testing"},{"location":"INDEX.html#5-documentation","text":"See the files in the doc/ sub-folder of this project.","title":"5. Documentation"},{"location":"INDEX.html#6-support","text":"There is only a limited support during the introduction phase of this package. Please, use the issue reporting on GitHub.","title":"6. Support"},{"location":"RequiredInfo.html","text":"Required Meta Information \ud83d\udd17","title":"Required Meta Information"},{"location":"RequiredInfo.html#required-meta-information","text":"","title":"Required Meta Information"},{"location":"api-mkreadme.html","text":"mkReadme \ud83d\udd17 \ud83d\udd17 Created on Fri Jan 10 10:31:20 2020 @author: luciennemicallef color \ud83d\udd17 This class stores a list of colours and font styles ask_exp00 ( exp ) \ud83d\udd17 exp is the configuration name Source code in mk_readme/clsmkReadme.py def ask_exp00 ( exp ): '''exp is the configuration name''' '''The purpose of this function is to show all directories for the chosen configuration ''' print ( \" \\n Chosen configuration is : \" , exp ) #list to store all the directories inside this configuration listWithAllDir = [] configPath = getNemoConfig () + \"/\" + exp #print(\"Config path\" , configPath) print ( \" \\n Directories for : \" , exp ) for r , d , f in os . walk ( configPath ): for directory in d : listWithAllDir . append ( directory ) #sort list listWithAllDir . sort () for i in listWithAllDir : print ( i ) choice = input ( \" \\n --> Are you sure that this is the configuration you would like to work with? Proceed with [Y] or [N] \\n\\n \" ) choice = choice . lower () if choice == 'y' : return True else : return False center ( text ) \ud83d\udd17 Centers the text to the midddle of the screen Source code in mk_readme/clsmkReadme.py def center ( text ): '''Centers the text to the midddle of the screen''' command = [ 'tput' , 'cols' ] width = int ( subprocess . check_output ( command )) print ( text . center ( width ), \" \\n \" ) check_confdir () \ud83d\udd17 The purpose of this function is to check if the script is in a configuration sub-folder in NEMOGCM/CONFIG Source code in mk_readme/clsmkReadme.py def check_confdir (): '''The purpose of this function is to check if the script is in a configuration sub-folder in NEMOGCM/CONFIG ''' pathLst = [] currentDirectory = os . getcwd () words = currentDirectory . split ( \"/\" , 4 ) for w in words : pathLst . append ( w ) lastElement = str ( pathLst [ len ( pathLst ) - 1 ]) #should be CONFIG print ( \"last Element \" , lastElement ) if ( lastElement != \"CONFIG\" ): errmsg ( \"It seems, we are not in a configuration sub-folder of NEMOGCM/CONFIG. I'm lost. \" + BOLD + \"Please run this script within a configuration folder!\" + NORMAL ) check_EXPref () \ud83d\udd17 This function will check whether the current location contains, EXP00 and EXPREF folder Source code in mk_readme/clsmkReadme.py def check_EXPref (): '''This function will check whether the current location contains, EXP00 and EXPREF folder''' path = os . getcwd () expRef = False for root , directories , files in os . walk ( path ): for folder in directories : #release 3 if \"EXP00\" in folder : expRef = True break #release 4 elif \"EXPREF\" in folder : expRef = True break return expRef check_gitorsvn () \ud83d\udd17 The purpose of this function is to check whether the current script is stored as a git repo or as an svn repo Source code in mk_readme/clsmkReadme.py def check_gitorsvn (): '''The purpose of this function is to check whether the current script is stored as a git repo or as an svn repo''' '''if LNGIT is True - the script is stored as a git repo''' '''if LNSVN is True - the script is stored as an svn svn repo''' global repo try : repo = git . Repo ( \".\" , search_parent_directories = True ) except git . InvalidGitRepositoryError : print ( BLUE + \"This is not a git repo \\n \" + NORMAL ) else : print ( BLUE + \"This is a Git Repo\" + NORMAL ) global LNGIT LNGIT = True if ( LNGIT == False ): try : repo = subprocess . check_output ( \"svn info | awk '/^Kind:/ {print $2}'\" , shell = True ) . strip () except svn . exception . SvnException : print ( BLUE + \"This is not an svn repo \\n \" + NORMAL ) except OSError as e : print ( \"Error - \" , e ) else : print ( BLUE + \"This is an SVN Repo\" + NORMAL ) global LNSVN LNSVN = True check_inputDef_exists () \ud83d\udd17 This function checks whether input.def file exists in the directory of the chosen configuration. If not the script will exit. Source code in mk_readme/clsmkReadme.py def check_inputDef_exists (): '''This function checks whether input.def file exists in the directory of the chosen configuration. If not the script will exit.''' if ( CURRCONFIG == True ): parent = os . path . dirname ( os . getcwd ()) else : parent = os . getcwd () #print(\"Parent \", parent) found = False files = [] #r=root, d=directories, f = files for r , d , f in os . walk ( parent ): for file in f : if 'input.def' in file : found = True files . append ( os . path . join ( r , file )) if found == True : return True else : return False check_prereq () \ud83d\udd17 This function will check that EXP00 or EXPREF directory is present in the current file structure Source code in mk_readme/clsmkReadme.py def check_prereq (): '''This function will check that EXP00 or EXPREF directory is present in the current file structure ''' if ( EXPref != \"EXP00\" ) and ( EXPref != \"EXPREF\" ): errmsg ( \"No EXP00/EXPREF folder with default settings was found. Please create one and re-run this script.\" ) else : cwflag = 0 #check_confdir() git_X = git . __version__ if len ( git_X ) > 0 : sucssmsg ( \"GIT found\" ) else : errmsg ( \"GIT not found\" ) svn_X = svn . __version__ if len ( svn_X ) > 0 : sucssmsg ( \"SVN found\" ) else : errmsg ( \"SVN not found\" ) ssh_X = os . system ( 'ssh -V' ) if len ( str ( ssh_X )) > 0 : sucssmsg ( \"SSH found\" ) else : errmsg ( \"SSH not found\" ) curl_X = pycurl . version if len ( curl_X ) > 0 : sucssmsg ( \"CURL found\" ) else : errmsg ( \"CURL not found\" ) cwflag = cwflag + 1 wget_X = wget . __version__ if len ( wget_X ) > 0 : sucssmsg ( \"WGET found\" ) else : errmsg ( \"WGET not found\" ) cwflag = cwflag + 1 if ( cwflag > 0 ): errmsg ( \"Neither CURL nor WGET was found. Abort\" ) m4_X = os . system ( 'm4 --version' ) if len ( str ( m4_X )) > 0 : sucssmsg ( \"m4 found\" ) else : errmsg ( \"m4 not found\" ) global zGITSERVER zGITSERVER = get_zGITSERVER () global zGITNMSPC zGITNMSPC = get_zGITNMSPC () print ( \"zGITSERVER: \" , zGITSERVER ) print ( \"zGITNMSPC: \" , zGITNMSPC ) checkScriptLocation () \ud83d\udd17 The purpose of this function is to check whether the script is being run from a particular configuration Source code in mk_readme/clsmkReadme.py def checkScriptLocation (): '''The purpose of this function is to check whether the script is being run from a particular configuration''' path2 = os . getcwd () configName = os . path . basename ( path2 ) #print(\"This script is saved in \", configName) for x in getAllConfigFolders (): if x == configName : global CURRCONFIG CURRCONFIG = True return x chooseConfigFolder () \ud83d\udd17 This function will ask the user to select one configuration from the list generated from getAllConfigFolders. The chosen config is stored in a global variable called exp which will be used throughout the script Source code in mk_readme/clsmkReadme.py def chooseConfigFolder (): '''This function will ask the user to select one configuration from the list generated from getAllConfigFolders. The chosen config is stored in a global variable called exp which will be used throughout the script''' valid = False global exp configList = [] print ( \" \\n\\n Config List: \\n \" ) for i in getAllConfigFolders (): configList . append ( i ) print ( i ) while valid == False : exp = input ( \" \\n Choose one of the above configurations : \\n\\n \" ) if exp in configList : valid = True return exp else : print ( \"Invalid entry, input has to match exactly (including capital letters)\" ) config_table () \ud83d\udd17 The purpose of this function is to generate the 'Configuration' section in the readme file Source code in mk_readme/clsmkReadme.py def config_table (): '''The purpose of this function is to generate the 'Configuration' section in the readme file ''' configLst = [ [ \"Characteristic\" , \"Specs\" ],[ \"**NEMOGCM repository**\" , _CURREPO_ ], [ \"**Git Branch**\" , _NEMOBRANCH_ ],[ \"**Nemo-ocean repository**\" , _NEMOREPO_ ], [ \"**Nemo-ocean revision**\" , _NEMOREVISION_ ],[ \"**Components**\" , _COMPONENTS_ ], [ \"**Reference Configuration**\" , _REFCONFIG_ ], [ \"**CPP keys**\" , _CPPKEYS_ ], [ \"**Grid**\" , _GRID_ ], [ \"**Resolution**\" , _RESOLUTION_ ], [ \"**Horizontal Gridpoints**\" , _HGRIDPT_ ],[ \"**Vertical Levels**\" , _VGRIDPTZ_ ], [ \"**Atmospheric Condition**\" , _ATMOS_ ],[ \"**Time Step [s]**\" , _OCEANRDT_ ], [ \"**Passive Tracers**\" , _PASSIVTRACERS_ ],[ \"**Number of Nests**\" , _NESTNUMBER_ ], ] markdown = \" \\n \" + str ( \"| \" ) for e in configLst [ 0 ]: to_add = \" \" + str ( e ) + str ( \" |\" ) markdown += to_add markdown += \" \\n \" markdown += '|' for i in range ( len ( configLst [ 0 ])): markdown += str ( \"-------------- | \" ) markdown += \" \\n \" for entry in configLst [ 1 :]: markdown += str ( \"| \" ) for e in entry : to_add = str ( e ) + str ( \" | \" ) markdown += to_add markdown += \" \\n \" return markdown + \" \\n \" errmsg ( msg ) \ud83d\udd17 Displays an error message in RED and reset text colour - Message will be passed as a parameter Source code in mk_readme/clsmkReadme.py def errmsg ( msg ): ''' Displays an error message in RED and reset text colour - Message will be passed as a parameter''' print ( RED + ' \\n ERROR: ' + msg + ' \\n\\n ' + NORMAL ) fillenv () \ud83d\udd17 This function returns variables which will be used to create the readme file Source code in mk_readme/clsmkReadme.py def fillenv (): '''This function returns variables which will be used to create the readme file''' global _CONFNAME_ _CONFNAME_ = get_confname () global _CONTACT_ _CONTACT_ = get_username () + \" - \" + get_useremail () global _PURPOSE_ _PURPOSE_ = get_purpose () global _CURREPO_ _CURREPO_ = get_currepo () global _NEMOREPO_ _NEMOREPO_ = get_nemorepo () global _NEMOREVISION_ _NEMOREVISION_ = get_nemorevision () global _NEMOBRANCH_ _NEMOBRANCH_ = get_branch () global _COMPONENTS_ _COMPONENTS_ = get_components () global _REFCONFIG_ _REFCONFIG_ = get_refconfig () global _CPPKEYS_ _CPPKEYS_ = get_cppkeys () global _RESOLUTION_ _RESOLUTION_ = get_resolution () global _GRID_ _GRID_ = get_hgridtype () + \", \" + get_vgridtype () global _HGRIDPT_ _HGRIDPT_ = get_hgridpt () global _VGRIDPTZ_ _VGRIDPTZ_ = get_vgridpt () global _ATMOS_ _ATMOS_ = get_atmos () global _OCEANRDT_ _OCEANRDT_ = get_oceanrdt () global _NESTNUMBER_ _NESTNUMBER_ = get_nestnumber () global _PASSIVTRACERS_ _PASSIVTRACERS_ = get_passivetracers () global _zGITSERVER_ _zGITSERVER_ = get_zGITSERVER () global _zGITNMSPC_ _zGITNMSPC_ = get_zGITNMSPC () global _zPAGE_ _zPAGE_ = get_zPAGESRV () get_atmos () \ud83d\udd17 This function will return the number of surface boundary condition from namelist_cfg file. Returns unknown if value is not available Source code in mk_readme/clsmkReadme.py def get_atmos (): '''This function will return the number of surface boundary condition from namelist_cfg file. Returns unknown if value is not available''' stringToMatch = '&namsbc ' matchedLine = '' namsbcLst = [] #stores all elements in &namsbc lnLst = [] #stores all ln_ elements nnLst = [] #stores all nn_ elements vaxLst = [] #stores the prefix e.g. blk_core, ana etc.. v = \"\" #returns the line with .true. vax = \"\" default = \"\" #get list of namelists allCFG = getNameLists () #remove empty spaces allCFG = allCFG . replace ( \" \" , \"\" ) print ( \" \\n --> Defining the surface boundary condition. Accept with [ENTER]: \\n\\n \" ) f = open ( allCFG , \"r\" ) for line in f : if stringToMatch in line : matchedLine = line for line in f : if not ( line . startswith ( \"/\" )): namsbcLst . append ( line ) else : break #check for ln_ for item in namsbcLst : if item . find ( \"ln_\" ) != - 1 : lnLst . append ( item ) for i in lnLst : if \"true\" in i : v = i #get last part after the ln_ _index = v . find ( \"_\" ) eqIndex = v . find ( \"=\" ) vax = v [ _index + 1 : eqIndex ] #retrieve the value after _ vax = vax . strip () #remove white spaces vaxLst . append ( vax ) for v in vaxLst : if ( v == \"ana\" ): default = \"Analytical forcing\" #output = BOLD + \"Surface Boundary Condition: \" + NORMAL + \"\" + default #print(output) elif ( v == \"flx\" ): default = \"Flux formulation\" #output = BOLD + \"Surface Boundary Condition: \" + NORMAL + \"\" + default #print(output) elif ( v == \"blk_clio\" ): default = \"CLIO bulk formulation\" #output = BOLD + \"Surface Boundary Condition: \" + NORMAL + \"\" + default #print(output) elif ( v == \"blk_core\" ): default = \"CORE bulk formulation\" #output = BOLD + \"Surface Boundary Condition: \" + NORMAL + \"\" + default #print(output) elif ( v == \"blk_mfs\" ): default = \"MFS bulk formulation\" #output = BOLD + \"Surface Boundary Condition: \" + NORMAL + \"\" + default #print(output) elif ( v == \"cpl\" ): default = \"Coupled to atmosphere\" #output = BOLD + \"Surface Boundary Condition: \" + NORMAL + \"\" + default #print(output) elif ( v == \"mixcpl\" ): default = \"Forced & coupled atmosphere\" #output = BOLD + \"Surface Boundary Condition: \" + NORMAL + \"\" + default #print(output) elif ( v == \"rnf\" ): default = default + \" + separate runoff\" # check for nn_ for itemN in namsbcLst : if itemN . find ( \"nn_fwb\" ) != - 1 : #get the digits between = and . eqIndex = itemN . find ( \"=\" ) dotIndex = itemN . find ( \"!\" ) output = itemN [ eqIndex + 1 : dotIndex ] #retrieve the value after _ output = output . strip () #remove white spaces if default == \"\" : print ( PURPLE + \"Unknown\" + NORMAL ) return \"Unknown\" else : print ( PURPLE + default + \" + Freshwater Budget Correction (Mode \" + output + \")\" + NORMAL ) return str ( default + \" + Freshwater Budget Correction (Mode \" + output + \")\" ) get_branch () \ud83d\udd17 This function will return the branch number for this repo Source code in mk_readme/clsmkReadme.py def get_branch (): '''This function will return the branch number for this repo''' print ( \" \\n \" ) print ( \"--> Which branch are you using? Try to get it from git/svn. Accept with [ENTER]: \" ) if ( LNGIT == True ): repo = git . Repo ( \".\" , search_parent_directories = True ) default = repo . active_branch print ( PURPLE + str ( default ) + NORMAL ) return default #else: #print (\"LNGIT is false\") if ( LNSVN == True ): getBranchInfo = subprocess . check_output ( \"svn info | awk '/^URL:/ {print $2}'\" , shell = True ) . strip () getBranch = str ( getBranchInfo ) branchSplit = getBranch . split ( '/' ) #Get the last part of the string getBranch = branchSplit [ - 1 ] getBranch = getBranch . replace ( \"'\" , \"\" ) print ( PURPLE + str ( getBranch ) + NORMAL ) return getBranch get_components () \ud83d\udd17 This function returns the NEMO components for this repo from cfg.txt or ref_cfg.txt Source code in mk_readme/clsmkReadme.py def get_components (): '''This function returns the NEMO components for this repo from cfg.txt or ref_cfg.txt''' cfgPath = \"\" componentsLst = [] findExactComponent = [] componentsLst . append ( ' \\n ' ) print ( \" \\n --> What NEMO components are we using? Try to get a comma-separated list from ../cfg.txt. Accept with [ENTER]: \\n \" ) #get file path for /cfg.txt currentDirectory = getNemoConfig () confName = os . path . basename ( currentDirectory ) if release3 == True : cfgPath = open ( getNemoConfig () + \"/cfg.txt\" , \"r\" ) elif release4 == True : cfgPath = open ( getNemoConfig () + \"/ref_cfgs.txt\" , \"r\" ) for i in cfgPath : if exp in i : componentsLst . append ( i ) #go through the list to check for multiplies if ( len ( componentsLst ) == 1 ): #print(cfgNameLists) output = componentsLst else : #add each item to the list for i in range ( len ( componentsLst )): findExactComponent . append ( componentsLst [ i ]) #Search through each item for the exact configuration name for item in findExactComponent : #for i in item: pathSplit = item . split ( ' ' ) #Get the first element from the last output = str ( pathSplit [ 0 ]) print ( PURPLE + '' . join ([ str ( elem ) for elem in output ]) + NORMAL ) return '' . join ([ str ( elem ) for elem in output ]) get_confname () \ud83d\udd17 Returns the configuration name which is the variable stored as 'exp' Source code in mk_readme/clsmkReadme.py def get_confname (): '''Returns the configuration name which is the variable stored as 'exp' ''' print ( \" \\n --> What is the name you want to use for publishing this configuration with DRAKKARshare? Our first guess is, that it's the configuration name in the current path. Accept with [ENTER] or modify accordingly: \\n\\n \" ) currentDirectory = os . getcwd () confName = os . path . basename ( currentDirectory ) pathSplit = currentDirectory . split ( '/' ) print ( PURPLE + \"Configuration's name: \" + exp + \"\" + NORMAL ) #returns the chosen configuration by the use return exp get_cppkeys () \ud83d\udd17 This function searches for .fcm file and extracts the cpp keys Source code in mk_readme/clsmkReadme.py def get_cppkeys (): '''This function searches for .fcm file and extracts the cpp keys''' lastElement = \"\" cppList = [] cppList2 = [] findExactCPP = [] output = \"\" matchPath = \"\" multiples = False path = getNemoConfig () found = False for ( dirname , dirs , files ) in os . walk ( path ): # for (dirname, dirs, files) in os.walk('.'): for filename in files : if exp in filename : if filename . endswith ( '.fcm' ) : #ADD filename to list cppList . append ( filename ) if len ( cppList ) == 1 : thefile = os . path . join ( dirname , filename ) #open file and read contents f = open ( thefile , \"r\" ) cppkeysContents = f . read () f . close () else : #multiples is used when the config file appears more than once, e.g. ORCA2_LIM multiples = True #add each item to the list if ( multiples == True ): for i in range ( len ( cppList )): findExactCPP . append ( cppList [ i ]) #Search through each item for the exact CPP key for item in findExactCPP : #item e.g. cpp_GYRE_PISCES.fcm, split by first _ and . underscoreIndex = item . find ( \"_\" ) dotIndex = item . find ( \".\" ) res = item [ underscoreIndex + 1 : dotIndex ] if res == exp : found = True break if ( found == True ): matchPath = os . path . join ( path , res , item ) #print(matchPath) x = open ( matchPath , \"r\" ) cppkeysContents = x . read () x . close () #remove bld::tool::fppkeys by replacing this text empty text #sample: bld::tool::fppkeys key_diaeiv key_dynldf_c2d content = cppkeysContents . replace ( ' \\n ' , ' ' ) content = content . replace ( 'bld::tool::fppkeys ' , '' ) return '' . join ( str ( content )) get_currepo () \ud83d\udd17 The purpose of this function is to display the actual repo from were NEMO was cloned Source code in mk_readme/clsmkReadme.py def get_currepo (): '''The purpose of this function is to display the actual repo from were NEMO was cloned''' print ( \" \\n --> Are we in a git/svn working tree? And from which remote repository was NEMOGCM cloned? Try to get it from git/svn. Accept with [ENTER]: \\n \" ) if ( LNGIT == True ): try : repo = git . Repo ( \".\" , search_parent_directories = True ) remoteLocation = repo . remote ( \"origin\" ) . url default = remoteLocation if ( default != \"\" ) & ( LNGIT == True ): print ( PURPLE + \"This is a GIT Repo \" + NORMAL ) print ( PURPLE + \"Actual Repository = \" + default + \"\" + NORMAL ) return default except git . InvalidGitRepositoryError : print ( PURPLE + \"Not connected to GIT\" + NORMAL ) else : pass if ( LNSVN == True ): try : default = subprocess . check_output ( \"svn info | awk '/^URL:/ {print $2}'\" , shell = True ) . strip () #convert to string default = str ( default ) default = default . replace ( \"'\" , \"\" ) if ( default != \"\" ) & ( LNSVN == True ): print ( PURPLE + \"This is an SVN Repo \" + NORMAL ) print ( PURPLE + \"Actual Repository = \" + str ( default [ 1 :]) + NORMAL ) return default [ 1 :] else : print ( PURPLE + \"Not connected to SVN\" + NORMAL ) except svn . exception . SvnException : print ( \"This is not a working copy of SVN - Not connected to SVN\" ) else : pass get_hgridpt () \ud83d\udd17 This function will return the value corresponding to the hortizonatal grid type from namelist_cfg file. Returns unknown if value is not available Source code in mk_readme/clsmkReadme.py def get_hgridpt (): '''This function will return the value corresponding to the hortizonatal grid type from namelist_cfg file. Returns unknown if value is not available''' stringToMatch = 'namcfg' defaultx = \"\" defaulty = \"\" output = 0 #get list of namelists allCFG = getNameLists () #remove empty spaces allCFG = allCFG . replace ( \" \" , \"\" ) # print ( \" \\n --> Number of grid points in the horizontal. Accept with [ENTER]: \\n\\n \" ) f = open ( allCFG , \"r\" ) #print(\"\\n File name: \", line) for line in f : #find the section namcfg if stringToMatch in line : #print(line) for line in f : if \"jpidta\" in line : defaultx = line #continue printing until line matches \"/\" if \"jpjdta\" in line : #if endStringToMatch2 in line: defaulty = line break #extract digits only from defaultX outputX = 0 repl_str = re . compile ( '^\\d+$' ) line = defaultx . split () for word in line : match = re . search ( repl_str , word ) if match : outputX = float ( match . group ()) #extract digits only from defaultY outputY = 0 #repl_str = re.compile('\\d+.?\\d*') repl_str = re . compile ( '^\\d+$' ) #t = r'\\d+.?\\d*' line = defaulty . split () for word in line : match = re . search ( repl_str , word ) if match : outputY = float ( match . group ()) #multiply two points #output = outputX * outputY output = str ( outputX ) + \" x \" + str ( outputY ) #print(BOLD + \"Horizontal Grid Points (I x J):\" +NORMAL+ \" \"+ str(output)) if str ( output ) == \"\" : print ( PURPLE + \"Unknown\" + NORMAL ) return \"Unknown\" else : print ( PURPLE + str ( output ) + NORMAL ) return str ( output ) get_hgridtype () \ud83d\udd17 This function will return the value corresponding to the horizontal grid type from namelist_cfg file. Returns unknown if value is not available Source code in mk_readme/clsmkReadme.py def get_hgridtype (): '''This function will return the value corresponding to the horizontal grid type from namelist_cfg file. Returns unknown if value is not available''' stringToMatch = 'namcfg' matchedLine = '' endStringToMatch = \"/\" endStringToMatch2 = \"cp_cfg\" output = \"\" #get list of namelists allCFG = getNameLists () #remove empty spaces allCFG = allCFG . replace ( \" \" , \"\" ) result = \"\" #default = \"\" print ( \" \\n --> Horizontal grid type, e.g. ORCA for a global tri-polar grid. Accept our guess with [ENTER]: \\n\\n \" ) #go through the list of files with namelist_cfg # for line in allCFG: #for each file read.. f = open ( allCFG , \"r\" ) #print(\"File Name \", line) for line in f : if stringToMatch in line : matchedLine = line #print(\"Matched Line \", matchedLine) for line in f : output = line result = result + line #print(\"Output \", line) #outputS = BOLD + \"Horizontal Grid Type: \"+NORMAL+output #print(outputS) #hGridType.append(outputS) #continue printing until line matches \"/\" #if (line.startswith(\"/\")): if endStringToMatch2 in line : break x = result . split ( \"!\" ) #remove the dashed line newX = \"\" for i in x [ 1 ]: newX = newX + i . replace ( '-' , '' ) #return only the value in the \"\" and do not print cp_cfg _index = newX . find ( \"=\" ) default = newX [ _index + 1 :] #retrieve the value after = default = default . strip () #remove white space print ( PURPLE + default . strip () + NORMAL ) return default . strip () get_nemoGit () \ud83d\udd17 This function will search for the git file Source code in mk_readme/clsmkReadme.py def get_nemoGit (): '''This function will search for the git file ''' global nemoGitRepo pathSplit = \"\" #find Nemo/.git proc = subprocess . check_output ([ \"locate\" , \"-r\" , \"\\.git$\" ]) proc = str ( proc ) pathSplit = proc . split ( \" \\\\ n\" ) for p in pathSplit : if \"/NEMOGCM/.git\" in p : nemoGitRepo = p return nemoGitRepo get_nemorepo () \ud83d\udd17 This function displays the URL of the repository the NEMO was installed from Source code in mk_readme/clsmkReadme.py def get_nemorepo (): '''This function displays the URL of the repository the NEMO was installed from ''' print ( \" \\n\\n\\n --> What is the URL of the repository you installed NEMO from? Try to get it from git/svn. Accept with [ENTER]:\" ) if ( LNGIT == True ): getIndexHash = \"\" #command = '--grep=\"jussieu\" --pretty=oneline --abbrev-commit --reverse | cut -d ' ' -f 3 |head -n 1' proc = subprocess . check_output ([ \"git\" , \"log\" , \"--pretty=oneline\" , \"--abbrev-commit\" , \"--reverse\" ]) proc = str ( proc ) getSvnIDText = proc . find ( 'http' ) getIndexHash = proc . find ( '@' ) getUrl = proc [ getSvnIDText : getIndexHash ] print ( PURPLE + \"\" + getUrl + \"\" + NORMAL ) return ( getUrl ) if ( LNSVN == True ): #command = '--grep=\"jussieu\" --pretty=oneline --abbrev-commit --reverse | cut -d ' ' -f 3 |head -n 1' getURLsvn = subprocess . check_output ( \"svn info | awk '/^URL:/ {print $2}'\" , shell = True ) . strip () getURLsvn = str ( getURLsvn ) getURLsvn = getURLsvn . replace ( \"'\" , \"\" ) print ( PURPLE + \"\" + str ( getURLsvn [ 1 :]) + \"\" + NORMAL ) return ( getURLsvn [ 1 :]) get_nemorevision () \ud83d\udd17 This function will display the revision number for the current NEMO version Source code in mk_readme/clsmkReadme.py def get_nemorevision (): '''This function will display the revision number for the current NEMO version ''' print ( \" \\n\\n\\n --> What is the NEMO revision you're currently using? Try to get it from git/svn history. Accept with [ENTER]:\" ) if ( LNGIT == True ): try : proc = subprocess . check_output ([ \"git\" , \"log\" , \"--pretty=oneline\" , \"--abbrev-commit\" , \"--reverse\" ]) proc = str ( proc ) getSvnIDText = proc . find ( 'http' ) getIndexHash = proc . find ( '#' ) nemoRev1 = proc [ getSvnIDText : getIndexHash ] getAT = nemoRev1 . find ( '@' ) getspace = nemoRev1 . find ( ' ' ) nemoRev2 = nemoRev1 [ getAT + 1 : getspace ] print ( PURPLE + nemoRev2 + NORMAL ) return ( nemoRev2 ) except git . InvalidGitRepositoryError : print ( PURPLE + \"Not connected to GIT\" + NORMAL ) except OSError as e : print ( \"Error - \" , e ) if ( LNSVN == True ): try : nemoRev = subprocess . check_output ( \"svn info | awk '/^Revision:/ {print $2}'\" , shell = True ) . strip () nemoRev = str ( nemoRev ) nemoRev = nemoRev . replace ( \"'\" , \"\" ) print ( PURPLE + str ( nemoRev [ 1 :]) + NORMAL ) return ( nemoRev [ 1 :]) except svn . exception . SvnException : print ( \"This is not an svn repo \\n \" ) get_nestnumber () \ud83d\udd17 This function will ask for user input to enter number of AGRIF Nests. Returns 0 if value is not available Source code in mk_readme/clsmkReadme.py def get_nestnumber (): '''This function will ask for user input to enter number of AGRIF Nests. Returns 0 if value is not available''' default = 0 print ( \" \\n --> How many \" + BOLD + \"AGRIF nests \" + NORMAL + \" are embedded? Accept our guess with [ENTER] or [M]odify accordingly: \\n\\n \" ) print ( PURPLE + \"Nest Number: \" + NORMAL + \"is \" + str ( default )) choice = input () choice = choice . lower () if choice == 'm' : default = input ( \"Input value: \" ) return default else : return default get_oceanrdt () \ud83d\udd17 This function will return the length of the general ocean time step for dynamics from namelist_cfg file. Returns unknown if value is not available Source code in mk_readme/clsmkReadme.py def get_oceanrdt () : '''This function will return the length of the general ocean time step for dynamics from namelist_cfg file. Returns unknown if value is not available''' stringToMatch = 'namdom' defaultT = \"\" output = 0 allCFG = getNameLists () #remove empty spaces allCFG = allCFG . replace ( \" \" , \"\" ) print ( \" \\n --> The length of the general ocean time step for dynamics. Accept with [ENTER]: \\n\\n \" ) f = open ( allCFG , \"r\" ) for line in f : if stringToMatch in line : #print(line) for line in f : if \"rn_rdt\" in line : defaultT = line #get the digits between = and . eqIndex = defaultT . find ( \"=\" ) dotIndex = defaultT . find ( \".\" ) output = defaultT [ eqIndex + 1 : dotIndex ] #retrieve the value after _ output = output . strip () #remove white spaces #print(BOLD + \"Time Step for Dynamics [sec]: \" + NORMAL + \"\" + str(output)) break #get the digits between = and . eqIndex = defaultT . find ( \"=\" ) dotIndex = defaultT . find ( \".\" ) output = defaultT [ eqIndex + 1 : dotIndex ] #retrieve the value after _ output = output . strip () #remove white spaces if str ( output ) == \"\" : print ( PURPLE + \"Unknown\" + NORMAL ) return \"Unknown\" else : print ( PURPLE + str ( output ) + NORMAL ) return str ( output ) get_passivetracers () \ud83d\udd17 This function will ask for user input which additional passive tracers are implemented. Returns unknown if value is not available Source code in mk_readme/clsmkReadme.py def get_passivetracers (): '''This function will ask for user input which additional passive tracers are implemented. Returns unknown if value is not available''' default = \"Unknown\" print ( \" \\n --> Which additional passive tracers are implemented? Accept our guess with [ENTER] or [M]odify accordingly: \\n\\n \" ) print ( PURPLE + \"List of passive tracers (TOP): \" + NORMAL + \"is \" + default ) choice = input () choice = choice . lower () if choice == 'm' : default = input ( \"Input value: \" ) return default else : return default get_purpose () \ud83d\udd17 This function creates a text file to store the purpose of the readme file or reads the existing text file Source code in mk_readme/clsmkReadme.py def get_purpose (): '''This function creates a text file to store the purpose of the readme file or reads the existing text file ''' pathS = pathlib . Path () . absolute () if ( LNGIT == True ) and ( CURRCONFIG == False ): dirName = str ( pathS ) + \"/CONFIG/\" + exp + \"/.includes\" elif ( LNSVN == True ) and ( CURRCONFIG == False ) and ( release3 == True ): dirName = str ( pathS ) + \"/NEMOGCM/CONFIG/\" + exp + \"/.includes\" elif ( LNSVN == True ) and ( CURRCONFIG == False ) and ( release4 == True ): dirName = str ( pathS ) + \"/cfgs/\" + exp + \"/.includes\" #if current script is stored in one of the configurations elif ( CURRCONFIG == True ): dirName = str ( pathS ) + \"/.includes\" try : # Create target Directory os . mkdir ( dirName ) purpose = input ( \" \\n\\n --> What's the purpose of this configuration?: \\n \" ) f = open ( dirName + \"/.recall_purpose.txt\" , \"w\" ) f . write ( purpose ) f = open ( dirName + \"/.recall_purpose.txt\" , \"r\" ) purpose = f . read () print ( PURPLE + purpose + NORMAL ) return ( purpose ) #if file already exists, read the contents and provide an option for modification (overwritten) except FileExistsError : f = open ( dirName + \"/.recall_purpose.txt\" , \"r\" ) #ask if content is as expected print ( \" \\n\\n --> What's the purpose of this configuration? Trying to remember last answer\" ) purpose = f . read () print ( PURPLE + purpose + NORMAL ) choice = input ( \"Accept with [ENTER] or modify accordingly (press [M] to modify): \" ) choice = choice . lower () if choice == 'm' : purpose = input ( \"Enter a new purpose, this will be overwritten: \" ) f = open ( dirName + \"/.recall_purpose.txt\" , \"w\" ) f . write ( purpose ) f = open ( dirName + \"/.recall_purpose.txt\" , \"r\" ) purpose = f . read () print ( PURPLE + purpose + NORMAL ) return ( purpose ) else : return ( purpose ) f . close () else : print ( \"Unable to create this file, check admin rights\" ) get_refconfig () \ud83d\udd17 This function asks for user input to return the reference configuration for a particular configuration. This may also be left blank Source code in mk_readme/clsmkReadme.py def get_refconfig (): '''This function asks for user input to return the reference configuration for a particular configuration. This may also be left blank ''' zrefconfname = \"\" zrefconfurl = \"\" zrefconfname = input ( \"--> If there is a reference configuration this particular configuration is based on, please type the name. Otherwise leave it blank by typing [ENTER]. \\n \" ) zrefconfurl = input ( \"--> If there is a reference configuration this particular configuration is based on, please type the URL. Otherwise leave it blank by typing [ENTER]. \\n \" ) return zrefconfname + \" - \" + zrefconfurl get_resolution () \ud83d\udd17 This function will return the value corresponding to the resolution of the horizontal grid from namelist_cfg file. Returns unknown if value is not available Source code in mk_readme/clsmkReadme.py def get_resolution (): '''This function will return the value corresponding to the resolution of the horizontal grid from namelist_cfg file. Returns unknown if value is not available ''' stringToMatch = 'namcfg' defaultK = \"\" output = 0 #get list of namelists allCFG = getNameLists () #remove empty spaces allCFG = allCFG . replace ( \" \" , \"\" ) print ( \" \\n --> The resolution of the horizontal grid. Accept with [ENTER]: \\n\\n \" ) f = open ( allCFG , \"r\" ) print ( \"all CFG is \" , allCFG ) for line in f : #find the section namcfg if stringToMatch in line : #print(line) for line in f : if \"jp_cfg\" in line : defaultK = line break #print(defaultK) #extract digits only from defaultK output = 0 repl_str = re . compile ( '^\\d+$' ) line = defaultK . split () for word in line : match = re . search ( repl_str , word ) if match : output = float ( match . group ()) #print(BOLD + \"Vertical Grid Points (K): \" + NORMAL + \"\" + str(output)) print ( PURPLE + str ( output ) + NORMAL ) return str ( output ) get_useremail () \ud83d\udd17 This function returns the user email, if available in the config file Source code in mk_readme/clsmkReadme.py def get_useremail (): '''This function returns the user email, if available in the config file ''' if ( LNGIT == True ): try : repo = git . Repo ( \".\" , search_parent_directories = True ) print ( \" \\n --> What is your email address? We try to get it from git. Accept with [ENTER] or modify accordingly: \\n\\n \" ) reader = repo . config_reader () default = reader . get_value ( 'user' , 'email' ) output = PURPLE + \"User's email :\" + default + NORMAL print ( output ) return default except : try : choice = input ( \"Config file does not include the email address, please amend accordingly in .git > config. Proceed with [ENTER] to continue with 'Unknown' or abort with CTRL-C: \" ) except KeyboardInterrupt : print ( \"You pressed Ctrl+C!\" ) finally : return \"Unknown\" else : pass if ( LNSVN == True ): try : email = input ( \" \\n --> Enter your email address (temporarily) or press [Ctrl-C] to exit and update through git-init \\n\\n \" ) return email except KeyboardInterrupt : print ( \"Exit.. \" ) get_username () \ud83d\udd17 This function returns the username, if available in the config file Source code in mk_readme/clsmkReadme.py def get_username (): '''This function returns the username, if available in the config file ''' if ( LNGIT == True ): try : repo = git . Repo ( \".\" , search_parent_directories = True ) print ( \" \\n --> What is your full name? We try to get it from git. Accept with [ENTER] or modify accordingly: \\n\\n \" ) reader = repo . config_reader () default = reader . get_value ( 'user' , 'name' ) output = PURPLE + \"User's Full Name :\" + default + NORMAL # return output print ( output ) return default except : try : choice = input ( \"Config file does not include the user name, please amend accordingly in .git > config. Proceed with [ENTER] to continue with 'Unknown' or abort with CTRL-C: \" ) except KeyboardInterrupt : print ( \"You pressed Ctrl+C!\" ) finally : return \"Unknown\" else : pass if ( LNSVN == True ): try : username = input ( \" \\n --> Enter your full name (temporarily) or press [Ctrl-C] to exit and update through git-init \\n\\n \" ) return username except KeyboardInterrupt : print ( \"Exit..\" ) get_vgridpt () \ud83d\udd17 This function will return the number of grid points in vertical grid from namelist_cfg file. Returns unknown if value is not available Source code in mk_readme/clsmkReadme.py def get_vgridpt (): '''This function will return the number of grid points in vertical grid from namelist_cfg file. Returns unknown if value is not available''' stringToMatch = 'namcfg' defaultK = \"\" output = 0 #get list of namelists allCFG = getNameLists () #remove empty spaces allCFG = allCFG . replace ( \" \" , \"\" ) print ( \" \\n --> Number of grid points in the vertical? Accept with [ENTER]: \\n\\n \" ) f = open ( allCFG , \"r\" ) for line in f : #find the section namcfg if stringToMatch in line : #print(line) for line in f : if \"jpkdta\" in line : defaultK = line break #print(defaultK) #extract digits only from defaultK output = 0 repl_str = re . compile ( '^\\d+$' ) line = defaultK . split () for word in line : match = re . search ( repl_str , word ) if match : output = float ( match . group ()) #print(BOLD + \"Vertical Grid Points (K): \" + NORMAL + \"\" + str(output)) if str ( output ) == \"\" : print ( PURPLE + \"Unknown\" + NORMAL ) return \"Unknown\" else : print ( PURPLE + str ( output ) + NORMAL ) return str ( output ) get_vgridtype () \ud83d\udd17 This function will return the value corresponding to the vertical grid type from namelist_cfg file. Returns unknown if value is not available Source code in mk_readme/clsmkReadme.py def get_vgridtype (): '''This function will return the value corresponding to the vertical grid type from namelist_cfg file. Returns unknown if value is not available''' stringToMatch = '&namzgr ' default = \"\" #get list of namelists allCFG = getNameLists () #remove empty spaces allCFG = allCFG . replace ( \" \" , \"\" ) result = \"\" print ( \" \\n --> Vertical grid type. Accept with [ENTER]: \\n\\n \" ) f = open ( allCFG , \"r\" ) for line in f : if line . startswith ( stringToMatch ): # print(\"line is \", line) # comma on the end prevents the double spacing from printing a file line for line in f : # #namzgrLst.append(line) if ( \".true.\" in line ): #print(\"Filtered \", line) #add to list to extract #lnLst.append(line) for ext in line : if ( \"zco\" in line ): default = \"zco (z-coordinate with full steps)\" #print(BOLD + \"Vertical Grid Type: \" + NORMAL + \"\" + default) break elif ( \"zps\" in line ): default = \"zps (z-coordinate with partial steps)\" #print(BOLD + \"Vertical Grid Type: \" + NORMAL + \"\" + default) break elif ( \"sco\" in line ): default = \"sco (s- or hybrid z-s-coordinate)\" #print(BOLD + \"Vertical Grid Type: \" + NORMAL + \"\" + default) break #not clear - refer to bash script elif ( \"isfcav\" in line ): default = \"ice shelf cavity\" #print(BOLD + \"Vertical Grid Type: \" + NORMAL + \"\" + default) break if line . startswith ( \"/\" ): break # stop this inner for loop; outer loop picks up on the next line if default == \"\" : print ( PURPLE + \"Unknown\" + NORMAL ) return \"Unknown\" else : print ( PURPLE + default + NORMAL ) return default get_zGITNMSPC () \ud83d\udd17 This function returns the value of a variable zGITNMSPC Source code in mk_readme/clsmkReadme.py def get_zGITNMSPC (): '''This function returns the value of a variable zGITNMSPC''' zGITSERVER = get_zGITSERVER () if zGITSERVER == \"gitlab.de\" : zGITNMSPC = \"DRAKKAshare\" elif zGITSERVER == \"git.geomar.de\" : zGITNMSPC = \"NEMO/EXP\" return zGITNMSPC get_zGITSERVER () \ud83d\udd17 This function returns the value of a variable zGITSERVER Source code in mk_readme/clsmkReadme.py def get_zGITSERVER (): '''This function returns the value of a variable zGITSERVER''' if ( LNGIT == True ): zGITSERVER = \"git.geomar.de\" else : zGITSERVER = \"gitlab.de\" return zGITSERVER get_zPAGESRV () \ud83d\udd17 This function returns the value of a variable zPAGESRV Source code in mk_readme/clsmkReadme.py def get_zPAGESRV (): '''This function returns the value of a variable zPAGESRV''' zGITSERVER = get_zGITSERVER () if zGITSERVER == \"gitlab.de\" : zPAGESRV = \"https://drakkarshare.gitlab.io\" zPAGE = zPAGESRV + \"/\" + _CONFNAME_ elif zGITSERVER == \"git.geomar.de\" : zPAGESRV = \"#\" zPAGE = \"| [Static Page](\" + zPAGESRV + \"/\" + _CONFNAME_ + \")\" return zPAGE getAllConfigFolders () \ud83d\udd17 This function will return a list of configurations, and eventually user will choose which configuration s/he would like to work with: (e.g. AMM12, ORCA2_LIM_CFC_C14b, GYRE, ORCA025.L46.LIM2vp.CORE.XIOS1, ORCA2_LIM etc.. Display only the configurations that include EXP00 folder Source code in mk_readme/clsmkReadme.py def getAllConfigFolders (): '''This function will return a list of configurations, and eventually user will choose which configuration s/he would like to work with: (e.g. AMM12, ORCA2_LIM_CFC_C14b, GYRE, ORCA025.L46.LIM2vp.CORE.XIOS1, ORCA2_LIM etc.. Display only the configurations that include EXP00 folder''' configFolders = [] listWithAllDir = [] listOnlyExp00 = [] configPath = getNemoConfig () #print(\"Config path\" , configPath) for r , d , f in os . walk ( configPath ): for directory in d : if \"EXP00\" in d : #release3 listWithAllDir . append ( os . path . join ( r , directory )) elif \"EXPREF\" in d : #release 4 listWithAllDir . append ( os . path . join ( r , directory )) for i in listWithAllDir : if \"EXP00\" in i : #remove the EXP00 listOnlyExp00 . append ( i ) elif \"EXPREF\" in i : #remove the EXPREF listOnlyExp00 . append ( i ) for c in listOnlyExp00 : last = c . split ( '/' ) configFolders . append ( last [ - 2 ]) #sort configFolders configFolders . sort () return configFolders getNameLists () \ud83d\udd17 This function searches for namelist_cfg file and extracts the namelist path for the chosen configuration Source code in mk_readme/clsmkReadme.py def getNameLists (): ''' This function searches for namelist_cfg file and extracts the namelist path for the chosen configuration''' #to retrieve only the cfg of the chosen configuration cfgNameLists = [] findExactNameList = [] output = \"\" path2 = getNemoConfig () for ( dirname , dirs , files ) in os . walk ( path2 ): #for (dirname, dirs, files) in os.walk('.'): for filename in files : if filename . startswith ( '1_namelist_cfg' ): pass #ignore elif 'namelist_cfg' in filename : thefile = os . path . join ( dirname , filename ) if exp in thefile : cfgNameLists . append ( thefile ) #go through the list to check for entries containing part of the chosen name if ( len ( cfgNameLists ) == 1 ): #print(cfgNameLists) output = cfgNameLists else : #add each item to the list for i in range ( len ( cfgNameLists )): findExactNameList . append ( cfgNameLists [ i ]) #Search through each item for the exact configuration name for item in findExactNameList : #for i in item: pathSplit = item . split ( '/' ) #Get the third element from the last if exp == pathSplit [ - 3 ]: #print(item) output = item #return full path #convert list to str return '' . join ([ str ( elem ) for elem in output ]) getNemoConfig () \ud83d\udd17 This function will look for the directory 'NEMOGCM/CONFIG' for release 3 and 'cfgs' for release 4 anywhere in the system Source code in mk_readme/clsmkReadme.py def getNemoConfig (): '''This function will look for the directory 'NEMOGCM/CONFIG' for release 3 and 'cfgs' for release 4 anywhere in the system''' global release3 , release4 rootPath = pathlib . Path () . absolute () fname = [] configPath = \"\" for root , d_names , f_names in os . walk ( rootPath ): for f in d_names : fname . append ( os . path . join ( root , f )) for i in fname : if \"NEMOGCM/CONFIG\" in i : configPath = i release3 = True #if this is True, the script is being run as a release 3 break elif \"cfgs\" in i : configPath = i release4 = True #if this is True, the script is being run as a release 4 break path = configPath #if release is 4 remove the last two folders since the file structure is different in rel3 and rel4 if (( release3 == True ) or ( release4 == True )) and ( scriptLoc != None ): pathSplit = os . path . dirname ( path ) pathUpdated , tail = os . path . split ( pathSplit ) return pathUpdated else : return path hr () \ud83d\udd17 displays a list of * across the page and moves cursor to next line Source code in mk_readme/clsmkReadme.py def hr (): '''displays a list of * across the page and moves cursor to next line''' command = [ 'tput' , 'cols' ] width = int ( subprocess . check_output ( command )) for i in range ( width ): { print ( \"*\" , end = \"\" ) } print ( \" \\n \" ) indent ( text ) \ud83d\udd17 Indents text to the right Source code in mk_readme/clsmkReadme.py def indent ( text ): '''Indents text to the right''' text = textwrap . indent ( text , ' ' * 4 )[ 4 - 1 :] print ( text ) list_inputfiles () \ud83d\udd17 The purpose of this function is to generate the 'Input Files' section in the readme file Source code in mk_readme/clsmkReadme.py def list_inputfiles (): '''The purpose of this function is to generate the 'Input Files' section in the readme file ''' #count 0 is the header count = 1 col1 = \"\" col2 = \"\" col3 = \"\" path2 = os . getcwd () parent = os . path . dirname ( path2 ) #parent directory #for (dirname, dirs, files) in os.walk('.'): for ( dirname , dirs , files ) in os . walk ( parent ): rowsLst . append ([]) rowsLst . append ([]) rowsLst . append ([]) for filename in files : if filename . endswith ( '.def' ) : thefile = os . path . join ( dirname , filename ) #list path with .def extension with open ( thefile ) as f : url = \"\" infile_nemo = \"\" #print all contents of the file for line in f : line = line . strip () #access only the lines that are not commented and empty if not ( line . startswith ( '#' )): if len ( line ) != 0 : allFieldsFirstLine = line . split ( \",\" ) try : infile_nemo = allFieldsFirstLine [ 0 ] #1st element #print(\"infile_nemo: \" + infile_nemo) col1 = infile_nemo if infile_nemo == \"\" or infile_nemo == \" \\\\ \" : infile_nemo = next ( f ) #move to next line else : infile_nemo = allFieldsFirstLine [ 1 ] except : #print(\"Error for infile_nemo\") print ( \"infile Nemo: \" + infile_nemo ) try : url = allFieldsFirstLine [ 2 ] #tableListing.append(url) if not ( url == \" \\\\ \" or url == \"\" or url == \"' \\' \" ): #print(\"this is the original line\") url = allFieldsFirstLine [ 2 ] else : #print(\"this is the next line\") url = next ( f ) #move to next line #print(\"url: \" + url.strip()) col3 = url . strip () + \" \\n \" except : #two exceptions to cater for in file #./ORCA025.L46.LIM2vp.CFCSF6.JRA.XIOS2/EXP00/input.def #print(\"Skip two lines section\") url = next ( f ) url = next ( f ) #print(\"URL : \", url.strip()) col3 = url . strip () + \" \\n \" #add data to table col1 = col1 . strip () col2 = \"---\" col3 = col3 . strip () if 'thredds' in col3 : col3up = col3 pass elif '@' in col3 : getIndex = col3 . find ( '@' ) col3 = col3 [ getIndex + 1 :] #replace : with / col3 = col3 . replace ( ':' , '/' ) #get last part of the string lastPart = col3 . split ( \"/\" )[ - 1 ] lastIndex = col3 . find ( lastPart ) col3 = col3 [: lastIndex - 1 ] col3up = lastPart + \"<b>\" + \" in \" + \"</b>\" + col3 #col3up = lastPart + \"<b>\" + \" in \" + \"</b>\" + \"<a href=\" + \"'\" + col3 + \"'\" + \">\" + col3 + \"</a>\" rowsLst [ count ] . append ( col1 ) rowsLst [ count ] . append ( col2 ) rowsLst [ count ] . append ( col3up ) count = count + 1 #### Create the table ####### rowsLst [ 0 ] . append ( \"**NEMO Input File**\" ) rowsLst [ 0 ] . append ( \"**Reference (DOI)**\" ) rowsLst [ 0 ] . append ( \"**Download**\" ) #this list will not contain empty tuples and will be used in the markdown template rowsLst2 = [ e for e in rowsLst if e ] return make_markdown_table ( rowsLst2 ) main () \ud83d\udd17 This function will be called if the script is stored in the root Source code in mk_readme/clsmkReadme.py def main (): '''This function will be called if the script is stored in the root''' check_inputDef_exists () #check if input.def is part of this directory if check_inputDef_exists () == True : exp = chooseConfigFolder () #print(ask_exp00()) if ask_exp00 ( exp ) == True : template () else : print ( \"Exiting..Please start again\" ) else : print ( \"Input.def file does not exist, create this file to be able to proceed\" ) mainconfig () \ud83d\udd17 This function will be called if the script is initially saved in one of the configuration folders Source code in mk_readme/clsmkReadme.py def mainconfig (): '''This function will be called if the script is initially saved in one of the configuration folders''' check_inputDef_exists () #check if input.def is part of this directory if check_inputDef_exists () == True : if ask_exp00 ( exp ) == True : template () else : print ( \"Exiting..Please start again\" ) else : print ( \"Input.def file does not exist, create this file to be able to proceed\" ) make_markdown_table ( rowsLst2 ) \ud83d\udd17 This function is used to format the tables in the readme file to replicate the markdown format Source code in mk_readme/clsmkReadme.py def make_markdown_table ( rowsLst2 ): '''This function is used to format the tables in the readme file to replicate the markdown format ''' markdown = \" \\n \" + str ( \"| \" ) for e in rowsLst2 [ 0 ]: to_add = \" \" + str ( e ) + str ( \" |\" ) markdown += to_add markdown += \" \\n \" markdown += '|' for i in range ( len ( rowsLst2 [ 0 ])): markdown += str ( \"-------------- | \" ) markdown += \" \\n \" for entry in rowsLst2 [ 1 :]: markdown += str ( \"| \" ) for e in entry : to_add = str ( e ) + str ( \" | \" ) markdown += to_add markdown += \" \\n \" return markdown + \" \\n \" prep_note () \ud83d\udd17 The purpose of this function is to display a list of prerequistes to successfully render a readme file Source code in mk_readme/clsmkReadme.py def prep_note (): '''The purpose of this function is to display a list of prerequistes to successfully render a readme file''' uName = os . uname () . nodename uName = str ( uName ) print ( \" \\n \" ) hr () print ( \" \\n \" ) center ( \"Prepare DRAKKARshare upload\" ) print ( \" \\n \" ) hr () print ( \" \\n\\n Before we begin, we have to make sure, that the following \" + ULINE + \"conditions are fulfilled\" + NORMAL + \" and you have the \" + ULINE + \"essential information\" + NORMAL + \" at hand right now:\" ) print ( \" \\n\\n \" ) indent ( \" [ ] \" \"You have access to \" + BOLD + BLACK + \"at least one gitlab server\" + NORMAL + \", like \" + BLUE + zGITSERVER + \"/\" + zGITNMSPC + NORMAL + \" and your \" + BOLD + BLACK + \"public ssh-key \" + NORMAL + \"from this host (\" + uName + \") has been deposited under your gitlab profile.\" ) print ( \" \\n \" ) indent ( \" [ ] \" \"Configuration-specific \" + BOLD + BLACK + \" input files \" + NORMAL + \" are \" + ULINE + \"publicly accessible\" + NORMAL + \" at least for members of a specific gitlab group) and you have a \" + BOLD + BLACK + \" reference\" + NORMAL + \" (e.g. DOI) and a \" + BOLD + BLACK + \" Download-URL \" + NORMAL + \" for each file.\" ) print ( \" \\n \" ) indent ( \" [ ] \" \"You know the \" + BOLD + BLACK + \"NEMO revision\" + NORMAL + \" and the \" + BOLD + BLACK + \"URL\" + NORMAL + \" you've installed it from (if it can't be determined automatically, because you're not within a svn or git working directory)\" ) print ( \" \\n \" ) indent ( \" [ ] \" \"If your configuration is build upon another \" + BOLD + BLACK + \"reference configuration \" + NORMAL + \" you'll need the exact name and a reference URL (e.g. another DRAKKARshare repository)\" ) print ( \" \\n \" ) indent ( \" [ ] \" \"Is INPUT.def part of this configuration? \" ) print ( \" \\n \" ) answer = input ( BOLD + RED + \"Do you confirm, that you meet the conditions above? [Y|N]:\" + NORMAL ) answer = answer . lower () if ( answer == \"n\" ): exit () else : return answer sucssmsg ( msg ) \ud83d\udd17 Displays an error message in GREEN and reset text colour - Message will be passed as a parameter Source code in mk_readme/clsmkReadme.py def sucssmsg ( msg ): ''' Displays an error message in GREEN and reset text colour - Message will be passed as a parameter''' print ( GREEN + ' \\n SUCCESS: ' + msg + ' \\n\\n ' + NORMAL ) template () \ud83d\udd17 The purpose of this function is to create a markup template with values generated from previous functions Source code in mk_readme/clsmkReadme.py def template (): '''The purpose of this function is to create a markup template with values generated from previous functions''' readme = Template ( \"\"\" # {{_COMPONENTS_}} ___ [Purpose](#purpose) | [Contact](#contact) | [License](#license) | [Configuration](#configuration) | [Input Files](#input-files) | [Diagnostics](#diagnostics) | [Installation](#installation) {{_zPAGE_}} ____ # Purpose {{_PURPOSE_}} # Contact {{_CONTACT_}} # License **By downloading this repository and using this code you agree to the following conditions.** The code in this project is based on the [NEMO](http://www.nemo-ocean.eu) software (Copyright (c) Centre National de la Recherche Scientifique CNRS). The original code as well as the contribution to this code in this project are licensed under the conditions of [CeCILL](http://www.cecill.info). The person stated under '*Contact*' above is the owner of the intellectual property rights of these contributions and **must be informed afore** publishing and **must be cited** in every published work that is based completely or partially on the modifications and additional code provided by this configuration. Usage is at one's own risk. # Configuration {{config_table}} The default experiment settings can be found in the [EXP00](EXP00) folder. The modified code is located in the [MY_SRC](MY_SRC) directory. # Input Files * **NEMO Input File:** File names as they are expected by NEMO * **Reference:** Citation for an article or report, webpage or even better: DOI * **Download:** Link for direct downloading the file (no user-interaction preferred to make it script-compliant) The actual file names should follow the *Guidelines for Naming DRAKKAR Input File Names*: \"\\`NemoName\\` \\\\ _\\`NemoVersion\\` \\\\ _\\`ConfigGrid\\` \\\\ _\\`Version\\`.nc\" {{list_inputfiles}} # Diagnostics See [DIAG](DIAG) for some standard diagnostics from a simulation with this configuraton. # Installation There are plenty of ways how to install a local copy of this configuration: 1. You can [clone it with git](#install-with-git) (regardless of whether your NEMOGCM path is already under git control or not). 2. Or you just download an archive from the web interface. In some cases there are different versions of the same configuration in separate branches (e.g. to reflect different NEMO revisions); **check the branches/tags** menu on the web interface or use the git branch and checkout commands to select the version you're interested in. <!--For further details, please read the [HELP pages](https://gitlab.com/DRAKKARshare/help/edit/master/GetConfiguration.md).--> ## Install with \\`git\\` **{- IMPORTANT: -}** The following guidelines assume, that you're already registered at https://{{_zGITSERVER_}} and your public SSH key has been deposited under your gitlab profile. #### (A) NEMOGCM already under git control If your **NEMOGCM installation is already under git control** you cannot clone a different repository into the existing working copy. Instead, you can use \\`git subtree\\` to inject files from another remote repository into a particular sub-folder of your existing working tree. Within NEMOGCM directory: **Option - With git commands** ~~~bash cd NEMOGCM git remote add -f remote_{{_CONFNAME_}} git@{{_zGITSERVER_}}:{{_zGITNMSPC_}}/{{_CONFNAME_}}.git # add remote git subtree add --prefix CONFIG/{{_CONFNAME_}} remote_{{_CONFNAME_}} {{_NEMOBRANCH_}}:-master --squash # donwload master branch into sub-folder cd CONFIG/{{_CONFNAME_}} remote_{{_CONFNAME_}} cat cfg.txt >> ../cfg.txt ~~~ > In this case, you keep the information from where you have downloaded the reference configuration (see \\`git remote -v\\`). Or even shorter, without keeping remote source information (not recommended): ~~~bash cd NEMOGCM git subtree add --prefix CONFIG/{{_CONFNAME_}} git@{{_zGITSERVER_}}:{{_zGITNMSPC_}}/{{_CONFNAME_}}.git {{_NEMOBRANCH_}}:-master --squash cd CONFIG/{{_CONFNAME_}} remote_{{_CONFNAME_}} cat cfg.txt >> ../cfg.txt ~~~ #### (B) NEMOGCM not under git control If your NEMOGCM installation **is not under git control already**, you can clone this configuration using the URL specified on the project's front page: ~~~bash cd NEMOGCM/CONFIG git clone git@{{_zGITSERVER_}}:{{_zGITNMSPC_}}/{{_CONFNAME_}}.git cat {{_CONFNAME_}}/cfg.txt >> cfg.txt ~~~ This wil create a new configuration folder, which can be used as a reference case for \\`makenemo -r\\`. Make sure, you add this confiuration to the local registry file \\`cfg.txt\\` before invoking \\`makenemo\\`. #### Other revisions The revision that will be installed, is the most recent one from the **master** branch. If you're seeking another branch/revision of this configuration (e.g. an older one), you can browse available branches/tags via the web-interface or list alternative branches on the command line and swap available branches/tags easily with \\`checkout\\`: ~~~bash cd {{_CONFNAME_}} git branches -r git checkout otherBranch ~~~ Note: *origin/HEAD* in the output listing is not a branch in its own but points to the default branch (master branch in most cases). \"\"\" ) fillenv () pathS = pathlib . Path () . absolute () if ( LNGIT == True ) and ( CURRCONFIG == False ): READMEOUT = str ( pathS ) + \"/CONFIG/\" + exp + \"/README_\" + exp + \".md\" elif ( LNSVN == True ) and ( CURRCONFIG == False ) and ( release3 == True ): READMEOUT = str ( pathS ) + \"/NEMOGCM/CONFIG/\" + exp + \"/README_\" + exp + \".md\" elif ( LNSVN == True ) and ( CURRCONFIG == False ) and ( release4 == True ): READMEOUT = str ( pathS ) + \"/cfgs/\" + exp + \"/README_\" + exp + \".md\" #if current script is stored in one of the configurations elif ( CURRCONFIG == True ): READMEOUT = str ( pathS ) + \"/README_\" + exp + \".md\" with open ( READMEOUT , \"w\" ) as f : f . write ( readme . render ( _CONFNAME_ = _CONFNAME_ , _CONTACT_ = _CONTACT_ , _PURPOSE_ = _PURPOSE_ , _CURREPO_ = _CURREPO_ , _NEMOREPO_ = _NEMOREPO_ , _NEMOREVISION_ = _NEMOREVISION_ , _NEMOBRANCH_ = _NEMOBRANCH_ , _COMPONENTS_ = _COMPONENTS_ , _REFCONFIG_ = _REFCONFIG_ , _CPPKEYS_ = _CPPKEYS_ , _RESOLUTION_ = _RESOLUTION_ , _GRID_ = _GRID_ , _HGRIDPT_ = _HGRIDPT_ , _VGRIDPTZ_ = _VGRIDPTZ_ , _ATMOS_ = _ATMOS_ , _OCEANRDT_ = _OCEANRDT_ , _NESTNUMBER_ = _NESTNUMBER_ , _PASSIVTRACERS_ = _PASSIVTRACERS_ , list_inputfiles = list_inputfiles (), config_table = config_table (), _zGITSERVER_ = _zGITSERVER_ , _zGITNMSPC_ = _zGITNMSPC_ , _zPAGE_ = _zPAGE_ )) print ( \"README file created\" ) trim ( text ) \ud83d\udd17 If any white spaces are present at the end of a line, the purpose of this function is to remove them Source code in mk_readme/clsmkReadme.py def trim ( text ): '''If any white spaces are present at the end of a line, the purpose of this function is to remove them''' text = text . strip () return text warnmsg ( msg ) \ud83d\udd17 Displays an error message in YELLOW and reset text colour - Message will be passed as a parameter Source code in mk_readme/clsmkReadme.py def warnmsg ( msg ): ''' Displays an error message in YELLOW and reset text colour - Message will be passed as a parameter''' print ( YELLOW + ' \\n WARNING: ' + msg + ' \\n\\n ' + NORMAL ) : : my_package.my_module.MyClass handler: python selection: members: - method_a - method_b rendering: show_root_heading: false show_source: false : : my_package.my_module.MyClass handler: python rendering: show_root_heading: false show_source: false : : MY_PACKAGE.your_module handler: python rendering: show_root_heading: false show_source: false","title":"`mkReadme`"},{"location":"api-mkreadme.html#mkreadme","text":"","title":"mkReadme"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme","text":"Created on Fri Jan 10 10:31:20 2020 @author: luciennemicallef","title":"mk_readme.clsmkReadme.MakeReadme"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.color","text":"This class stores a list of colours and font styles","title":"color"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.ask_exp00","text":"exp is the configuration name Source code in mk_readme/clsmkReadme.py def ask_exp00 ( exp ): '''exp is the configuration name''' '''The purpose of this function is to show all directories for the chosen configuration ''' print ( \" \\n Chosen configuration is : \" , exp ) #list to store all the directories inside this configuration listWithAllDir = [] configPath = getNemoConfig () + \"/\" + exp #print(\"Config path\" , configPath) print ( \" \\n Directories for : \" , exp ) for r , d , f in os . walk ( configPath ): for directory in d : listWithAllDir . append ( directory ) #sort list listWithAllDir . sort () for i in listWithAllDir : print ( i ) choice = input ( \" \\n --> Are you sure that this is the configuration you would like to work with? Proceed with [Y] or [N] \\n\\n \" ) choice = choice . lower () if choice == 'y' : return True else : return False","title":"ask_exp00()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.center","text":"Centers the text to the midddle of the screen Source code in mk_readme/clsmkReadme.py def center ( text ): '''Centers the text to the midddle of the screen''' command = [ 'tput' , 'cols' ] width = int ( subprocess . check_output ( command )) print ( text . center ( width ), \" \\n \" )","title":"center()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.check_confdir","text":"The purpose of this function is to check if the script is in a configuration sub-folder in NEMOGCM/CONFIG Source code in mk_readme/clsmkReadme.py def check_confdir (): '''The purpose of this function is to check if the script is in a configuration sub-folder in NEMOGCM/CONFIG ''' pathLst = [] currentDirectory = os . getcwd () words = currentDirectory . split ( \"/\" , 4 ) for w in words : pathLst . append ( w ) lastElement = str ( pathLst [ len ( pathLst ) - 1 ]) #should be CONFIG print ( \"last Element \" , lastElement ) if ( lastElement != \"CONFIG\" ): errmsg ( \"It seems, we are not in a configuration sub-folder of NEMOGCM/CONFIG. I'm lost. \" + BOLD + \"Please run this script within a configuration folder!\" + NORMAL )","title":"check_confdir()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.check_EXPref","text":"This function will check whether the current location contains, EXP00 and EXPREF folder Source code in mk_readme/clsmkReadme.py def check_EXPref (): '''This function will check whether the current location contains, EXP00 and EXPREF folder''' path = os . getcwd () expRef = False for root , directories , files in os . walk ( path ): for folder in directories : #release 3 if \"EXP00\" in folder : expRef = True break #release 4 elif \"EXPREF\" in folder : expRef = True break return expRef","title":"check_EXPref()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.check_gitorsvn","text":"The purpose of this function is to check whether the current script is stored as a git repo or as an svn repo Source code in mk_readme/clsmkReadme.py def check_gitorsvn (): '''The purpose of this function is to check whether the current script is stored as a git repo or as an svn repo''' '''if LNGIT is True - the script is stored as a git repo''' '''if LNSVN is True - the script is stored as an svn svn repo''' global repo try : repo = git . Repo ( \".\" , search_parent_directories = True ) except git . InvalidGitRepositoryError : print ( BLUE + \"This is not a git repo \\n \" + NORMAL ) else : print ( BLUE + \"This is a Git Repo\" + NORMAL ) global LNGIT LNGIT = True if ( LNGIT == False ): try : repo = subprocess . check_output ( \"svn info | awk '/^Kind:/ {print $2}'\" , shell = True ) . strip () except svn . exception . SvnException : print ( BLUE + \"This is not an svn repo \\n \" + NORMAL ) except OSError as e : print ( \"Error - \" , e ) else : print ( BLUE + \"This is an SVN Repo\" + NORMAL ) global LNSVN LNSVN = True","title":"check_gitorsvn()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.check_inputDef_exists","text":"This function checks whether input.def file exists in the directory of the chosen configuration. If not the script will exit. Source code in mk_readme/clsmkReadme.py def check_inputDef_exists (): '''This function checks whether input.def file exists in the directory of the chosen configuration. If not the script will exit.''' if ( CURRCONFIG == True ): parent = os . path . dirname ( os . getcwd ()) else : parent = os . getcwd () #print(\"Parent \", parent) found = False files = [] #r=root, d=directories, f = files for r , d , f in os . walk ( parent ): for file in f : if 'input.def' in file : found = True files . append ( os . path . join ( r , file )) if found == True : return True else : return False","title":"check_inputDef_exists()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.check_prereq","text":"This function will check that EXP00 or EXPREF directory is present in the current file structure Source code in mk_readme/clsmkReadme.py def check_prereq (): '''This function will check that EXP00 or EXPREF directory is present in the current file structure ''' if ( EXPref != \"EXP00\" ) and ( EXPref != \"EXPREF\" ): errmsg ( \"No EXP00/EXPREF folder with default settings was found. Please create one and re-run this script.\" ) else : cwflag = 0 #check_confdir() git_X = git . __version__ if len ( git_X ) > 0 : sucssmsg ( \"GIT found\" ) else : errmsg ( \"GIT not found\" ) svn_X = svn . __version__ if len ( svn_X ) > 0 : sucssmsg ( \"SVN found\" ) else : errmsg ( \"SVN not found\" ) ssh_X = os . system ( 'ssh -V' ) if len ( str ( ssh_X )) > 0 : sucssmsg ( \"SSH found\" ) else : errmsg ( \"SSH not found\" ) curl_X = pycurl . version if len ( curl_X ) > 0 : sucssmsg ( \"CURL found\" ) else : errmsg ( \"CURL not found\" ) cwflag = cwflag + 1 wget_X = wget . __version__ if len ( wget_X ) > 0 : sucssmsg ( \"WGET found\" ) else : errmsg ( \"WGET not found\" ) cwflag = cwflag + 1 if ( cwflag > 0 ): errmsg ( \"Neither CURL nor WGET was found. Abort\" ) m4_X = os . system ( 'm4 --version' ) if len ( str ( m4_X )) > 0 : sucssmsg ( \"m4 found\" ) else : errmsg ( \"m4 not found\" ) global zGITSERVER zGITSERVER = get_zGITSERVER () global zGITNMSPC zGITNMSPC = get_zGITNMSPC () print ( \"zGITSERVER: \" , zGITSERVER ) print ( \"zGITNMSPC: \" , zGITNMSPC )","title":"check_prereq()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.checkScriptLocation","text":"The purpose of this function is to check whether the script is being run from a particular configuration Source code in mk_readme/clsmkReadme.py def checkScriptLocation (): '''The purpose of this function is to check whether the script is being run from a particular configuration''' path2 = os . getcwd () configName = os . path . basename ( path2 ) #print(\"This script is saved in \", configName) for x in getAllConfigFolders (): if x == configName : global CURRCONFIG CURRCONFIG = True return x","title":"checkScriptLocation()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.chooseConfigFolder","text":"This function will ask the user to select one configuration from the list generated from getAllConfigFolders. The chosen config is stored in a global variable called exp which will be used throughout the script Source code in mk_readme/clsmkReadme.py def chooseConfigFolder (): '''This function will ask the user to select one configuration from the list generated from getAllConfigFolders. The chosen config is stored in a global variable called exp which will be used throughout the script''' valid = False global exp configList = [] print ( \" \\n\\n Config List: \\n \" ) for i in getAllConfigFolders (): configList . append ( i ) print ( i ) while valid == False : exp = input ( \" \\n Choose one of the above configurations : \\n\\n \" ) if exp in configList : valid = True return exp else : print ( \"Invalid entry, input has to match exactly (including capital letters)\" )","title":"chooseConfigFolder()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.config_table","text":"The purpose of this function is to generate the 'Configuration' section in the readme file Source code in mk_readme/clsmkReadme.py def config_table (): '''The purpose of this function is to generate the 'Configuration' section in the readme file ''' configLst = [ [ \"Characteristic\" , \"Specs\" ],[ \"**NEMOGCM repository**\" , _CURREPO_ ], [ \"**Git Branch**\" , _NEMOBRANCH_ ],[ \"**Nemo-ocean repository**\" , _NEMOREPO_ ], [ \"**Nemo-ocean revision**\" , _NEMOREVISION_ ],[ \"**Components**\" , _COMPONENTS_ ], [ \"**Reference Configuration**\" , _REFCONFIG_ ], [ \"**CPP keys**\" , _CPPKEYS_ ], [ \"**Grid**\" , _GRID_ ], [ \"**Resolution**\" , _RESOLUTION_ ], [ \"**Horizontal Gridpoints**\" , _HGRIDPT_ ],[ \"**Vertical Levels**\" , _VGRIDPTZ_ ], [ \"**Atmospheric Condition**\" , _ATMOS_ ],[ \"**Time Step [s]**\" , _OCEANRDT_ ], [ \"**Passive Tracers**\" , _PASSIVTRACERS_ ],[ \"**Number of Nests**\" , _NESTNUMBER_ ], ] markdown = \" \\n \" + str ( \"| \" ) for e in configLst [ 0 ]: to_add = \" \" + str ( e ) + str ( \" |\" ) markdown += to_add markdown += \" \\n \" markdown += '|' for i in range ( len ( configLst [ 0 ])): markdown += str ( \"-------------- | \" ) markdown += \" \\n \" for entry in configLst [ 1 :]: markdown += str ( \"| \" ) for e in entry : to_add = str ( e ) + str ( \" | \" ) markdown += to_add markdown += \" \\n \" return markdown + \" \\n \"","title":"config_table()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.errmsg","text":"Displays an error message in RED and reset text colour - Message will be passed as a parameter Source code in mk_readme/clsmkReadme.py def errmsg ( msg ): ''' Displays an error message in RED and reset text colour - Message will be passed as a parameter''' print ( RED + ' \\n ERROR: ' + msg + ' \\n\\n ' + NORMAL )","title":"errmsg()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.fillenv","text":"This function returns variables which will be used to create the readme file Source code in mk_readme/clsmkReadme.py def fillenv (): '''This function returns variables which will be used to create the readme file''' global _CONFNAME_ _CONFNAME_ = get_confname () global _CONTACT_ _CONTACT_ = get_username () + \" - \" + get_useremail () global _PURPOSE_ _PURPOSE_ = get_purpose () global _CURREPO_ _CURREPO_ = get_currepo () global _NEMOREPO_ _NEMOREPO_ = get_nemorepo () global _NEMOREVISION_ _NEMOREVISION_ = get_nemorevision () global _NEMOBRANCH_ _NEMOBRANCH_ = get_branch () global _COMPONENTS_ _COMPONENTS_ = get_components () global _REFCONFIG_ _REFCONFIG_ = get_refconfig () global _CPPKEYS_ _CPPKEYS_ = get_cppkeys () global _RESOLUTION_ _RESOLUTION_ = get_resolution () global _GRID_ _GRID_ = get_hgridtype () + \", \" + get_vgridtype () global _HGRIDPT_ _HGRIDPT_ = get_hgridpt () global _VGRIDPTZ_ _VGRIDPTZ_ = get_vgridpt () global _ATMOS_ _ATMOS_ = get_atmos () global _OCEANRDT_ _OCEANRDT_ = get_oceanrdt () global _NESTNUMBER_ _NESTNUMBER_ = get_nestnumber () global _PASSIVTRACERS_ _PASSIVTRACERS_ = get_passivetracers () global _zGITSERVER_ _zGITSERVER_ = get_zGITSERVER () global _zGITNMSPC_ _zGITNMSPC_ = get_zGITNMSPC () global _zPAGE_ _zPAGE_ = get_zPAGESRV ()","title":"fillenv()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.get_atmos","text":"This function will return the number of surface boundary condition from namelist_cfg file. Returns unknown if value is not available Source code in mk_readme/clsmkReadme.py def get_atmos (): '''This function will return the number of surface boundary condition from namelist_cfg file. Returns unknown if value is not available''' stringToMatch = '&namsbc ' matchedLine = '' namsbcLst = [] #stores all elements in &namsbc lnLst = [] #stores all ln_ elements nnLst = [] #stores all nn_ elements vaxLst = [] #stores the prefix e.g. blk_core, ana etc.. v = \"\" #returns the line with .true. vax = \"\" default = \"\" #get list of namelists allCFG = getNameLists () #remove empty spaces allCFG = allCFG . replace ( \" \" , \"\" ) print ( \" \\n --> Defining the surface boundary condition. Accept with [ENTER]: \\n\\n \" ) f = open ( allCFG , \"r\" ) for line in f : if stringToMatch in line : matchedLine = line for line in f : if not ( line . startswith ( \"/\" )): namsbcLst . append ( line ) else : break #check for ln_ for item in namsbcLst : if item . find ( \"ln_\" ) != - 1 : lnLst . append ( item ) for i in lnLst : if \"true\" in i : v = i #get last part after the ln_ _index = v . find ( \"_\" ) eqIndex = v . find ( \"=\" ) vax = v [ _index + 1 : eqIndex ] #retrieve the value after _ vax = vax . strip () #remove white spaces vaxLst . append ( vax ) for v in vaxLst : if ( v == \"ana\" ): default = \"Analytical forcing\" #output = BOLD + \"Surface Boundary Condition: \" + NORMAL + \"\" + default #print(output) elif ( v == \"flx\" ): default = \"Flux formulation\" #output = BOLD + \"Surface Boundary Condition: \" + NORMAL + \"\" + default #print(output) elif ( v == \"blk_clio\" ): default = \"CLIO bulk formulation\" #output = BOLD + \"Surface Boundary Condition: \" + NORMAL + \"\" + default #print(output) elif ( v == \"blk_core\" ): default = \"CORE bulk formulation\" #output = BOLD + \"Surface Boundary Condition: \" + NORMAL + \"\" + default #print(output) elif ( v == \"blk_mfs\" ): default = \"MFS bulk formulation\" #output = BOLD + \"Surface Boundary Condition: \" + NORMAL + \"\" + default #print(output) elif ( v == \"cpl\" ): default = \"Coupled to atmosphere\" #output = BOLD + \"Surface Boundary Condition: \" + NORMAL + \"\" + default #print(output) elif ( v == \"mixcpl\" ): default = \"Forced & coupled atmosphere\" #output = BOLD + \"Surface Boundary Condition: \" + NORMAL + \"\" + default #print(output) elif ( v == \"rnf\" ): default = default + \" + separate runoff\" # check for nn_ for itemN in namsbcLst : if itemN . find ( \"nn_fwb\" ) != - 1 : #get the digits between = and . eqIndex = itemN . find ( \"=\" ) dotIndex = itemN . find ( \"!\" ) output = itemN [ eqIndex + 1 : dotIndex ] #retrieve the value after _ output = output . strip () #remove white spaces if default == \"\" : print ( PURPLE + \"Unknown\" + NORMAL ) return \"Unknown\" else : print ( PURPLE + default + \" + Freshwater Budget Correction (Mode \" + output + \")\" + NORMAL ) return str ( default + \" + Freshwater Budget Correction (Mode \" + output + \")\" )","title":"get_atmos()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.get_branch","text":"This function will return the branch number for this repo Source code in mk_readme/clsmkReadme.py def get_branch (): '''This function will return the branch number for this repo''' print ( \" \\n \" ) print ( \"--> Which branch are you using? Try to get it from git/svn. Accept with [ENTER]: \" ) if ( LNGIT == True ): repo = git . Repo ( \".\" , search_parent_directories = True ) default = repo . active_branch print ( PURPLE + str ( default ) + NORMAL ) return default #else: #print (\"LNGIT is false\") if ( LNSVN == True ): getBranchInfo = subprocess . check_output ( \"svn info | awk '/^URL:/ {print $2}'\" , shell = True ) . strip () getBranch = str ( getBranchInfo ) branchSplit = getBranch . split ( '/' ) #Get the last part of the string getBranch = branchSplit [ - 1 ] getBranch = getBranch . replace ( \"'\" , \"\" ) print ( PURPLE + str ( getBranch ) + NORMAL ) return getBranch","title":"get_branch()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.get_components","text":"This function returns the NEMO components for this repo from cfg.txt or ref_cfg.txt Source code in mk_readme/clsmkReadme.py def get_components (): '''This function returns the NEMO components for this repo from cfg.txt or ref_cfg.txt''' cfgPath = \"\" componentsLst = [] findExactComponent = [] componentsLst . append ( ' \\n ' ) print ( \" \\n --> What NEMO components are we using? Try to get a comma-separated list from ../cfg.txt. Accept with [ENTER]: \\n \" ) #get file path for /cfg.txt currentDirectory = getNemoConfig () confName = os . path . basename ( currentDirectory ) if release3 == True : cfgPath = open ( getNemoConfig () + \"/cfg.txt\" , \"r\" ) elif release4 == True : cfgPath = open ( getNemoConfig () + \"/ref_cfgs.txt\" , \"r\" ) for i in cfgPath : if exp in i : componentsLst . append ( i ) #go through the list to check for multiplies if ( len ( componentsLst ) == 1 ): #print(cfgNameLists) output = componentsLst else : #add each item to the list for i in range ( len ( componentsLst )): findExactComponent . append ( componentsLst [ i ]) #Search through each item for the exact configuration name for item in findExactComponent : #for i in item: pathSplit = item . split ( ' ' ) #Get the first element from the last output = str ( pathSplit [ 0 ]) print ( PURPLE + '' . join ([ str ( elem ) for elem in output ]) + NORMAL ) return '' . join ([ str ( elem ) for elem in output ])","title":"get_components()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.get_confname","text":"Returns the configuration name which is the variable stored as 'exp' Source code in mk_readme/clsmkReadme.py def get_confname (): '''Returns the configuration name which is the variable stored as 'exp' ''' print ( \" \\n --> What is the name you want to use for publishing this configuration with DRAKKARshare? Our first guess is, that it's the configuration name in the current path. Accept with [ENTER] or modify accordingly: \\n\\n \" ) currentDirectory = os . getcwd () confName = os . path . basename ( currentDirectory ) pathSplit = currentDirectory . split ( '/' ) print ( PURPLE + \"Configuration's name: \" + exp + \"\" + NORMAL ) #returns the chosen configuration by the use return exp","title":"get_confname()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.get_cppkeys","text":"This function searches for .fcm file and extracts the cpp keys Source code in mk_readme/clsmkReadme.py def get_cppkeys (): '''This function searches for .fcm file and extracts the cpp keys''' lastElement = \"\" cppList = [] cppList2 = [] findExactCPP = [] output = \"\" matchPath = \"\" multiples = False path = getNemoConfig () found = False for ( dirname , dirs , files ) in os . walk ( path ): # for (dirname, dirs, files) in os.walk('.'): for filename in files : if exp in filename : if filename . endswith ( '.fcm' ) : #ADD filename to list cppList . append ( filename ) if len ( cppList ) == 1 : thefile = os . path . join ( dirname , filename ) #open file and read contents f = open ( thefile , \"r\" ) cppkeysContents = f . read () f . close () else : #multiples is used when the config file appears more than once, e.g. ORCA2_LIM multiples = True #add each item to the list if ( multiples == True ): for i in range ( len ( cppList )): findExactCPP . append ( cppList [ i ]) #Search through each item for the exact CPP key for item in findExactCPP : #item e.g. cpp_GYRE_PISCES.fcm, split by first _ and . underscoreIndex = item . find ( \"_\" ) dotIndex = item . find ( \".\" ) res = item [ underscoreIndex + 1 : dotIndex ] if res == exp : found = True break if ( found == True ): matchPath = os . path . join ( path , res , item ) #print(matchPath) x = open ( matchPath , \"r\" ) cppkeysContents = x . read () x . close () #remove bld::tool::fppkeys by replacing this text empty text #sample: bld::tool::fppkeys key_diaeiv key_dynldf_c2d content = cppkeysContents . replace ( ' \\n ' , ' ' ) content = content . replace ( 'bld::tool::fppkeys ' , '' ) return '' . join ( str ( content ))","title":"get_cppkeys()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.get_currepo","text":"The purpose of this function is to display the actual repo from were NEMO was cloned Source code in mk_readme/clsmkReadme.py def get_currepo (): '''The purpose of this function is to display the actual repo from were NEMO was cloned''' print ( \" \\n --> Are we in a git/svn working tree? And from which remote repository was NEMOGCM cloned? Try to get it from git/svn. Accept with [ENTER]: \\n \" ) if ( LNGIT == True ): try : repo = git . Repo ( \".\" , search_parent_directories = True ) remoteLocation = repo . remote ( \"origin\" ) . url default = remoteLocation if ( default != \"\" ) & ( LNGIT == True ): print ( PURPLE + \"This is a GIT Repo \" + NORMAL ) print ( PURPLE + \"Actual Repository = \" + default + \"\" + NORMAL ) return default except git . InvalidGitRepositoryError : print ( PURPLE + \"Not connected to GIT\" + NORMAL ) else : pass if ( LNSVN == True ): try : default = subprocess . check_output ( \"svn info | awk '/^URL:/ {print $2}'\" , shell = True ) . strip () #convert to string default = str ( default ) default = default . replace ( \"'\" , \"\" ) if ( default != \"\" ) & ( LNSVN == True ): print ( PURPLE + \"This is an SVN Repo \" + NORMAL ) print ( PURPLE + \"Actual Repository = \" + str ( default [ 1 :]) + NORMAL ) return default [ 1 :] else : print ( PURPLE + \"Not connected to SVN\" + NORMAL ) except svn . exception . SvnException : print ( \"This is not a working copy of SVN - Not connected to SVN\" ) else : pass","title":"get_currepo()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.get_hgridpt","text":"This function will return the value corresponding to the hortizonatal grid type from namelist_cfg file. Returns unknown if value is not available Source code in mk_readme/clsmkReadme.py def get_hgridpt (): '''This function will return the value corresponding to the hortizonatal grid type from namelist_cfg file. Returns unknown if value is not available''' stringToMatch = 'namcfg' defaultx = \"\" defaulty = \"\" output = 0 #get list of namelists allCFG = getNameLists () #remove empty spaces allCFG = allCFG . replace ( \" \" , \"\" ) # print ( \" \\n --> Number of grid points in the horizontal. Accept with [ENTER]: \\n\\n \" ) f = open ( allCFG , \"r\" ) #print(\"\\n File name: \", line) for line in f : #find the section namcfg if stringToMatch in line : #print(line) for line in f : if \"jpidta\" in line : defaultx = line #continue printing until line matches \"/\" if \"jpjdta\" in line : #if endStringToMatch2 in line: defaulty = line break #extract digits only from defaultX outputX = 0 repl_str = re . compile ( '^\\d+$' ) line = defaultx . split () for word in line : match = re . search ( repl_str , word ) if match : outputX = float ( match . group ()) #extract digits only from defaultY outputY = 0 #repl_str = re.compile('\\d+.?\\d*') repl_str = re . compile ( '^\\d+$' ) #t = r'\\d+.?\\d*' line = defaulty . split () for word in line : match = re . search ( repl_str , word ) if match : outputY = float ( match . group ()) #multiply two points #output = outputX * outputY output = str ( outputX ) + \" x \" + str ( outputY ) #print(BOLD + \"Horizontal Grid Points (I x J):\" +NORMAL+ \" \"+ str(output)) if str ( output ) == \"\" : print ( PURPLE + \"Unknown\" + NORMAL ) return \"Unknown\" else : print ( PURPLE + str ( output ) + NORMAL ) return str ( output )","title":"get_hgridpt()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.get_hgridtype","text":"This function will return the value corresponding to the horizontal grid type from namelist_cfg file. Returns unknown if value is not available Source code in mk_readme/clsmkReadme.py def get_hgridtype (): '''This function will return the value corresponding to the horizontal grid type from namelist_cfg file. Returns unknown if value is not available''' stringToMatch = 'namcfg' matchedLine = '' endStringToMatch = \"/\" endStringToMatch2 = \"cp_cfg\" output = \"\" #get list of namelists allCFG = getNameLists () #remove empty spaces allCFG = allCFG . replace ( \" \" , \"\" ) result = \"\" #default = \"\" print ( \" \\n --> Horizontal grid type, e.g. ORCA for a global tri-polar grid. Accept our guess with [ENTER]: \\n\\n \" ) #go through the list of files with namelist_cfg # for line in allCFG: #for each file read.. f = open ( allCFG , \"r\" ) #print(\"File Name \", line) for line in f : if stringToMatch in line : matchedLine = line #print(\"Matched Line \", matchedLine) for line in f : output = line result = result + line #print(\"Output \", line) #outputS = BOLD + \"Horizontal Grid Type: \"+NORMAL+output #print(outputS) #hGridType.append(outputS) #continue printing until line matches \"/\" #if (line.startswith(\"/\")): if endStringToMatch2 in line : break x = result . split ( \"!\" ) #remove the dashed line newX = \"\" for i in x [ 1 ]: newX = newX + i . replace ( '-' , '' ) #return only the value in the \"\" and do not print cp_cfg _index = newX . find ( \"=\" ) default = newX [ _index + 1 :] #retrieve the value after = default = default . strip () #remove white space print ( PURPLE + default . strip () + NORMAL ) return default . strip ()","title":"get_hgridtype()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.get_nemoGit","text":"This function will search for the git file Source code in mk_readme/clsmkReadme.py def get_nemoGit (): '''This function will search for the git file ''' global nemoGitRepo pathSplit = \"\" #find Nemo/.git proc = subprocess . check_output ([ \"locate\" , \"-r\" , \"\\.git$\" ]) proc = str ( proc ) pathSplit = proc . split ( \" \\\\ n\" ) for p in pathSplit : if \"/NEMOGCM/.git\" in p : nemoGitRepo = p return nemoGitRepo","title":"get_nemoGit()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.get_nemorepo","text":"This function displays the URL of the repository the NEMO was installed from Source code in mk_readme/clsmkReadme.py def get_nemorepo (): '''This function displays the URL of the repository the NEMO was installed from ''' print ( \" \\n\\n\\n --> What is the URL of the repository you installed NEMO from? Try to get it from git/svn. Accept with [ENTER]:\" ) if ( LNGIT == True ): getIndexHash = \"\" #command = '--grep=\"jussieu\" --pretty=oneline --abbrev-commit --reverse | cut -d ' ' -f 3 |head -n 1' proc = subprocess . check_output ([ \"git\" , \"log\" , \"--pretty=oneline\" , \"--abbrev-commit\" , \"--reverse\" ]) proc = str ( proc ) getSvnIDText = proc . find ( 'http' ) getIndexHash = proc . find ( '@' ) getUrl = proc [ getSvnIDText : getIndexHash ] print ( PURPLE + \"\" + getUrl + \"\" + NORMAL ) return ( getUrl ) if ( LNSVN == True ): #command = '--grep=\"jussieu\" --pretty=oneline --abbrev-commit --reverse | cut -d ' ' -f 3 |head -n 1' getURLsvn = subprocess . check_output ( \"svn info | awk '/^URL:/ {print $2}'\" , shell = True ) . strip () getURLsvn = str ( getURLsvn ) getURLsvn = getURLsvn . replace ( \"'\" , \"\" ) print ( PURPLE + \"\" + str ( getURLsvn [ 1 :]) + \"\" + NORMAL ) return ( getURLsvn [ 1 :])","title":"get_nemorepo()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.get_nemorevision","text":"This function will display the revision number for the current NEMO version Source code in mk_readme/clsmkReadme.py def get_nemorevision (): '''This function will display the revision number for the current NEMO version ''' print ( \" \\n\\n\\n --> What is the NEMO revision you're currently using? Try to get it from git/svn history. Accept with [ENTER]:\" ) if ( LNGIT == True ): try : proc = subprocess . check_output ([ \"git\" , \"log\" , \"--pretty=oneline\" , \"--abbrev-commit\" , \"--reverse\" ]) proc = str ( proc ) getSvnIDText = proc . find ( 'http' ) getIndexHash = proc . find ( '#' ) nemoRev1 = proc [ getSvnIDText : getIndexHash ] getAT = nemoRev1 . find ( '@' ) getspace = nemoRev1 . find ( ' ' ) nemoRev2 = nemoRev1 [ getAT + 1 : getspace ] print ( PURPLE + nemoRev2 + NORMAL ) return ( nemoRev2 ) except git . InvalidGitRepositoryError : print ( PURPLE + \"Not connected to GIT\" + NORMAL ) except OSError as e : print ( \"Error - \" , e ) if ( LNSVN == True ): try : nemoRev = subprocess . check_output ( \"svn info | awk '/^Revision:/ {print $2}'\" , shell = True ) . strip () nemoRev = str ( nemoRev ) nemoRev = nemoRev . replace ( \"'\" , \"\" ) print ( PURPLE + str ( nemoRev [ 1 :]) + NORMAL ) return ( nemoRev [ 1 :]) except svn . exception . SvnException : print ( \"This is not an svn repo \\n \" )","title":"get_nemorevision()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.get_nestnumber","text":"This function will ask for user input to enter number of AGRIF Nests. Returns 0 if value is not available Source code in mk_readme/clsmkReadme.py def get_nestnumber (): '''This function will ask for user input to enter number of AGRIF Nests. Returns 0 if value is not available''' default = 0 print ( \" \\n --> How many \" + BOLD + \"AGRIF nests \" + NORMAL + \" are embedded? Accept our guess with [ENTER] or [M]odify accordingly: \\n\\n \" ) print ( PURPLE + \"Nest Number: \" + NORMAL + \"is \" + str ( default )) choice = input () choice = choice . lower () if choice == 'm' : default = input ( \"Input value: \" ) return default else : return default","title":"get_nestnumber()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.get_oceanrdt","text":"This function will return the length of the general ocean time step for dynamics from namelist_cfg file. Returns unknown if value is not available Source code in mk_readme/clsmkReadme.py def get_oceanrdt () : '''This function will return the length of the general ocean time step for dynamics from namelist_cfg file. Returns unknown if value is not available''' stringToMatch = 'namdom' defaultT = \"\" output = 0 allCFG = getNameLists () #remove empty spaces allCFG = allCFG . replace ( \" \" , \"\" ) print ( \" \\n --> The length of the general ocean time step for dynamics. Accept with [ENTER]: \\n\\n \" ) f = open ( allCFG , \"r\" ) for line in f : if stringToMatch in line : #print(line) for line in f : if \"rn_rdt\" in line : defaultT = line #get the digits between = and . eqIndex = defaultT . find ( \"=\" ) dotIndex = defaultT . find ( \".\" ) output = defaultT [ eqIndex + 1 : dotIndex ] #retrieve the value after _ output = output . strip () #remove white spaces #print(BOLD + \"Time Step for Dynamics [sec]: \" + NORMAL + \"\" + str(output)) break #get the digits between = and . eqIndex = defaultT . find ( \"=\" ) dotIndex = defaultT . find ( \".\" ) output = defaultT [ eqIndex + 1 : dotIndex ] #retrieve the value after _ output = output . strip () #remove white spaces if str ( output ) == \"\" : print ( PURPLE + \"Unknown\" + NORMAL ) return \"Unknown\" else : print ( PURPLE + str ( output ) + NORMAL ) return str ( output )","title":"get_oceanrdt()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.get_passivetracers","text":"This function will ask for user input which additional passive tracers are implemented. Returns unknown if value is not available Source code in mk_readme/clsmkReadme.py def get_passivetracers (): '''This function will ask for user input which additional passive tracers are implemented. Returns unknown if value is not available''' default = \"Unknown\" print ( \" \\n --> Which additional passive tracers are implemented? Accept our guess with [ENTER] or [M]odify accordingly: \\n\\n \" ) print ( PURPLE + \"List of passive tracers (TOP): \" + NORMAL + \"is \" + default ) choice = input () choice = choice . lower () if choice == 'm' : default = input ( \"Input value: \" ) return default else : return default","title":"get_passivetracers()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.get_purpose","text":"This function creates a text file to store the purpose of the readme file or reads the existing text file Source code in mk_readme/clsmkReadme.py def get_purpose (): '''This function creates a text file to store the purpose of the readme file or reads the existing text file ''' pathS = pathlib . Path () . absolute () if ( LNGIT == True ) and ( CURRCONFIG == False ): dirName = str ( pathS ) + \"/CONFIG/\" + exp + \"/.includes\" elif ( LNSVN == True ) and ( CURRCONFIG == False ) and ( release3 == True ): dirName = str ( pathS ) + \"/NEMOGCM/CONFIG/\" + exp + \"/.includes\" elif ( LNSVN == True ) and ( CURRCONFIG == False ) and ( release4 == True ): dirName = str ( pathS ) + \"/cfgs/\" + exp + \"/.includes\" #if current script is stored in one of the configurations elif ( CURRCONFIG == True ): dirName = str ( pathS ) + \"/.includes\" try : # Create target Directory os . mkdir ( dirName ) purpose = input ( \" \\n\\n --> What's the purpose of this configuration?: \\n \" ) f = open ( dirName + \"/.recall_purpose.txt\" , \"w\" ) f . write ( purpose ) f = open ( dirName + \"/.recall_purpose.txt\" , \"r\" ) purpose = f . read () print ( PURPLE + purpose + NORMAL ) return ( purpose ) #if file already exists, read the contents and provide an option for modification (overwritten) except FileExistsError : f = open ( dirName + \"/.recall_purpose.txt\" , \"r\" ) #ask if content is as expected print ( \" \\n\\n --> What's the purpose of this configuration? Trying to remember last answer\" ) purpose = f . read () print ( PURPLE + purpose + NORMAL ) choice = input ( \"Accept with [ENTER] or modify accordingly (press [M] to modify): \" ) choice = choice . lower () if choice == 'm' : purpose = input ( \"Enter a new purpose, this will be overwritten: \" ) f = open ( dirName + \"/.recall_purpose.txt\" , \"w\" ) f . write ( purpose ) f = open ( dirName + \"/.recall_purpose.txt\" , \"r\" ) purpose = f . read () print ( PURPLE + purpose + NORMAL ) return ( purpose ) else : return ( purpose ) f . close () else : print ( \"Unable to create this file, check admin rights\" )","title":"get_purpose()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.get_refconfig","text":"This function asks for user input to return the reference configuration for a particular configuration. This may also be left blank Source code in mk_readme/clsmkReadme.py def get_refconfig (): '''This function asks for user input to return the reference configuration for a particular configuration. This may also be left blank ''' zrefconfname = \"\" zrefconfurl = \"\" zrefconfname = input ( \"--> If there is a reference configuration this particular configuration is based on, please type the name. Otherwise leave it blank by typing [ENTER]. \\n \" ) zrefconfurl = input ( \"--> If there is a reference configuration this particular configuration is based on, please type the URL. Otherwise leave it blank by typing [ENTER]. \\n \" ) return zrefconfname + \" - \" + zrefconfurl","title":"get_refconfig()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.get_resolution","text":"This function will return the value corresponding to the resolution of the horizontal grid from namelist_cfg file. Returns unknown if value is not available Source code in mk_readme/clsmkReadme.py def get_resolution (): '''This function will return the value corresponding to the resolution of the horizontal grid from namelist_cfg file. Returns unknown if value is not available ''' stringToMatch = 'namcfg' defaultK = \"\" output = 0 #get list of namelists allCFG = getNameLists () #remove empty spaces allCFG = allCFG . replace ( \" \" , \"\" ) print ( \" \\n --> The resolution of the horizontal grid. Accept with [ENTER]: \\n\\n \" ) f = open ( allCFG , \"r\" ) print ( \"all CFG is \" , allCFG ) for line in f : #find the section namcfg if stringToMatch in line : #print(line) for line in f : if \"jp_cfg\" in line : defaultK = line break #print(defaultK) #extract digits only from defaultK output = 0 repl_str = re . compile ( '^\\d+$' ) line = defaultK . split () for word in line : match = re . search ( repl_str , word ) if match : output = float ( match . group ()) #print(BOLD + \"Vertical Grid Points (K): \" + NORMAL + \"\" + str(output)) print ( PURPLE + str ( output ) + NORMAL ) return str ( output )","title":"get_resolution()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.get_useremail","text":"This function returns the user email, if available in the config file Source code in mk_readme/clsmkReadme.py def get_useremail (): '''This function returns the user email, if available in the config file ''' if ( LNGIT == True ): try : repo = git . Repo ( \".\" , search_parent_directories = True ) print ( \" \\n --> What is your email address? We try to get it from git. Accept with [ENTER] or modify accordingly: \\n\\n \" ) reader = repo . config_reader () default = reader . get_value ( 'user' , 'email' ) output = PURPLE + \"User's email :\" + default + NORMAL print ( output ) return default except : try : choice = input ( \"Config file does not include the email address, please amend accordingly in .git > config. Proceed with [ENTER] to continue with 'Unknown' or abort with CTRL-C: \" ) except KeyboardInterrupt : print ( \"You pressed Ctrl+C!\" ) finally : return \"Unknown\" else : pass if ( LNSVN == True ): try : email = input ( \" \\n --> Enter your email address (temporarily) or press [Ctrl-C] to exit and update through git-init \\n\\n \" ) return email except KeyboardInterrupt : print ( \"Exit.. \" )","title":"get_useremail()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.get_username","text":"This function returns the username, if available in the config file Source code in mk_readme/clsmkReadme.py def get_username (): '''This function returns the username, if available in the config file ''' if ( LNGIT == True ): try : repo = git . Repo ( \".\" , search_parent_directories = True ) print ( \" \\n --> What is your full name? We try to get it from git. Accept with [ENTER] or modify accordingly: \\n\\n \" ) reader = repo . config_reader () default = reader . get_value ( 'user' , 'name' ) output = PURPLE + \"User's Full Name :\" + default + NORMAL # return output print ( output ) return default except : try : choice = input ( \"Config file does not include the user name, please amend accordingly in .git > config. Proceed with [ENTER] to continue with 'Unknown' or abort with CTRL-C: \" ) except KeyboardInterrupt : print ( \"You pressed Ctrl+C!\" ) finally : return \"Unknown\" else : pass if ( LNSVN == True ): try : username = input ( \" \\n --> Enter your full name (temporarily) or press [Ctrl-C] to exit and update through git-init \\n\\n \" ) return username except KeyboardInterrupt : print ( \"Exit..\" )","title":"get_username()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.get_vgridpt","text":"This function will return the number of grid points in vertical grid from namelist_cfg file. Returns unknown if value is not available Source code in mk_readme/clsmkReadme.py def get_vgridpt (): '''This function will return the number of grid points in vertical grid from namelist_cfg file. Returns unknown if value is not available''' stringToMatch = 'namcfg' defaultK = \"\" output = 0 #get list of namelists allCFG = getNameLists () #remove empty spaces allCFG = allCFG . replace ( \" \" , \"\" ) print ( \" \\n --> Number of grid points in the vertical? Accept with [ENTER]: \\n\\n \" ) f = open ( allCFG , \"r\" ) for line in f : #find the section namcfg if stringToMatch in line : #print(line) for line in f : if \"jpkdta\" in line : defaultK = line break #print(defaultK) #extract digits only from defaultK output = 0 repl_str = re . compile ( '^\\d+$' ) line = defaultK . split () for word in line : match = re . search ( repl_str , word ) if match : output = float ( match . group ()) #print(BOLD + \"Vertical Grid Points (K): \" + NORMAL + \"\" + str(output)) if str ( output ) == \"\" : print ( PURPLE + \"Unknown\" + NORMAL ) return \"Unknown\" else : print ( PURPLE + str ( output ) + NORMAL ) return str ( output )","title":"get_vgridpt()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.get_vgridtype","text":"This function will return the value corresponding to the vertical grid type from namelist_cfg file. Returns unknown if value is not available Source code in mk_readme/clsmkReadme.py def get_vgridtype (): '''This function will return the value corresponding to the vertical grid type from namelist_cfg file. Returns unknown if value is not available''' stringToMatch = '&namzgr ' default = \"\" #get list of namelists allCFG = getNameLists () #remove empty spaces allCFG = allCFG . replace ( \" \" , \"\" ) result = \"\" print ( \" \\n --> Vertical grid type. Accept with [ENTER]: \\n\\n \" ) f = open ( allCFG , \"r\" ) for line in f : if line . startswith ( stringToMatch ): # print(\"line is \", line) # comma on the end prevents the double spacing from printing a file line for line in f : # #namzgrLst.append(line) if ( \".true.\" in line ): #print(\"Filtered \", line) #add to list to extract #lnLst.append(line) for ext in line : if ( \"zco\" in line ): default = \"zco (z-coordinate with full steps)\" #print(BOLD + \"Vertical Grid Type: \" + NORMAL + \"\" + default) break elif ( \"zps\" in line ): default = \"zps (z-coordinate with partial steps)\" #print(BOLD + \"Vertical Grid Type: \" + NORMAL + \"\" + default) break elif ( \"sco\" in line ): default = \"sco (s- or hybrid z-s-coordinate)\" #print(BOLD + \"Vertical Grid Type: \" + NORMAL + \"\" + default) break #not clear - refer to bash script elif ( \"isfcav\" in line ): default = \"ice shelf cavity\" #print(BOLD + \"Vertical Grid Type: \" + NORMAL + \"\" + default) break if line . startswith ( \"/\" ): break # stop this inner for loop; outer loop picks up on the next line if default == \"\" : print ( PURPLE + \"Unknown\" + NORMAL ) return \"Unknown\" else : print ( PURPLE + default + NORMAL ) return default","title":"get_vgridtype()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.get_zGITNMSPC","text":"This function returns the value of a variable zGITNMSPC Source code in mk_readme/clsmkReadme.py def get_zGITNMSPC (): '''This function returns the value of a variable zGITNMSPC''' zGITSERVER = get_zGITSERVER () if zGITSERVER == \"gitlab.de\" : zGITNMSPC = \"DRAKKAshare\" elif zGITSERVER == \"git.geomar.de\" : zGITNMSPC = \"NEMO/EXP\" return zGITNMSPC","title":"get_zGITNMSPC()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.get_zGITSERVER","text":"This function returns the value of a variable zGITSERVER Source code in mk_readme/clsmkReadme.py def get_zGITSERVER (): '''This function returns the value of a variable zGITSERVER''' if ( LNGIT == True ): zGITSERVER = \"git.geomar.de\" else : zGITSERVER = \"gitlab.de\" return zGITSERVER","title":"get_zGITSERVER()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.get_zPAGESRV","text":"This function returns the value of a variable zPAGESRV Source code in mk_readme/clsmkReadme.py def get_zPAGESRV (): '''This function returns the value of a variable zPAGESRV''' zGITSERVER = get_zGITSERVER () if zGITSERVER == \"gitlab.de\" : zPAGESRV = \"https://drakkarshare.gitlab.io\" zPAGE = zPAGESRV + \"/\" + _CONFNAME_ elif zGITSERVER == \"git.geomar.de\" : zPAGESRV = \"#\" zPAGE = \"| [Static Page](\" + zPAGESRV + \"/\" + _CONFNAME_ + \")\" return zPAGE","title":"get_zPAGESRV()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.getAllConfigFolders","text":"This function will return a list of configurations, and eventually user will choose which configuration s/he would like to work with: (e.g. AMM12, ORCA2_LIM_CFC_C14b, GYRE, ORCA025.L46.LIM2vp.CORE.XIOS1, ORCA2_LIM etc.. Display only the configurations that include EXP00 folder Source code in mk_readme/clsmkReadme.py def getAllConfigFolders (): '''This function will return a list of configurations, and eventually user will choose which configuration s/he would like to work with: (e.g. AMM12, ORCA2_LIM_CFC_C14b, GYRE, ORCA025.L46.LIM2vp.CORE.XIOS1, ORCA2_LIM etc.. Display only the configurations that include EXP00 folder''' configFolders = [] listWithAllDir = [] listOnlyExp00 = [] configPath = getNemoConfig () #print(\"Config path\" , configPath) for r , d , f in os . walk ( configPath ): for directory in d : if \"EXP00\" in d : #release3 listWithAllDir . append ( os . path . join ( r , directory )) elif \"EXPREF\" in d : #release 4 listWithAllDir . append ( os . path . join ( r , directory )) for i in listWithAllDir : if \"EXP00\" in i : #remove the EXP00 listOnlyExp00 . append ( i ) elif \"EXPREF\" in i : #remove the EXPREF listOnlyExp00 . append ( i ) for c in listOnlyExp00 : last = c . split ( '/' ) configFolders . append ( last [ - 2 ]) #sort configFolders configFolders . sort () return configFolders","title":"getAllConfigFolders()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.getNameLists","text":"This function searches for namelist_cfg file and extracts the namelist path for the chosen configuration Source code in mk_readme/clsmkReadme.py def getNameLists (): ''' This function searches for namelist_cfg file and extracts the namelist path for the chosen configuration''' #to retrieve only the cfg of the chosen configuration cfgNameLists = [] findExactNameList = [] output = \"\" path2 = getNemoConfig () for ( dirname , dirs , files ) in os . walk ( path2 ): #for (dirname, dirs, files) in os.walk('.'): for filename in files : if filename . startswith ( '1_namelist_cfg' ): pass #ignore elif 'namelist_cfg' in filename : thefile = os . path . join ( dirname , filename ) if exp in thefile : cfgNameLists . append ( thefile ) #go through the list to check for entries containing part of the chosen name if ( len ( cfgNameLists ) == 1 ): #print(cfgNameLists) output = cfgNameLists else : #add each item to the list for i in range ( len ( cfgNameLists )): findExactNameList . append ( cfgNameLists [ i ]) #Search through each item for the exact configuration name for item in findExactNameList : #for i in item: pathSplit = item . split ( '/' ) #Get the third element from the last if exp == pathSplit [ - 3 ]: #print(item) output = item #return full path #convert list to str return '' . join ([ str ( elem ) for elem in output ])","title":"getNameLists()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.getNemoConfig","text":"This function will look for the directory 'NEMOGCM/CONFIG' for release 3 and 'cfgs' for release 4 anywhere in the system Source code in mk_readme/clsmkReadme.py def getNemoConfig (): '''This function will look for the directory 'NEMOGCM/CONFIG' for release 3 and 'cfgs' for release 4 anywhere in the system''' global release3 , release4 rootPath = pathlib . Path () . absolute () fname = [] configPath = \"\" for root , d_names , f_names in os . walk ( rootPath ): for f in d_names : fname . append ( os . path . join ( root , f )) for i in fname : if \"NEMOGCM/CONFIG\" in i : configPath = i release3 = True #if this is True, the script is being run as a release 3 break elif \"cfgs\" in i : configPath = i release4 = True #if this is True, the script is being run as a release 4 break path = configPath #if release is 4 remove the last two folders since the file structure is different in rel3 and rel4 if (( release3 == True ) or ( release4 == True )) and ( scriptLoc != None ): pathSplit = os . path . dirname ( path ) pathUpdated , tail = os . path . split ( pathSplit ) return pathUpdated else : return path","title":"getNemoConfig()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.hr","text":"displays a list of * across the page and moves cursor to next line Source code in mk_readme/clsmkReadme.py def hr (): '''displays a list of * across the page and moves cursor to next line''' command = [ 'tput' , 'cols' ] width = int ( subprocess . check_output ( command )) for i in range ( width ): { print ( \"*\" , end = \"\" ) } print ( \" \\n \" )","title":"hr()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.indent","text":"Indents text to the right Source code in mk_readme/clsmkReadme.py def indent ( text ): '''Indents text to the right''' text = textwrap . indent ( text , ' ' * 4 )[ 4 - 1 :] print ( text )","title":"indent()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.list_inputfiles","text":"The purpose of this function is to generate the 'Input Files' section in the readme file Source code in mk_readme/clsmkReadme.py def list_inputfiles (): '''The purpose of this function is to generate the 'Input Files' section in the readme file ''' #count 0 is the header count = 1 col1 = \"\" col2 = \"\" col3 = \"\" path2 = os . getcwd () parent = os . path . dirname ( path2 ) #parent directory #for (dirname, dirs, files) in os.walk('.'): for ( dirname , dirs , files ) in os . walk ( parent ): rowsLst . append ([]) rowsLst . append ([]) rowsLst . append ([]) for filename in files : if filename . endswith ( '.def' ) : thefile = os . path . join ( dirname , filename ) #list path with .def extension with open ( thefile ) as f : url = \"\" infile_nemo = \"\" #print all contents of the file for line in f : line = line . strip () #access only the lines that are not commented and empty if not ( line . startswith ( '#' )): if len ( line ) != 0 : allFieldsFirstLine = line . split ( \",\" ) try : infile_nemo = allFieldsFirstLine [ 0 ] #1st element #print(\"infile_nemo: \" + infile_nemo) col1 = infile_nemo if infile_nemo == \"\" or infile_nemo == \" \\\\ \" : infile_nemo = next ( f ) #move to next line else : infile_nemo = allFieldsFirstLine [ 1 ] except : #print(\"Error for infile_nemo\") print ( \"infile Nemo: \" + infile_nemo ) try : url = allFieldsFirstLine [ 2 ] #tableListing.append(url) if not ( url == \" \\\\ \" or url == \"\" or url == \"' \\' \" ): #print(\"this is the original line\") url = allFieldsFirstLine [ 2 ] else : #print(\"this is the next line\") url = next ( f ) #move to next line #print(\"url: \" + url.strip()) col3 = url . strip () + \" \\n \" except : #two exceptions to cater for in file #./ORCA025.L46.LIM2vp.CFCSF6.JRA.XIOS2/EXP00/input.def #print(\"Skip two lines section\") url = next ( f ) url = next ( f ) #print(\"URL : \", url.strip()) col3 = url . strip () + \" \\n \" #add data to table col1 = col1 . strip () col2 = \"---\" col3 = col3 . strip () if 'thredds' in col3 : col3up = col3 pass elif '@' in col3 : getIndex = col3 . find ( '@' ) col3 = col3 [ getIndex + 1 :] #replace : with / col3 = col3 . replace ( ':' , '/' ) #get last part of the string lastPart = col3 . split ( \"/\" )[ - 1 ] lastIndex = col3 . find ( lastPart ) col3 = col3 [: lastIndex - 1 ] col3up = lastPart + \"<b>\" + \" in \" + \"</b>\" + col3 #col3up = lastPart + \"<b>\" + \" in \" + \"</b>\" + \"<a href=\" + \"'\" + col3 + \"'\" + \">\" + col3 + \"</a>\" rowsLst [ count ] . append ( col1 ) rowsLst [ count ] . append ( col2 ) rowsLst [ count ] . append ( col3up ) count = count + 1 #### Create the table ####### rowsLst [ 0 ] . append ( \"**NEMO Input File**\" ) rowsLst [ 0 ] . append ( \"**Reference (DOI)**\" ) rowsLst [ 0 ] . append ( \"**Download**\" ) #this list will not contain empty tuples and will be used in the markdown template rowsLst2 = [ e for e in rowsLst if e ] return make_markdown_table ( rowsLst2 )","title":"list_inputfiles()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.main","text":"This function will be called if the script is stored in the root Source code in mk_readme/clsmkReadme.py def main (): '''This function will be called if the script is stored in the root''' check_inputDef_exists () #check if input.def is part of this directory if check_inputDef_exists () == True : exp = chooseConfigFolder () #print(ask_exp00()) if ask_exp00 ( exp ) == True : template () else : print ( \"Exiting..Please start again\" ) else : print ( \"Input.def file does not exist, create this file to be able to proceed\" )","title":"main()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.mainconfig","text":"This function will be called if the script is initially saved in one of the configuration folders Source code in mk_readme/clsmkReadme.py def mainconfig (): '''This function will be called if the script is initially saved in one of the configuration folders''' check_inputDef_exists () #check if input.def is part of this directory if check_inputDef_exists () == True : if ask_exp00 ( exp ) == True : template () else : print ( \"Exiting..Please start again\" ) else : print ( \"Input.def file does not exist, create this file to be able to proceed\" )","title":"mainconfig()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.make_markdown_table","text":"This function is used to format the tables in the readme file to replicate the markdown format Source code in mk_readme/clsmkReadme.py def make_markdown_table ( rowsLst2 ): '''This function is used to format the tables in the readme file to replicate the markdown format ''' markdown = \" \\n \" + str ( \"| \" ) for e in rowsLst2 [ 0 ]: to_add = \" \" + str ( e ) + str ( \" |\" ) markdown += to_add markdown += \" \\n \" markdown += '|' for i in range ( len ( rowsLst2 [ 0 ])): markdown += str ( \"-------------- | \" ) markdown += \" \\n \" for entry in rowsLst2 [ 1 :]: markdown += str ( \"| \" ) for e in entry : to_add = str ( e ) + str ( \" | \" ) markdown += to_add markdown += \" \\n \" return markdown + \" \\n \"","title":"make_markdown_table()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.prep_note","text":"The purpose of this function is to display a list of prerequistes to successfully render a readme file Source code in mk_readme/clsmkReadme.py def prep_note (): '''The purpose of this function is to display a list of prerequistes to successfully render a readme file''' uName = os . uname () . nodename uName = str ( uName ) print ( \" \\n \" ) hr () print ( \" \\n \" ) center ( \"Prepare DRAKKARshare upload\" ) print ( \" \\n \" ) hr () print ( \" \\n\\n Before we begin, we have to make sure, that the following \" + ULINE + \"conditions are fulfilled\" + NORMAL + \" and you have the \" + ULINE + \"essential information\" + NORMAL + \" at hand right now:\" ) print ( \" \\n\\n \" ) indent ( \" [ ] \" \"You have access to \" + BOLD + BLACK + \"at least one gitlab server\" + NORMAL + \", like \" + BLUE + zGITSERVER + \"/\" + zGITNMSPC + NORMAL + \" and your \" + BOLD + BLACK + \"public ssh-key \" + NORMAL + \"from this host (\" + uName + \") has been deposited under your gitlab profile.\" ) print ( \" \\n \" ) indent ( \" [ ] \" \"Configuration-specific \" + BOLD + BLACK + \" input files \" + NORMAL + \" are \" + ULINE + \"publicly accessible\" + NORMAL + \" at least for members of a specific gitlab group) and you have a \" + BOLD + BLACK + \" reference\" + NORMAL + \" (e.g. DOI) and a \" + BOLD + BLACK + \" Download-URL \" + NORMAL + \" for each file.\" ) print ( \" \\n \" ) indent ( \" [ ] \" \"You know the \" + BOLD + BLACK + \"NEMO revision\" + NORMAL + \" and the \" + BOLD + BLACK + \"URL\" + NORMAL + \" you've installed it from (if it can't be determined automatically, because you're not within a svn or git working directory)\" ) print ( \" \\n \" ) indent ( \" [ ] \" \"If your configuration is build upon another \" + BOLD + BLACK + \"reference configuration \" + NORMAL + \" you'll need the exact name and a reference URL (e.g. another DRAKKARshare repository)\" ) print ( \" \\n \" ) indent ( \" [ ] \" \"Is INPUT.def part of this configuration? \" ) print ( \" \\n \" ) answer = input ( BOLD + RED + \"Do you confirm, that you meet the conditions above? [Y|N]:\" + NORMAL ) answer = answer . lower () if ( answer == \"n\" ): exit () else : return answer","title":"prep_note()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.sucssmsg","text":"Displays an error message in GREEN and reset text colour - Message will be passed as a parameter Source code in mk_readme/clsmkReadme.py def sucssmsg ( msg ): ''' Displays an error message in GREEN and reset text colour - Message will be passed as a parameter''' print ( GREEN + ' \\n SUCCESS: ' + msg + ' \\n\\n ' + NORMAL )","title":"sucssmsg()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.template","text":"The purpose of this function is to create a markup template with values generated from previous functions Source code in mk_readme/clsmkReadme.py def template (): '''The purpose of this function is to create a markup template with values generated from previous functions''' readme = Template ( \"\"\" # {{_COMPONENTS_}} ___ [Purpose](#purpose) | [Contact](#contact) | [License](#license) | [Configuration](#configuration) | [Input Files](#input-files) | [Diagnostics](#diagnostics) | [Installation](#installation) {{_zPAGE_}} ____ # Purpose {{_PURPOSE_}} # Contact {{_CONTACT_}} # License **By downloading this repository and using this code you agree to the following conditions.** The code in this project is based on the [NEMO](http://www.nemo-ocean.eu) software (Copyright (c) Centre National de la Recherche Scientifique CNRS). The original code as well as the contribution to this code in this project are licensed under the conditions of [CeCILL](http://www.cecill.info). The person stated under '*Contact*' above is the owner of the intellectual property rights of these contributions and **must be informed afore** publishing and **must be cited** in every published work that is based completely or partially on the modifications and additional code provided by this configuration. Usage is at one's own risk. # Configuration {{config_table}} The default experiment settings can be found in the [EXP00](EXP00) folder. The modified code is located in the [MY_SRC](MY_SRC) directory. # Input Files * **NEMO Input File:** File names as they are expected by NEMO * **Reference:** Citation for an article or report, webpage or even better: DOI * **Download:** Link for direct downloading the file (no user-interaction preferred to make it script-compliant) The actual file names should follow the *Guidelines for Naming DRAKKAR Input File Names*: \"\\`NemoName\\` \\\\ _\\`NemoVersion\\` \\\\ _\\`ConfigGrid\\` \\\\ _\\`Version\\`.nc\" {{list_inputfiles}} # Diagnostics See [DIAG](DIAG) for some standard diagnostics from a simulation with this configuraton. # Installation There are plenty of ways how to install a local copy of this configuration: 1. You can [clone it with git](#install-with-git) (regardless of whether your NEMOGCM path is already under git control or not). 2. Or you just download an archive from the web interface. In some cases there are different versions of the same configuration in separate branches (e.g. to reflect different NEMO revisions); **check the branches/tags** menu on the web interface or use the git branch and checkout commands to select the version you're interested in. <!--For further details, please read the [HELP pages](https://gitlab.com/DRAKKARshare/help/edit/master/GetConfiguration.md).--> ## Install with \\`git\\` **{- IMPORTANT: -}** The following guidelines assume, that you're already registered at https://{{_zGITSERVER_}} and your public SSH key has been deposited under your gitlab profile. #### (A) NEMOGCM already under git control If your **NEMOGCM installation is already under git control** you cannot clone a different repository into the existing working copy. Instead, you can use \\`git subtree\\` to inject files from another remote repository into a particular sub-folder of your existing working tree. Within NEMOGCM directory: **Option - With git commands** ~~~bash cd NEMOGCM git remote add -f remote_{{_CONFNAME_}} git@{{_zGITSERVER_}}:{{_zGITNMSPC_}}/{{_CONFNAME_}}.git # add remote git subtree add --prefix CONFIG/{{_CONFNAME_}} remote_{{_CONFNAME_}} {{_NEMOBRANCH_}}:-master --squash # donwload master branch into sub-folder cd CONFIG/{{_CONFNAME_}} remote_{{_CONFNAME_}} cat cfg.txt >> ../cfg.txt ~~~ > In this case, you keep the information from where you have downloaded the reference configuration (see \\`git remote -v\\`). Or even shorter, without keeping remote source information (not recommended): ~~~bash cd NEMOGCM git subtree add --prefix CONFIG/{{_CONFNAME_}} git@{{_zGITSERVER_}}:{{_zGITNMSPC_}}/{{_CONFNAME_}}.git {{_NEMOBRANCH_}}:-master --squash cd CONFIG/{{_CONFNAME_}} remote_{{_CONFNAME_}} cat cfg.txt >> ../cfg.txt ~~~ #### (B) NEMOGCM not under git control If your NEMOGCM installation **is not under git control already**, you can clone this configuration using the URL specified on the project's front page: ~~~bash cd NEMOGCM/CONFIG git clone git@{{_zGITSERVER_}}:{{_zGITNMSPC_}}/{{_CONFNAME_}}.git cat {{_CONFNAME_}}/cfg.txt >> cfg.txt ~~~ This wil create a new configuration folder, which can be used as a reference case for \\`makenemo -r\\`. Make sure, you add this confiuration to the local registry file \\`cfg.txt\\` before invoking \\`makenemo\\`. #### Other revisions The revision that will be installed, is the most recent one from the **master** branch. If you're seeking another branch/revision of this configuration (e.g. an older one), you can browse available branches/tags via the web-interface or list alternative branches on the command line and swap available branches/tags easily with \\`checkout\\`: ~~~bash cd {{_CONFNAME_}} git branches -r git checkout otherBranch ~~~ Note: *origin/HEAD* in the output listing is not a branch in its own but points to the default branch (master branch in most cases). \"\"\" ) fillenv () pathS = pathlib . Path () . absolute () if ( LNGIT == True ) and ( CURRCONFIG == False ): READMEOUT = str ( pathS ) + \"/CONFIG/\" + exp + \"/README_\" + exp + \".md\" elif ( LNSVN == True ) and ( CURRCONFIG == False ) and ( release3 == True ): READMEOUT = str ( pathS ) + \"/NEMOGCM/CONFIG/\" + exp + \"/README_\" + exp + \".md\" elif ( LNSVN == True ) and ( CURRCONFIG == False ) and ( release4 == True ): READMEOUT = str ( pathS ) + \"/cfgs/\" + exp + \"/README_\" + exp + \".md\" #if current script is stored in one of the configurations elif ( CURRCONFIG == True ): READMEOUT = str ( pathS ) + \"/README_\" + exp + \".md\" with open ( READMEOUT , \"w\" ) as f : f . write ( readme . render ( _CONFNAME_ = _CONFNAME_ , _CONTACT_ = _CONTACT_ , _PURPOSE_ = _PURPOSE_ , _CURREPO_ = _CURREPO_ , _NEMOREPO_ = _NEMOREPO_ , _NEMOREVISION_ = _NEMOREVISION_ , _NEMOBRANCH_ = _NEMOBRANCH_ , _COMPONENTS_ = _COMPONENTS_ , _REFCONFIG_ = _REFCONFIG_ , _CPPKEYS_ = _CPPKEYS_ , _RESOLUTION_ = _RESOLUTION_ , _GRID_ = _GRID_ , _HGRIDPT_ = _HGRIDPT_ , _VGRIDPTZ_ = _VGRIDPTZ_ , _ATMOS_ = _ATMOS_ , _OCEANRDT_ = _OCEANRDT_ , _NESTNUMBER_ = _NESTNUMBER_ , _PASSIVTRACERS_ = _PASSIVTRACERS_ , list_inputfiles = list_inputfiles (), config_table = config_table (), _zGITSERVER_ = _zGITSERVER_ , _zGITNMSPC_ = _zGITNMSPC_ , _zPAGE_ = _zPAGE_ )) print ( \"README file created\" )","title":"template()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.trim","text":"If any white spaces are present at the end of a line, the purpose of this function is to remove them Source code in mk_readme/clsmkReadme.py def trim ( text ): '''If any white spaces are present at the end of a line, the purpose of this function is to remove them''' text = text . strip () return text","title":"trim()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.warnmsg","text":"Displays an error message in YELLOW and reset text colour - Message will be passed as a parameter Source code in mk_readme/clsmkReadme.py def warnmsg ( msg ): ''' Displays an error message in YELLOW and reset text colour - Message will be passed as a parameter''' print ( YELLOW + ' \\n WARNING: ' + msg + ' \\n\\n ' + NORMAL ) : : my_package.my_module.MyClass handler: python selection: members: - method_a - method_b rendering: show_root_heading: false show_source: false : : my_package.my_module.MyClass handler: python rendering: show_root_heading: false show_source: false : : MY_PACKAGE.your_module handler: python rendering: show_root_heading: false show_source: false","title":"warnmsg()"},{"location":"bundleup.html","text":"Bundle up \ud83d\udd17 Everything is ready to bundle up? Here is a short checklist: Your experiment folder is complete, clean and ready. README.md is ready in the experiment folder. input.ini is present and lists all necessary files. Local git client is installed ( git --version ) You have access to a git remote server (maybe also to some group namespace) ... The next step depends on whether your local NEMO worktree/repository is already under git control or not, though it might be under subversion control : (A) NEMO tree NOT under git control or (Not ready yet!) (B) NEMO tree already under git control (A) NEMO Tree NOT under git control \ud83d\udd17 You are lucky! This is as easy as putting any existing directory under git control and pushing it to some remote repository. Global shell variables Examples below may use some shell variables. These variables are: $WORK : Shell variable which holds the path to some scratch disk, where NEMO was checked out. (1) Initialize git \ud83d\udd17 First, you have to put your configuration's folder (one level deeper than CONFIG / or cfgs/ ). Let's assume we have a Configuration named \"ORCA2_ICE\" we are going to share in the example below: cd $WORK /NEMO/release-4.0/cfgs/ORCA2_ICE/ git init Now, you'll find a new (hidden) golder, called .git in the configuration's folder. (2) Branching Off \ud83d\udd17 The deafult branch name will be master . If you want to use branches that explicitly matches the NEMO branches, you could create a new branch using the -b argument with the git checkout command: git checkout -b release-4.0 (3) Ignore Patterns \ud83d\udd17 Surely, there are files you won't submit to a public repository, like backup files or snippets. You can use file name patterns in the .gitignore file to exclude them from beeing tracked. Just open an ASCII editor, e.g. vi and add your patterns (If you start an entry with **/ the pattern will work recursively). Patterns you'll need to exclude anyway, are: BLD/ WORK/ The .gitignore file is stored in the root folder of the git repository, hence: vi $WORK /NEMO/release-4.0/cfgs/ORCA2_ICE/.gitignore EXAMPLE: In the example below, the BLD/ , WORK/ and EXP00/ folders are going to be ignored while all files with suffixes *.bak , *.tar or *.swp are excluded, too. .gitignore BLD WORK EXP00 **/*.bak **/*.tar **/*.swp After saving this file, the ignore patterns are immediately effective. Don't forget to add it to the commit stage: git add .gitignore (4) README \ud83d\udd17 Option-a: Single Experiment \ud83d\udd17 If your' going to submit only one experiment folder, just copy the README.md file from your experiment into the configuration's folder before submitting. In the example below, the only experiment will be \"REF\": # still in $WORK/NEMO/release-4.0/cfgs/ORCA2_ICE/ cp REF/README.md README.md Option-b: Multiple Experiments \ud83d\udd17 In the case you want to publish multiple experiments with your SImulation Package: Make sure you have a README for each experiment Copy one of the README files into the configuration's folder as you would for only one experiment Modify the title in the README Add a list of your experiments** linked with each specific README.md file Modify the text of the purpose accordingly Example README.md for Simulation Package with multiple experiments Original # ORCA2_ICE-REF ___ [ Purpose ]( #purpose ) | [ Contact ]( #contact ) | [ License ]( #license ) | [ Configuration ]( #configuration ) | [ Input Files ]( #input-files ) | [ Diagnostics ]( #diagnostics ) | [ Installation ]( #installation ) ____ ## Purpose Reference experiment with ORCA2 and Sea Ice Modified # ORCA2_ICE-* ___ [ Experiments ]( #experiments ) | [ Purpose ]( #purpose ) | [ Contact ]( #contact ) | [ License ]( #license ) | [ Configuration ]( #configuration ) | [ Input Files ]( #input-files ) | [ Diagnostics ]( #diagnostics ) | [ Installation ]( #installation ) ____ ## Experiments * [ REF ]( REF/README.md ) * [ SENS1 ]( SENS1/README.md ) * [ SENS2 ]( SENS2/README.md ) ## Purpose Series of simple experiments with ORCA2 and Sea Ice. (5) Add Files \ud83d\udd17 Now is the time, to add some files and folders to track them with git (= files and folders which are going to be submitted to the remote repository). Please, consider adding those files separately using git add <file/folder> instead of using the bunch command git add . (adding a folder however will add it recursively). For example , REF/ is the experiment we want to share: git add README.md git add MY_SRC git add REF git add cpp_ORCA2_ICE.fcm (6) Commit \ud83d\udd17 You can check which files will be tracked with git status : git status If you're happy with the result, commit them, e.g.: git commit -m \"Initial commit for experiment ORCA2_ICE-REF\" If you omit the -m option, the default editor will open and you'll have to type your commit message therein. After saving the temporary MESSAGE file and closing the editor git will proceed with finalizing the commit. (7) Push to remote \ud83d\udd17 This step is part of the publishing process . Please follow the link or click on the buttons below: Publish: General Remarks Publish with GIT (B) NEMO tree already under git control \ud83d\udd17 Not ready yet. Coming soon...","title":"Bundle up"},{"location":"bundleup.html#bundle-up","text":"Everything is ready to bundle up? Here is a short checklist: Your experiment folder is complete, clean and ready. README.md is ready in the experiment folder. input.ini is present and lists all necessary files. Local git client is installed ( git --version ) You have access to a git remote server (maybe also to some group namespace) ... The next step depends on whether your local NEMO worktree/repository is already under git control or not, though it might be under subversion control : (A) NEMO tree NOT under git control or (Not ready yet!) (B) NEMO tree already under git control","title":"Bundle up"},{"location":"bundleup.html#a-nemo-tree-not-under-git-control","text":"You are lucky! This is as easy as putting any existing directory under git control and pushing it to some remote repository. Global shell variables Examples below may use some shell variables. These variables are: $WORK : Shell variable which holds the path to some scratch disk, where NEMO was checked out.","title":"(A) NEMO Tree NOT under git control"},{"location":"bundleup.html#1-initialize-git","text":"First, you have to put your configuration's folder (one level deeper than CONFIG / or cfgs/ ). Let's assume we have a Configuration named \"ORCA2_ICE\" we are going to share in the example below: cd $WORK /NEMO/release-4.0/cfgs/ORCA2_ICE/ git init Now, you'll find a new (hidden) golder, called .git in the configuration's folder.","title":"(1) Initialize git"},{"location":"bundleup.html#2-branching-off","text":"The deafult branch name will be master . If you want to use branches that explicitly matches the NEMO branches, you could create a new branch using the -b argument with the git checkout command: git checkout -b release-4.0","title":"(2) Branching Off"},{"location":"bundleup.html#3-ignore-patterns","text":"Surely, there are files you won't submit to a public repository, like backup files or snippets. You can use file name patterns in the .gitignore file to exclude them from beeing tracked. Just open an ASCII editor, e.g. vi and add your patterns (If you start an entry with **/ the pattern will work recursively). Patterns you'll need to exclude anyway, are: BLD/ WORK/ The .gitignore file is stored in the root folder of the git repository, hence: vi $WORK /NEMO/release-4.0/cfgs/ORCA2_ICE/.gitignore EXAMPLE: In the example below, the BLD/ , WORK/ and EXP00/ folders are going to be ignored while all files with suffixes *.bak , *.tar or *.swp are excluded, too. .gitignore BLD WORK EXP00 **/*.bak **/*.tar **/*.swp After saving this file, the ignore patterns are immediately effective. Don't forget to add it to the commit stage: git add .gitignore","title":"(3) Ignore Patterns"},{"location":"bundleup.html#4-readme","text":"","title":"(4) README"},{"location":"bundleup.html#option-a-single-experiment","text":"If your' going to submit only one experiment folder, just copy the README.md file from your experiment into the configuration's folder before submitting. In the example below, the only experiment will be \"REF\": # still in $WORK/NEMO/release-4.0/cfgs/ORCA2_ICE/ cp REF/README.md README.md","title":"Option-a: Single Experiment"},{"location":"bundleup.html#option-b-multiple-experiments","text":"In the case you want to publish multiple experiments with your SImulation Package: Make sure you have a README for each experiment Copy one of the README files into the configuration's folder as you would for only one experiment Modify the title in the README Add a list of your experiments** linked with each specific README.md file Modify the text of the purpose accordingly Example README.md for Simulation Package with multiple experiments Original # ORCA2_ICE-REF ___ [ Purpose ]( #purpose ) | [ Contact ]( #contact ) | [ License ]( #license ) | [ Configuration ]( #configuration ) | [ Input Files ]( #input-files ) | [ Diagnostics ]( #diagnostics ) | [ Installation ]( #installation ) ____ ## Purpose Reference experiment with ORCA2 and Sea Ice Modified # ORCA2_ICE-* ___ [ Experiments ]( #experiments ) | [ Purpose ]( #purpose ) | [ Contact ]( #contact ) | [ License ]( #license ) | [ Configuration ]( #configuration ) | [ Input Files ]( #input-files ) | [ Diagnostics ]( #diagnostics ) | [ Installation ]( #installation ) ____ ## Experiments * [ REF ]( REF/README.md ) * [ SENS1 ]( SENS1/README.md ) * [ SENS2 ]( SENS2/README.md ) ## Purpose Series of simple experiments with ORCA2 and Sea Ice.","title":"Option-b: Multiple Experiments"},{"location":"bundleup.html#5-add-files","text":"Now is the time, to add some files and folders to track them with git (= files and folders which are going to be submitted to the remote repository). Please, consider adding those files separately using git add <file/folder> instead of using the bunch command git add . (adding a folder however will add it recursively). For example , REF/ is the experiment we want to share: git add README.md git add MY_SRC git add REF git add cpp_ORCA2_ICE.fcm","title":"(5) Add Files"},{"location":"bundleup.html#6-commit","text":"You can check which files will be tracked with git status : git status If you're happy with the result, commit them, e.g.: git commit -m \"Initial commit for experiment ORCA2_ICE-REF\" If you omit the -m option, the default editor will open and you'll have to type your commit message therein. After saving the temporary MESSAGE file and closing the editor git will proceed with finalizing the commit.","title":"(6) Commit"},{"location":"bundleup.html#7-push-to-remote","text":"This step is part of the publishing process . Please follow the link or click on the buttons below: Publish: General Remarks Publish with GIT","title":"(7) Push to remote"},{"location":"bundleup.html#b-nemo-tree-already-under-git-control","text":"Not ready yet. Coming soon...","title":"(B) NEMO tree already under git control"},{"location":"contact.html","text":"Contact \ud83d\udd17","title":"Contact"},{"location":"contact.html#contact","text":"","title":"Contact"},{"location":"disclaimer.html","text":"Disclaimer \ud83d\udd17 If you require any more information or have any questions about our site's disclaimer, please feel free to contact us via contact form at https://immerse-ocean.eu/#contact. Our Disclaimer was generated with the help of the Disclaimer Generator . Disclaimers for nemo-simsar All the information on this website - https://immerse-ocean.eu/nemo-simsar/ - is published in good faith and for general information purpose only. nemo-simsar does not make any warranties about the completeness, reliability and accuracy of this information. Any action you take upon the information you find on this website (nemo-simsar), is strictly at your own risk. nemo-simsar will not be liable for any losses and/or damages in connection with the use of our website. From our website, you can visit other websites by following hyperlinks to such external sites. While we strive to provide only quality links to useful and ethical websites, we have no control over the content and nature of these sites. These links to other websites do not imply a recommendation for all the content found on these sites. Site owners and content may change without notice and may occur before we have the opportunity to remove a link which may have gone 'bad'. Please be also aware that when you leave our website, other sites may have different privacy policies and terms which are beyond our control. Please be sure to check the Privacy Policies of these sites as well as their \"Terms of Service\" before engaging in any business or uploading any information. Our Privacy Policy was created by the Privacy Policy Generator . Consent By using our website, you hereby consent to our disclaimer and agree to its terms. Update Should we update, amend or make any changes to this document, those changes will be prominently posted here.","title":"Disclaimer"},{"location":"disclaimer.html#disclaimer","text":"If you require any more information or have any questions about our site's disclaimer, please feel free to contact us via contact form at https://immerse-ocean.eu/#contact. Our Disclaimer was generated with the help of the Disclaimer Generator .","title":"Disclaimer"},{"location":"getothers.html","text":"Via other resources \ud83d\udd17","title":"Via other resources"},{"location":"getothers.html#via-other-resources","text":"","title":"Via other resources"},{"location":"getsimulation.html","text":"Get a Simulation Package \ud83d\udd17","title":"Get a Simulation Package"},{"location":"getsimulation.html#get-a-simulation-package","text":"","title":"Get a Simulation Package"},{"location":"gettingstarted.html","text":"Getting Started \ud83d\udd17 NOTE: User's working environment The structure of the user's working environment can differ significantly. Hence there is no \"one-click & go\" solution for publishing a simulation package. SIMSAR follows rather a \"recipe\" guided approach and provides the user with batch scripts or other tools where feasible. A Simulation Package consists of the code (reference to the NEMO revision + the user code modifications), the build settings and the runtime environment for one or multiple experiments (namelists + input files). The package could be expanded optionally by output data or figures for evaluation (or a reference to them) as well as by testing/analysis routines . In order to create and publish the simulation package, you'll need to go through these steps: Step-1: Prepare Step-2: Create README Step-3: Create git repository Step-4: Publish Step-1: Prepare \ud83d\udd17 Assuming the path to your copy of the NEMO repository reads $HOME/NEMO/release-4.0 , let's go into the respective experiment folder of the simulation you want to publish (e.g. experiment MyExp1 under configuration My_Config ): cd ~/NEMO/release-4.0/cfgs/My_Config/MyExp1 check in latest revision It is important that when using svn or git the latest changes have been committed to the version control system: git git add . git commit -m \"last checkin before creating README\" svn svn add . 1.1 List input data files \ud83d\udd17 First, we need a list of the required input data files for your simulation together with some detailed meta-data, like sources, references and check-sums. SIMSAR expects this list in a special file, the input.ini file. If this file does not exists yet, please create it . You'll find more information about the file format and how to create it in the \" Citable Input Data \" section of this guide or follow these buttons for further details: How to refer to Input Data The \"input.ini\" file Important Make sure, that the sources in the input.def files (the URLs) are publicly accessible (or grant permissions respectively). 1.2 Other meta-data \ud83d\udd17 Meta-data is an essential part of a documentation because it summarizes the most important basic characteristics of a simulation as well as its special features. Some of this information can be identified automatically while other information requires user input, like the textual description of the purpose of a simulation. Please, follow the button below to read about which meta information will be needed (from the \" The Simulation Package \" section): Simulation Meta Data Step-2: Create README \ud83d\udd17 The meta-information from the preparation step is now assembled in one single document: the README file. This document serves both as front-page for the git repository and as static web page (if enabled). It will give the reader a brief overview of the simulation, a list of requirements to re-run the simulation and how to obtain the code and input files. There is a python script for assistance. Just run the script mkReadme from the SIMSAR package and follow the instructions from the user dialog. Click on the following button to read more about the process: Create a README (mkReadme) Step-3: Create git repository \ud83d\udd17 The Simulation Package will be stored as a git repository . During this step you can review the contents of the repository before it will be uploaded in the next step. Depending on your working environment and whether the directory is already under version control, there are slightly different ways of how to proceed. Please, click on the button below to read about how to bundle up from the \" The Simulation Package \" section: Bundle up Step-4: Publish \ud83d\udd17 Publishing your Simulation Package is an essential step for the reproducibility of scientific findings. But you should also ensure that it's easy to acknowledge your contribution by referring to your work. 4.1 Persistent Identifier \ud83d\udd17 Instead of referring to email addresses, which can change during a scientist's career, you should link your published Simulation Package with a persistent handler for any citing, e.g. using a DOI. See the \" Persistent Handler \" in the \" Publish \" section or follow the button below to read about the necessary steps: Get a persistent handler (DOI) Tip If you want to indicate a persistent handler (e.g. DOI) in the README file (and you should), try to get a preliminary identifier from the service provider, modify the README accordingly, then commit to the remote repository in the next step and finally register this commit with the handler provider. Note If you do not want to register a persistent handler for your simulation you can skip this step, of course. 4.2 Submit to a Git Project Server \ud83d\udd17 To give others access to your Simulation Package you need to upload it to some remote git server either as a public (recommended) or private project. If the project settings allow cloning/forking and so-called merge requests, you can open your Simulation Package for others to contribute to the development. However, most free service providers require the project to be public anyway (or some kind of payed membership) in order to use advanced features, like git pages (for the static web page). You'll find some examples on how to upload your git repository to a git server in the \" Publish \" section under: publish via git 4.3 Add Static Webpage (optional) \ud83d\udd17 Not everybody is familiar with git. And in particular, if your intension is just to provide the information for reference (e.g. for scientific publications) and less for real collaboration, you may want to use a static web page instead of a git repository. Some git hosts provide a nice feature in this regard: git pages . This feature allows you to create a static web page from the existing files using a static web content generator as part of a continuous integration technique. Follow the button below to read more about static webpages in the \" Publish \" section: add static webpage Tip This static web page version can also be used with the \"unsupported configuration\" switch makenemo -u to import this simulation into NEMO without using git.","title":"Getting Started"},{"location":"gettingstarted.html#getting-started","text":"NOTE: User's working environment The structure of the user's working environment can differ significantly. Hence there is no \"one-click & go\" solution for publishing a simulation package. SIMSAR follows rather a \"recipe\" guided approach and provides the user with batch scripts or other tools where feasible. A Simulation Package consists of the code (reference to the NEMO revision + the user code modifications), the build settings and the runtime environment for one or multiple experiments (namelists + input files). The package could be expanded optionally by output data or figures for evaluation (or a reference to them) as well as by testing/analysis routines . In order to create and publish the simulation package, you'll need to go through these steps: Step-1: Prepare Step-2: Create README Step-3: Create git repository Step-4: Publish","title":"Getting Started"},{"location":"gettingstarted.html#step-1-prepare","text":"Assuming the path to your copy of the NEMO repository reads $HOME/NEMO/release-4.0 , let's go into the respective experiment folder of the simulation you want to publish (e.g. experiment MyExp1 under configuration My_Config ): cd ~/NEMO/release-4.0/cfgs/My_Config/MyExp1 check in latest revision It is important that when using svn or git the latest changes have been committed to the version control system: git git add . git commit -m \"last checkin before creating README\" svn svn add .","title":"Step-1: Prepare"},{"location":"gettingstarted.html#11-list-input-data-files","text":"First, we need a list of the required input data files for your simulation together with some detailed meta-data, like sources, references and check-sums. SIMSAR expects this list in a special file, the input.ini file. If this file does not exists yet, please create it . You'll find more information about the file format and how to create it in the \" Citable Input Data \" section of this guide or follow these buttons for further details: How to refer to Input Data The \"input.ini\" file Important Make sure, that the sources in the input.def files (the URLs) are publicly accessible (or grant permissions respectively).","title":"1.1 List input data files"},{"location":"gettingstarted.html#12-other-meta-data","text":"Meta-data is an essential part of a documentation because it summarizes the most important basic characteristics of a simulation as well as its special features. Some of this information can be identified automatically while other information requires user input, like the textual description of the purpose of a simulation. Please, follow the button below to read about which meta information will be needed (from the \" The Simulation Package \" section): Simulation Meta Data","title":"1.2 Other meta-data"},{"location":"gettingstarted.html#step-2-create-readme","text":"The meta-information from the preparation step is now assembled in one single document: the README file. This document serves both as front-page for the git repository and as static web page (if enabled). It will give the reader a brief overview of the simulation, a list of requirements to re-run the simulation and how to obtain the code and input files. There is a python script for assistance. Just run the script mkReadme from the SIMSAR package and follow the instructions from the user dialog. Click on the following button to read more about the process: Create a README (mkReadme)","title":"Step-2: Create README"},{"location":"gettingstarted.html#step-3-create-git-repository","text":"The Simulation Package will be stored as a git repository . During this step you can review the contents of the repository before it will be uploaded in the next step. Depending on your working environment and whether the directory is already under version control, there are slightly different ways of how to proceed. Please, click on the button below to read about how to bundle up from the \" The Simulation Package \" section: Bundle up","title":"Step-3: Create git repository"},{"location":"gettingstarted.html#step-4-publish","text":"Publishing your Simulation Package is an essential step for the reproducibility of scientific findings. But you should also ensure that it's easy to acknowledge your contribution by referring to your work.","title":"Step-4: Publish"},{"location":"gettingstarted.html#41-persistent-identifier","text":"Instead of referring to email addresses, which can change during a scientist's career, you should link your published Simulation Package with a persistent handler for any citing, e.g. using a DOI. See the \" Persistent Handler \" in the \" Publish \" section or follow the button below to read about the necessary steps: Get a persistent handler (DOI) Tip If you want to indicate a persistent handler (e.g. DOI) in the README file (and you should), try to get a preliminary identifier from the service provider, modify the README accordingly, then commit to the remote repository in the next step and finally register this commit with the handler provider. Note If you do not want to register a persistent handler for your simulation you can skip this step, of course.","title":"4.1 Persistent Identifier"},{"location":"gettingstarted.html#42-submit-to-a-git-project-server","text":"To give others access to your Simulation Package you need to upload it to some remote git server either as a public (recommended) or private project. If the project settings allow cloning/forking and so-called merge requests, you can open your Simulation Package for others to contribute to the development. However, most free service providers require the project to be public anyway (or some kind of payed membership) in order to use advanced features, like git pages (for the static web page). You'll find some examples on how to upload your git repository to a git server in the \" Publish \" section under: publish via git","title":"4.2 Submit to a Git Project Server"},{"location":"gettingstarted.html#43-add-static-webpage-optional","text":"Not everybody is familiar with git. And in particular, if your intension is just to provide the information for reference (e.g. for scientific publications) and less for real collaboration, you may want to use a static web page instead of a git repository. Some git hosts provide a nice feature in this regard: git pages . This feature allows you to create a static web page from the existing files using a static web content generator as part of a continuous integration technique. Follow the button below to read more about static webpages in the \" Publish \" section: add static webpage Tip This static web page version can also be used with the \"unsupported configuration\" switch makenemo -u to import this simulation into NEMO without using git.","title":"4.3 Add Static Webpage (optional)"},{"location":"getviacloud.html","text":"Via Cloud \ud83d\udd17","title":"Via Cloud"},{"location":"getviacloud.html#via-cloud","text":"","title":"Via Cloud"},{"location":"getviagit.html","text":"Get Simulation Package via GIT \ud83d\udd17 Getting a Simulation Package with git is as easy as pushing it to a remote git server, in particular if your NEMO root installation is under Subversion (no interference between svn and git). (A) NEMO root NOT under git control \ud83d\udd17 If your NEMO installation is not under git control , you can clone a configuration using the URL specified on the repository's web page: Go into the configurations directory in your local NEMO installation ( CONFIG/ for NEMO version 3, cfgs/ for version 4) and clone this project (see the \"Clone\" link or button on the git webinterface to get the URL). EXAMPLE: In this example, NEMO (version 4) has been installed on a separate scratch-disk ( $WORK ) and the simulation repository was hosted on github under the namespace \"mscheinert\": cd $WORK/NEMO-release-4.0/cfgs git clone https://github.com/mscheinert/ORCA2_ICE.git cat ORCA2_ICE/exp_cfg.txt >> ./work_cfgs.txt Instead of the default branch you can also specify it when cloning (e.g. release-4.0 if it exists): git clone -b release-4.0 https://github.com/mscheinert/ORCA2_ICE.git This wil create a new configuration folder, which can be used as a reference case for makenemo -r . Make sure, you add this configuration to the local registry file cfg.txt (NEMO version 3) or work_cfgs.txt (NEMO version 4) before invoking makenemo . Name Collision In the case you have already a configuration with the same name , you can specify a new name for the clone you are pulling from remote. Just add another argument with the new name: git clone -b release-4.0 https://github.com/mscheinert/ORCA2_ICE.git ORCA2_ICE__release4 (B) NEMOGCM already under git control \ud83d\udd17 If your NEMOGCM installation is already under git control you cannot clone a different repository into the existing working copy. Instead, you can use git subtree to inject files from another remote repository into a particular sub-folder of your existing working tree. Within NEMO root directory: cd $WORK/NEMO-release-4.0 git remote add -f remote_ORCA2_ICE-mscheinert https://github.com/mscheinert/ORCA2_ICE.git # add remote git subtree add --prefix cfgs/ORCA2_ICE remote_ORCA2_ICE-scheinert release-4.0 --squash # donwload master branch into sub-folder cat cfgs/ORCA2_ICE/exp_cfg.txt >> cfgs/work_cfgs.txt In this case, you keep the information from where you have downloaded the reference configuration (see git remote -v ). Or even shorter, without keeping remote source information (not recommended): cd $WORK/NEMO-release-4.0 git subtree add --prefix cfgs/ORCA2_ICE-REF git@github.com:immerse-project/ORCA2_ICE-REF.git release-4.0 --squash cat cfgs/ORCA2_ICE-REF/exp_cfg.txt >> cfgs/work_cfgs.txt Other revisions \ud83d\udd17 The revision that will be installed, is the most recent one from the master branch. If you're seeking another branch/revision of this configuration (e.g. an older one), you can browse available branches/tags via the web-interface or list alternative branches on the command line and swap available branches/tags easily with checkout : cd ORCA2_ICE-REF git branches -r git checkout otherBranch Note: origin/HEAD in the output listing is not a branch in its own but points to the default branch (master branch in most cases).","title":"git"},{"location":"getviagit.html#get-simulation-package-via-git","text":"Getting a Simulation Package with git is as easy as pushing it to a remote git server, in particular if your NEMO root installation is under Subversion (no interference between svn and git).","title":"Get Simulation Package via GIT"},{"location":"getviagit.html#a-nemo-root-not-under-git-control","text":"If your NEMO installation is not under git control , you can clone a configuration using the URL specified on the repository's web page: Go into the configurations directory in your local NEMO installation ( CONFIG/ for NEMO version 3, cfgs/ for version 4) and clone this project (see the \"Clone\" link or button on the git webinterface to get the URL). EXAMPLE: In this example, NEMO (version 4) has been installed on a separate scratch-disk ( $WORK ) and the simulation repository was hosted on github under the namespace \"mscheinert\": cd $WORK/NEMO-release-4.0/cfgs git clone https://github.com/mscheinert/ORCA2_ICE.git cat ORCA2_ICE/exp_cfg.txt >> ./work_cfgs.txt Instead of the default branch you can also specify it when cloning (e.g. release-4.0 if it exists): git clone -b release-4.0 https://github.com/mscheinert/ORCA2_ICE.git This wil create a new configuration folder, which can be used as a reference case for makenemo -r . Make sure, you add this configuration to the local registry file cfg.txt (NEMO version 3) or work_cfgs.txt (NEMO version 4) before invoking makenemo . Name Collision In the case you have already a configuration with the same name , you can specify a new name for the clone you are pulling from remote. Just add another argument with the new name: git clone -b release-4.0 https://github.com/mscheinert/ORCA2_ICE.git ORCA2_ICE__release4","title":"(A) NEMO root NOT under git control"},{"location":"getviagit.html#b-nemogcm-already-under-git-control","text":"If your NEMOGCM installation is already under git control you cannot clone a different repository into the existing working copy. Instead, you can use git subtree to inject files from another remote repository into a particular sub-folder of your existing working tree. Within NEMO root directory: cd $WORK/NEMO-release-4.0 git remote add -f remote_ORCA2_ICE-mscheinert https://github.com/mscheinert/ORCA2_ICE.git # add remote git subtree add --prefix cfgs/ORCA2_ICE remote_ORCA2_ICE-scheinert release-4.0 --squash # donwload master branch into sub-folder cat cfgs/ORCA2_ICE/exp_cfg.txt >> cfgs/work_cfgs.txt In this case, you keep the information from where you have downloaded the reference configuration (see git remote -v ). Or even shorter, without keeping remote source information (not recommended): cd $WORK/NEMO-release-4.0 git subtree add --prefix cfgs/ORCA2_ICE-REF git@github.com:immerse-project/ORCA2_ICE-REF.git release-4.0 --squash cat cfgs/ORCA2_ICE-REF/exp_cfg.txt >> cfgs/work_cfgs.txt","title":"(B) NEMOGCM already under git control"},{"location":"getviagit.html#other-revisions","text":"The revision that will be installed, is the most recent one from the master branch. If you're seeking another branch/revision of this configuration (e.g. an older one), you can browse available branches/tags via the web-interface or list alternative branches on the command line and swap available branches/tags easily with checkout : cd ORCA2_ICE-REF git branches -r git checkout otherBranch Note: origin/HEAD in the output listing is not a branch in its own but points to the default branch (master branch in most cases).","title":"Other revisions"},{"location":"getvianemo.html","text":"Get via maenemo -u \ud83d\udd17","title":"Get via maenemo -u"},{"location":"getvianemo.html#get-via-maenemo-u","text":"","title":"Get via maenemo -u"},{"location":"input_def.html","text":"The input.def File \ud83d\udd17 The input.def file is an additional file that is not part of the original NEMO framework. It lists all the input data files needed for a specific simulation, each with their file names as expected by NEMO (hard coded or by namelist parameter) one or multiple remote sources (file name may differ from the NEMO name) a SHA256 checksum (optional) a reference , like a publication or the data file's DOI/POI (optional) Info input.def is read by the mkReadme python script. File Format \ud83d\udd17 The file is a simple ASCII text file with: each record representing one input file a record may consist of multiple continuing lines (use \\ and a line break at the end of a line to continue in the next line instead of a simple line break) each record consists of three or more comma separated columns: The file name as expected by NEMO A SHA256 checksum (preceded with ' sha256= ') and/or a Reference Text at least one source URL (optional) additional URLs, if available (also comma separated) lines that start with a ' # ' are completely treated as comments (may be preceded with blanks; continuing lines ('\\') must start with a hash character as well) Example \ud83d\udd17 See the example/template file docs/input.def : Example input.def #-------------------------------------------------------------------------------------- # NEMO Input File Definition # # <NEMO-FileName>, <'DOI|Reference SHA256=xxxx...'>, <URI>[,<URI>[,...]] # # Each 'Reference' can also contain a SHA256-hash for verifying the file. This entry # is separated with spaces and has the preceding key-word SHA256= without any blanks # # You can use hash character (#) to comment the rest of the line out # Long lines can be split by backslashes (\\); trailing comments (#) are allowed. # #-------------------------------------------------------------------------------------- # <NEMO-FileName>, <'DOI|Reference SHA256=xxxx...'>, <URI>[,<URI>[,...]] coordinates.nc, SHA256=288b021a8595efeee8de7c4fb665d3037bd356a72ca13e591bb81acc5c3ceeb5 ,\\ https://data.myserver.org/ORCA025/coordinates__3.6.0_ORCA025_v1.0.1.nc reshape_jra55_orca025_bilin.nc, SHA256=645de13bb1cbe652c1c2fa3913523d42adf4ec04fd3f55f20766a43abbd00e50 ,\\ git@git.myserver.org:ORCA025/reshape_jra.git/reshape_jra_bilin__v1.0.1.nc reshape_jra55_orca025_bicub.nc, SHA256=91edfbc233a48d6aaa266d7aca71665f420da9957d3d124e9864e91e0012e10f ,\\ git@git.myserver.org:ORCA025/reshape_jra.git/reshape_jra_bicub__v1.0.1.nc","title":"The `input.def` File"},{"location":"input_def.html#the-inputdef-file","text":"The input.def file is an additional file that is not part of the original NEMO framework. It lists all the input data files needed for a specific simulation, each with their file names as expected by NEMO (hard coded or by namelist parameter) one or multiple remote sources (file name may differ from the NEMO name) a SHA256 checksum (optional) a reference , like a publication or the data file's DOI/POI (optional) Info input.def is read by the mkReadme python script.","title":"The input.def File"},{"location":"input_def.html#file-format","text":"The file is a simple ASCII text file with: each record representing one input file a record may consist of multiple continuing lines (use \\ and a line break at the end of a line to continue in the next line instead of a simple line break) each record consists of three or more comma separated columns: The file name as expected by NEMO A SHA256 checksum (preceded with ' sha256= ') and/or a Reference Text at least one source URL (optional) additional URLs, if available (also comma separated) lines that start with a ' # ' are completely treated as comments (may be preceded with blanks; continuing lines ('\\') must start with a hash character as well)","title":"File Format"},{"location":"input_def.html#example","text":"See the example/template file docs/input.def : Example input.def #-------------------------------------------------------------------------------------- # NEMO Input File Definition # # <NEMO-FileName>, <'DOI|Reference SHA256=xxxx...'>, <URI>[,<URI>[,...]] # # Each 'Reference' can also contain a SHA256-hash for verifying the file. This entry # is separated with spaces and has the preceding key-word SHA256= without any blanks # # You can use hash character (#) to comment the rest of the line out # Long lines can be split by backslashes (\\); trailing comments (#) are allowed. # #-------------------------------------------------------------------------------------- # <NEMO-FileName>, <'DOI|Reference SHA256=xxxx...'>, <URI>[,<URI>[,...]] coordinates.nc, SHA256=288b021a8595efeee8de7c4fb665d3037bd356a72ca13e591bb81acc5c3ceeb5 ,\\ https://data.myserver.org/ORCA025/coordinates__3.6.0_ORCA025_v1.0.1.nc reshape_jra55_orca025_bilin.nc, SHA256=645de13bb1cbe652c1c2fa3913523d42adf4ec04fd3f55f20766a43abbd00e50 ,\\ git@git.myserver.org:ORCA025/reshape_jra.git/reshape_jra_bilin__v1.0.1.nc reshape_jra55_orca025_bicub.nc, SHA256=91edfbc233a48d6aaa266d7aca71665f420da9957d3d124e9864e91e0012e10f ,\\ git@git.myserver.org:ORCA025/reshape_jra.git/reshape_jra_bicub__v1.0.1.nc","title":"Example"},{"location":"input_ini.html","text":"The input.ini File \ud83d\udd17 The input.ini file is an additional file that is not part of the original NEMO framework. It lists all the input data files needed for a specific simulation, each with their file names as expected by NEMO (hard coded or by namelist parameter) one or multiple remote sources (file name may differ from the NEMO name) a checksum (optional, e.g. SHA256) a reference , like a publication or the data file's DOI/POI (optional) Info input.ini is read by the mkReadme python script. File Format \ud83d\udd17 The file is a simple ASCII text file ( INI format) with: each section representing one input file each section contains at least one key ( URL ): The section name represents the file name as expected by NEMO (hard coded or set by namelist parameter) At least one source URL A checksum An indicator for the type of the checksum (sha or md5) (optional) additional URLs, if available (also comma separated) lines that start with a ' # or ; ' are treated as comments. lines might be indented Example \ud83d\udd17 See the example/template file docs/input.ini : Example input.inni # NEMO-simsar input file registry # # Each NEMO input file has one entry: The SECTION name in square brackets is the # file name NEMO expects (hard coded or by namelist parameter). # Each section has several key=value pairs: # # [NemoFileName.nc] # URL = https:// # Reference = Author, A. (YEAR) # DOI = <doi:reference-id, not the url> # CheckSum = <HASH:sha1|sha224|sha256|sha384|sha512|md5> # CheckSumType = [SHA|MD5| ] # Comment = Some additional notes or comments on the data set # [coordinates.nc] URL = https://data.myserver.org/ORCA025/coordinates__3.6.0_ORCA025_v1.0.1.nc Reference = DOI = 10.5281/zenodo.3767939 CheckSum = 288b021a8595efeee8de7c4fb665d3037bd356a72ca13e591bb81acc5c3ceeb5 CheckSumType = sha Comment = [data_1m_salinity_nomask.nc] URL = https://zenodo.org/record/3767939/files/ORCA2_ICE_v4.2.tar?download=1 Reference = DOI = 10.5281/zenodo.3767939 CheckSum = b3f60e3507bbea3466834a363f366b45ef8aec19495ae0975ea3dcbbbfc70aa2 CheckSumType = sha Comment =","title":"The `input.ini` File"},{"location":"input_ini.html#the-inputini-file","text":"The input.ini file is an additional file that is not part of the original NEMO framework. It lists all the input data files needed for a specific simulation, each with their file names as expected by NEMO (hard coded or by namelist parameter) one or multiple remote sources (file name may differ from the NEMO name) a checksum (optional, e.g. SHA256) a reference , like a publication or the data file's DOI/POI (optional) Info input.ini is read by the mkReadme python script.","title":"The input.ini File"},{"location":"input_ini.html#file-format","text":"The file is a simple ASCII text file ( INI format) with: each section representing one input file each section contains at least one key ( URL ): The section name represents the file name as expected by NEMO (hard coded or set by namelist parameter) At least one source URL A checksum An indicator for the type of the checksum (sha or md5) (optional) additional URLs, if available (also comma separated) lines that start with a ' # or ; ' are treated as comments. lines might be indented","title":"File Format"},{"location":"input_ini.html#example","text":"See the example/template file docs/input.ini : Example input.inni # NEMO-simsar input file registry # # Each NEMO input file has one entry: The SECTION name in square brackets is the # file name NEMO expects (hard coded or by namelist parameter). # Each section has several key=value pairs: # # [NemoFileName.nc] # URL = https:// # Reference = Author, A. (YEAR) # DOI = <doi:reference-id, not the url> # CheckSum = <HASH:sha1|sha224|sha256|sha384|sha512|md5> # CheckSumType = [SHA|MD5| ] # Comment = Some additional notes or comments on the data set # [coordinates.nc] URL = https://data.myserver.org/ORCA025/coordinates__3.6.0_ORCA025_v1.0.1.nc Reference = DOI = 10.5281/zenodo.3767939 CheckSum = 288b021a8595efeee8de7c4fb665d3037bd356a72ca13e591bb81acc5c3ceeb5 CheckSumType = sha Comment = [data_1m_salinity_nomask.nc] URL = https://zenodo.org/record/3767939/files/ORCA2_ICE_v4.2.tar?download=1 Reference = DOI = 10.5281/zenodo.3767939 CheckSum = b3f60e3507bbea3466834a363f366b45ef8aec19495ae0975ea3dcbbbfc70aa2 CheckSumType = sha Comment =","title":"Example"},{"location":"inputdata.html","text":"How to refer to Input Data \ud83d\udd17 Beside the run-time parameters (namelists) and the program code of the model, the input data files are the third essential component for the reproducibility of a simulation. It is therefore indispensable that the origin and the history of the input data is well documented and that each file can be referenced unequivocally. This can be achieved by: version control a persistent data handler per file a check-sum Data Version Control \ud83d\udd17 The simplest way of version-controlling a data file is using a different file name for each version. But this approach may cause trouble and confusion for automation processes (scripts) and users with different file naming conventions. A much more robust, though resource-intensive way would be a svn or git-lfs system. Whatever system it is, that you prefer, it should sustain an easy and persistent way of accessing the exact data file that is needed for a specific simulation. Persistent Data Handler \ud83d\udd17 Document Object Identifiers (DOI) are used for a long time now and are a very effective way of referencing documents. Something similar can be used for data files as well. You can use either a DOI or any other form of persistent handler. Data Files or Data Sets? \ud83d\udd17 It's your choice whether you want to publish each file separately or as a data set combining the different files. The latter is much easier and less time consuming. But the former can be used in a more flexible way such as re-using it for different experiments without dealing with unnecessary files in the same collection. Example: Publish with GitHub and zenodo \ud83d\udd17 Both GitHub and zenodo provide free service for publicly available data. Furthermore, they can be combined. Alternative 1: one-time upload \ud83d\udd17 Data sets that will not change or will not be further developed, can be simply uploaded to zenodo without a repository link. Step 1: Login to zenodo You can either use your GitHub account, your OrcID or you sign up for a zenodo account. Just visit zenodo.org/login and follow the instructions there. Step 2: Create a new data set Create a new data set using the \"New Upload button\" on the Upload page (see the top menu of the zenodo page). Step 3: Fill in the data set details ... Alternative 2: version controlled repository \ud83d\udd17 If you want to document the development of a data file or provide additional files, like a script for creation or testing, upload your files to a git repository first, then create a fixed tag for a certain revision (release) and then upload and link this version at zenodo: Step 1:New Git-LFS project on github go to github.org and create a new data project, e.g. with the following sub-folders: data/ docs/ util/ Don't forget adding a README(.md,.rst,.txt) and a LICENSE file. Step 2: git-lfs Clone the git project onto your local host, enable git-lfs by adding a filter (don't forget to run git-lfs install on this host once), add the files, commit and push to the remote repo. For example: git clone https://github.org/namespace/data-project.git cd data-project mkdir data docs util git-lfs install # only once on a host git lfs track \"*.nc\" # e.g. for NetCDF files git add .gitattributes cp /path/to/data/data.nc data/. git add data/data.nc git commit -m \"adding data.nc\" git push origin master Step 3: Login to zenodo You can either use your GitHub account, your OrcID or you sign up for a zenodo account. Just visit zenodo.org/login and follow the instructions there. Step 4: Create a new data set Create a new data set using the \"New Upload button\" on the Upload page (see the top menu of the zenodo page). Step 5: Fill in the data set details ...","title":"How to refer to Input Data"},{"location":"inputdata.html#how-to-refer-to-input-data","text":"Beside the run-time parameters (namelists) and the program code of the model, the input data files are the third essential component for the reproducibility of a simulation. It is therefore indispensable that the origin and the history of the input data is well documented and that each file can be referenced unequivocally. This can be achieved by: version control a persistent data handler per file a check-sum","title":"How to refer to Input Data"},{"location":"inputdata.html#data-version-control","text":"The simplest way of version-controlling a data file is using a different file name for each version. But this approach may cause trouble and confusion for automation processes (scripts) and users with different file naming conventions. A much more robust, though resource-intensive way would be a svn or git-lfs system. Whatever system it is, that you prefer, it should sustain an easy and persistent way of accessing the exact data file that is needed for a specific simulation.","title":"Data Version Control"},{"location":"inputdata.html#persistent-data-handler","text":"Document Object Identifiers (DOI) are used for a long time now and are a very effective way of referencing documents. Something similar can be used for data files as well. You can use either a DOI or any other form of persistent handler.","title":"Persistent Data Handler"},{"location":"inputdata.html#data-files-or-data-sets","text":"It's your choice whether you want to publish each file separately or as a data set combining the different files. The latter is much easier and less time consuming. But the former can be used in a more flexible way such as re-using it for different experiments without dealing with unnecessary files in the same collection.","title":"Data Files or Data Sets?"},{"location":"inputdata.html#example-publish-with-github-and-zenodo","text":"Both GitHub and zenodo provide free service for publicly available data. Furthermore, they can be combined.","title":"Example: Publish with GitHub and zenodo"},{"location":"inputdata.html#alternative-1-one-time-upload","text":"Data sets that will not change or will not be further developed, can be simply uploaded to zenodo without a repository link. Step 1: Login to zenodo You can either use your GitHub account, your OrcID or you sign up for a zenodo account. Just visit zenodo.org/login and follow the instructions there. Step 2: Create a new data set Create a new data set using the \"New Upload button\" on the Upload page (see the top menu of the zenodo page). Step 3: Fill in the data set details ...","title":"Alternative 1: one-time upload"},{"location":"inputdata.html#alternative-2-version-controlled-repository","text":"If you want to document the development of a data file or provide additional files, like a script for creation or testing, upload your files to a git repository first, then create a fixed tag for a certain revision (release) and then upload and link this version at zenodo: Step 1:New Git-LFS project on github go to github.org and create a new data project, e.g. with the following sub-folders: data/ docs/ util/ Don't forget adding a README(.md,.rst,.txt) and a LICENSE file. Step 2: git-lfs Clone the git project onto your local host, enable git-lfs by adding a filter (don't forget to run git-lfs install on this host once), add the files, commit and push to the remote repo. For example: git clone https://github.org/namespace/data-project.git cd data-project mkdir data docs util git-lfs install # only once on a host git lfs track \"*.nc\" # e.g. for NetCDF files git add .gitattributes cp /path/to/data/data.nc data/. git add data/data.nc git commit -m \"adding data.nc\" git push origin master Step 3: Login to zenodo You can either use your GitHub account, your OrcID or you sign up for a zenodo account. Just visit zenodo.org/login and follow the instructions there. Step 4: Create a new data set Create a new data set using the \"New Upload button\" on the Upload page (see the top menu of the zenodo page). Step 5: Fill in the data set details ...","title":"Alternative 2: version controlled repository"},{"location":"introduction.html","text":"Introduction \ud83d\udd17 Modeling the Ocean \ud83d\udd17 Ocean models of today are highly complex computer programs based on mathematical formulations of physical, chemical and biological interrelations. They are essential tools to investigate processes in the ocean from large scales to micro-structures which effect the climate physics, environmental conditions, economic developments and ultimately the human well-being. They can help to understand processes that lead to events in the past as well as to present changes. And it places an instrument to our disposal to look into the future using projections and forecasts. Reproducibility \ud83d\udd17 The results and the conclusions of a scientific analysis are the most important outcome in the wake of an ocean simulation effort. But the interpretation of the results must be verifiable and the simulation itself thus reproducible. Therefore, the knowledge about how the simulation was created and run is of equal importance and cannot be neglected. To fulfil this obligation of reproducibility every component of and input for a simulation must be documented in a well-defined, reliable, citable and thus sharable way. What is sharing for you? Publishing? Collaborating? \ud83d\udd17 If you want to share a simulation with others you may either want to just document what you have done and provide this information to others. Or you may want to develop a configuration together with contributions from different groups. While the former can be implemented quite easily: Just put the necessary information into one archive and extract some of the meta data for a summary; no further contribution intended. The latter (collaboration) needs a more complex solution: You'll have to make sure, that the development is version controlled and each contributor can be identified (not only to track bugs but also to acknowledge and to give credit for their contributions). NEMO \ud83d\udd17 The NEMO framework ( nemo-ocean.eu ) provides the code and tools to compile a computer program in order to simulate the ocean and its diverse components. Besides the physical ocean, also a sea-ice and a biogeochemical tracer module can both be included. The final program code is assembled during the compilation process and factors in additional pre-compiler choices (like model functionalities, competing parametrization and algorithms) and code modifications made by the user. The setup for such a specific executable program is called a \" configuration \". Although the same configuration can be compiled using different compilers for different machines, the same executable can be used however to run different \" experiments \". These experiments or \"runs\" differ on parameter choices made in separate namelist files, which are evaluated during run-time. They may also start from different initial conditions (e.g. the ocean state, like temperature, salinity and current velocities) and may respond to different boundary condition data (like geothermal bottom heat or atmospheric forcing), all read from external input data sets . NEMO is shipped with several build-in configurations including example parameter sets to demonstrate different kinds of application. The necessary input data files for these configurations can be downloaded from a data repository (see link in the cited NEMO documentation). Test Cases NEMO also provides a bunch of idealized test cases . Each in the shape of a configuration folder they reside in a separate NEMO directory and are meant to test certain features, algorithms and functionalities of the code. The full collection can be retrieved from a separate git repository which is open to contributions from the community. Missing User Configuration Documentation While the build-in configurations in NEMO are sufficiently documented, version-controlled and even the input files are linked to a permanent object identifier, there is no recommended way of keeping records of user configurations. NEMO-SIMSAR \ud83d\udd17 NEMO-SIMSAR aims to fill the gap of documenting NEMO simulations created by users and introduces a consistent concept and provides recipes and tools for the user. The concept behind NEMO-SIMSAR does not only emphasize univocally citable input data sets but also introduces a more comprehensive definition of a simulation package and its components than the original concept of configurations and experiments stipulates. The preferred repository system for publishing your simulation with SIMSAR is git (but other platforms and protocols might be applicable, too). The figure below illustrates the workflow: User A (Simulation Manager X) has a copy of the NEMO framework repository containing several experiments under different configurations User A creates one ore more Simulation Packages and publishes them each in a separate git project. User A also has the option to create additional static pages from the git project in order to support the makenemo -u . User B, also having a copy of the NEMO framework repository, clones one or more of these git projects to work with. In this case, User B could also contribute to a simulation package by uploading their own version and submitting a merge request to the respective git project. User B could also import a simulation package using the static pages version of the git project and the \"unsupported configuration\" switch with the build tool: makenemo -u . In this case no contributions could be made directly to the simulation project unless the simulation package is re-imported invoking step 3. DOIs could refer either to the git project version or the static pages version. In a two-level-access approach a DOI could refer to the static page version which in turn provides a link to the original repository. Getting Started","title":"Introduction"},{"location":"introduction.html#introduction","text":"","title":"Introduction"},{"location":"introduction.html#modeling-the-ocean","text":"Ocean models of today are highly complex computer programs based on mathematical formulations of physical, chemical and biological interrelations. They are essential tools to investigate processes in the ocean from large scales to micro-structures which effect the climate physics, environmental conditions, economic developments and ultimately the human well-being. They can help to understand processes that lead to events in the past as well as to present changes. And it places an instrument to our disposal to look into the future using projections and forecasts.","title":"Modeling the Ocean"},{"location":"introduction.html#reproducibility","text":"The results and the conclusions of a scientific analysis are the most important outcome in the wake of an ocean simulation effort. But the interpretation of the results must be verifiable and the simulation itself thus reproducible. Therefore, the knowledge about how the simulation was created and run is of equal importance and cannot be neglected. To fulfil this obligation of reproducibility every component of and input for a simulation must be documented in a well-defined, reliable, citable and thus sharable way.","title":"Reproducibility"},{"location":"introduction.html#what-is-sharing-for-you-publishing-collaborating","text":"If you want to share a simulation with others you may either want to just document what you have done and provide this information to others. Or you may want to develop a configuration together with contributions from different groups. While the former can be implemented quite easily: Just put the necessary information into one archive and extract some of the meta data for a summary; no further contribution intended. The latter (collaboration) needs a more complex solution: You'll have to make sure, that the development is version controlled and each contributor can be identified (not only to track bugs but also to acknowledge and to give credit for their contributions).","title":"What is sharing for you? Publishing? Collaborating?"},{"location":"introduction.html#nemo","text":"The NEMO framework ( nemo-ocean.eu ) provides the code and tools to compile a computer program in order to simulate the ocean and its diverse components. Besides the physical ocean, also a sea-ice and a biogeochemical tracer module can both be included. The final program code is assembled during the compilation process and factors in additional pre-compiler choices (like model functionalities, competing parametrization and algorithms) and code modifications made by the user. The setup for such a specific executable program is called a \" configuration \". Although the same configuration can be compiled using different compilers for different machines, the same executable can be used however to run different \" experiments \". These experiments or \"runs\" differ on parameter choices made in separate namelist files, which are evaluated during run-time. They may also start from different initial conditions (e.g. the ocean state, like temperature, salinity and current velocities) and may respond to different boundary condition data (like geothermal bottom heat or atmospheric forcing), all read from external input data sets . NEMO is shipped with several build-in configurations including example parameter sets to demonstrate different kinds of application. The necessary input data files for these configurations can be downloaded from a data repository (see link in the cited NEMO documentation). Test Cases NEMO also provides a bunch of idealized test cases . Each in the shape of a configuration folder they reside in a separate NEMO directory and are meant to test certain features, algorithms and functionalities of the code. The full collection can be retrieved from a separate git repository which is open to contributions from the community. Missing User Configuration Documentation While the build-in configurations in NEMO are sufficiently documented, version-controlled and even the input files are linked to a permanent object identifier, there is no recommended way of keeping records of user configurations.","title":"NEMO"},{"location":"introduction.html#nemo-simsar","text":"NEMO-SIMSAR aims to fill the gap of documenting NEMO simulations created by users and introduces a consistent concept and provides recipes and tools for the user. The concept behind NEMO-SIMSAR does not only emphasize univocally citable input data sets but also introduces a more comprehensive definition of a simulation package and its components than the original concept of configurations and experiments stipulates. The preferred repository system for publishing your simulation with SIMSAR is git (but other platforms and protocols might be applicable, too). The figure below illustrates the workflow: User A (Simulation Manager X) has a copy of the NEMO framework repository containing several experiments under different configurations User A creates one ore more Simulation Packages and publishes them each in a separate git project. User A also has the option to create additional static pages from the git project in order to support the makenemo -u . User B, also having a copy of the NEMO framework repository, clones one or more of these git projects to work with. In this case, User B could also contribute to a simulation package by uploading their own version and submitting a merge request to the respective git project. User B could also import a simulation package using the static pages version of the git project and the \"unsupported configuration\" switch with the build tool: makenemo -u . In this case no contributions could be made directly to the simulation project unless the simulation package is re-imported invoking step 3. DOIs could refer either to the git project version or the static pages version. In a two-level-access approach a DOI could refer to the static page version which in turn provides a link to the original repository. Getting Started","title":"NEMO-SIMSAR"},{"location":"mkReadme.html","text":"Create the README file with mkReadme \ud83d\udd17 mkReadme helps you creating a README file that summerizes the characteristics of a simulation (an experiment with a specific configuration) as Markdown file ( README.md ). Step-by-Step \ud83d\udd17 Experiment Folder Please, be aware, that currently mkReadme expects you to be wihtin the NEMO repository tree. If your experiment folder is outside of e.g. NEMO/cfgs/WhateverConfig/YourEXP , please consider finding a work-around by e.g. copying the necessary files temporarily into the NEMO repository tree (no need to copy the huge input data files, input.ini will be sufficient). \u200b Go into the folder of the exxperiment you want to publish. Run mkReadme and provide input when asked : Confirm with > y < when you're ready and prepared (see list on the screen) The ascertained name of the configuration and experiment are printed on screen for controlling purposes only Your're asked for your full name (given name and family name). Confirm with >RETURN< You're asked for your email address (both will apear as \"Contact\" on the README page). Confirm with >RETURN< Now type in a short notice on the purpose of the experiment; You can modify an existing text, if you have invoked the script before Confirm with >RETURN< The Script now checks some information and will put some control output on screen: Are we already in a svn or git repository? And if so, what is the registered remote repo? What was the original NEMO repository URL? What is the revision number for the svn repository root? Prints the branch name (parent folder of the NEMO code in the original svn repository) Prints a list of components used for the current configuration (from cfg.txt / ref_cfgs.txt / work_cfgs.txt ) You're asked now whether there is a previous 'parent' configuration you want to link this configuration to? Leave it empty if there is no such parent config. Confirm with >RETURN< You may want to insert the URL of a remote repository for the parent configuration from the step before. Leave it empty if there is no such URL. Confirm with >RETURN< some basic grid information is determined and printed on screen: Horizontal Resolution Grid Type Vertical grid type Horizontal grid numbers Number of vertical levels Type of atmospheric forcing Dynamic time step Now you're asked for the number of AGRIF nests (just keep it zero (0) if there are no nests). Confirm with >RETURN< Finaly, you can type in a list of passive tracers, if necessary. Confirm with >RETURN< Your README.md file ist written. Load the README.md in a Markdown Viewer or in some ASCII editor to check the information therein. Now proceed with the next step: Bundle Up Bundle Up Example \ud83d\udd17","title":"Create the README file with **mkReadme**"},{"location":"mkReadme.html#create-the-readme-file-with-mkreadme","text":"mkReadme helps you creating a README file that summerizes the characteristics of a simulation (an experiment with a specific configuration) as Markdown file ( README.md ).","title":"Create the README file with mkReadme"},{"location":"mkReadme.html#step-by-step","text":"Experiment Folder Please, be aware, that currently mkReadme expects you to be wihtin the NEMO repository tree. If your experiment folder is outside of e.g. NEMO/cfgs/WhateverConfig/YourEXP , please consider finding a work-around by e.g. copying the necessary files temporarily into the NEMO repository tree (no need to copy the huge input data files, input.ini will be sufficient). \u200b Go into the folder of the exxperiment you want to publish. Run mkReadme and provide input when asked : Confirm with > y < when you're ready and prepared (see list on the screen) The ascertained name of the configuration and experiment are printed on screen for controlling purposes only Your're asked for your full name (given name and family name). Confirm with >RETURN< You're asked for your email address (both will apear as \"Contact\" on the README page). Confirm with >RETURN< Now type in a short notice on the purpose of the experiment; You can modify an existing text, if you have invoked the script before Confirm with >RETURN< The Script now checks some information and will put some control output on screen: Are we already in a svn or git repository? And if so, what is the registered remote repo? What was the original NEMO repository URL? What is the revision number for the svn repository root? Prints the branch name (parent folder of the NEMO code in the original svn repository) Prints a list of components used for the current configuration (from cfg.txt / ref_cfgs.txt / work_cfgs.txt ) You're asked now whether there is a previous 'parent' configuration you want to link this configuration to? Leave it empty if there is no such parent config. Confirm with >RETURN< You may want to insert the URL of a remote repository for the parent configuration from the step before. Leave it empty if there is no such URL. Confirm with >RETURN< some basic grid information is determined and printed on screen: Horizontal Resolution Grid Type Vertical grid type Horizontal grid numbers Number of vertical levels Type of atmospheric forcing Dynamic time step Now you're asked for the number of AGRIF nests (just keep it zero (0) if there are no nests). Confirm with >RETURN< Finaly, you can type in a list of passive tracers, if necessary. Confirm with >RETURN< Your README.md file ist written. Load the README.md in a Markdown Viewer or in some ASCII editor to check the information therein. Now proceed with the next step: Bundle Up Bundle Up","title":"Step-by-Step"},{"location":"mkReadme.html#example","text":"","title":"Example"},{"location":"notes.html","text":"Hidden Notes \ud83d\udd17 Note Warning Info Success Question Which license? test github pages under immerse? Fail Danger Bug \u2013 .icons/material/account-circle.svg \u2013 .icons/fontawesome/regular/laugh-wink.svg \u2013 .icons/octicons/octoface-16.svg Check Now you should have a clean simulation repository in a separate directory looking similar to this: tree /tmp/My_Config-MyExp1 /tmp/My_Config-MyExp1/ | -MY_SRC/ | -sbcblk.F90 | -MyExp1/ | -iodef.xml | -input.def | -namelist_cfg | -namelist_ice_cfg | -namelist_ice_ref | -namelist_ref | -cpp_MyConfig.fcm | -README.md | -ref_cfgs.input GitHub #include <stdio.h> int main ( void ) { printf ( \"Hello world! \\n \" ); return 0 ; } GitLab #include <iostream> int main ( void ) { std :: cout << \"Hello world!\" << std :: endl ; return 0 ; } other Some other Git Host.","title":"Hidden Notes"},{"location":"notes.html#hidden-notes","text":"Note Warning Info Success Question Which license? test github pages under immerse? Fail Danger Bug \u2013 .icons/material/account-circle.svg \u2013 .icons/fontawesome/regular/laugh-wink.svg \u2013 .icons/octicons/octoface-16.svg Check Now you should have a clean simulation repository in a separate directory looking similar to this: tree /tmp/My_Config-MyExp1 /tmp/My_Config-MyExp1/ | -MY_SRC/ | -sbcblk.F90 | -MyExp1/ | -iodef.xml | -input.def | -namelist_cfg | -namelist_ice_cfg | -namelist_ice_ref | -namelist_ref | -cpp_MyConfig.fcm | -README.md | -ref_cfgs.input GitHub #include <stdio.h> int main ( void ) { printf ( \"Hello world! \\n \" ); return 0 ; } GitLab #include <iostream> int main ( void ) { std :: cout << \"Hello world!\" << std :: endl ; return 0 ; } other Some other Git Host.","title":"Hidden Notes"},{"location":"orca2_ice_log.html","text":"Example Nemo session \ud83d\udd17 During this session we will create a new configuration ORCA2-ICE which will be then published/shared in a (private) git repository with nemo-simsar. (1) Install NEMO \ud83d\udd17 This step installs NEMO from scratch and creates the new configuration if both do not exist yet. + Clone / Checkout NEMO repo \ud83d\udd17 If you're going to run your experiments within the NEMO repository tree, make sure, you're not working within your $HOME directory. You may want to use a 'scratch disk' instead (e.g. $WORK ) which can also store large input and output files. cd $WORK svn co https://forge.ipsl.jussieu.fr/nemo/svn/NEMO/releases/release-4.0 NEMO-release-4.0 + New ARCH \ud83d\udd17 For simplicity we us a new ARCH file which would run the model in a serial mode (instead of a parallel mode): arch-linux_gfortran_serial.fcm : %NCDF_HOME /usr %HDF5_HOME /usr %XIOS_HOME %OASIS_HOME %NCDF_INC -I%NCDF_HOME/include -I%HDF5_HOME/include/hdf5/serial %NCDF_LIB -L%NCDF_HOME/lib/x86_64-linux-gnu -lnetcdff -lnetcdf %XIOS_INC %XIOS_LIB %OASIS_INC %OASIS_LIB %CPP cpp -Dkey_nosignedzero %FC /usr/bin/gfortran -c -cpp %FCFLAGS -fdefault-real-8 -O3 -funroll-all-loops -fcray-pointer -ffree-line-length-none %FFLAGS %FCFLAGS #%LD /usr/bin/gfortran -Wl,-rpath=$HOME/INSTALL/lib:/usr/lib %LD /usr/bin/gfortran %LDFLAGS %FPPFLAGS -P -C -traditional %AR ar %ARFLAGS rs %MK make %USER_INC %XIOS_INC %OASIS_INC %NCDF_INC %USER_LIB %XIOS_LIB %OASIS_LIB %NCDF_LIB %CC cc %CFLAGS -O0 + Create new ORCA2_ICE configuration \ud83d\udd17 The next commands will create the new configuration \"ORCA2_ICE\" based on the existing reference configuration ORCA2_ICE_PISCES\" (which originally also uses the NST component). The model components are reduced to OCE and ICE and all CPP keys that'd require MPI (parallel computing) are removed, too. cd NEMO-release-4.0 ./makenemo -m linux_gfortran_serial -r ORCA2_ICE_PISCES -n ORCA2_ICE -j 0 ./makenemo -m linux_gfortran_serial -r ORCA2_ICE -j 0 -d OCE,ICE ./makenemo -m linux_gfortran_serial -r ORCA2_ICE -j 0 del_key 'key_top key_iomput key_mpp_mpi' Now, there is also a new file cfgs/work_cfgs.txt listing the user configurations and their model components: ORCA2_ICE OCE TOP ICE NST and the cpp file cpp_ORCA2_ICE.fcm only contains now the macro key for the sea ice model: bld::tool::fppkeys key_si3 + MY_SRC \ud83d\udd17 We will just copy a file from the original source tree in order to simulate the existence of a user-modified file in MY_SRC/ : cd cfgs/ORCA2_ICE/MY_SRC cp src/OCE/SBC/sbcblk.F90 cfgs/ORCA2_ICE/MY_SRC/. + COMPILATION \ud83d\udd17 Still in NEMO-release-4.0/ folder: ./makenemo -m linux_gfortran_serial -r ORCA2_ICE + Experiment REF \ud83d\udd17 cp -R EXP00 REF (2) Install nemo-simsar \ud83d\udd17 cd $HOME git clone https:// export PATH=$HOME/nemo-simsar/bin:$PATH (3) Prepare Software Package \ud83d\udd17 + List input files in input.def \ud83d\udd17 cd $WORK/NEMO-release-4.0/cfgs/ORCA2_ICE/RE vi input.def REF/input.def : #-------------------------------------------------------------------------------------- # NEMO Input File Definition # # <NEMO-FileName>, <'DOI|Reference SHA256=xxxx...'>, <URI>[,<URI>[,...]] # # Each 'Reference' can also contain a SHA256-hash for verifying the file. This entry # is separated with spaces and has the preceding key-word SHA256= without any blanks # # You can use hash character (#) to comment the rest of the line out # Long lines can be split by backslashes (\\); trailing comments (#) are allowed. # #-------------------------------------------------------------------------------------- # <NEMO-FileName>, <'DOI|Reference SHA256=xxxx...'>, <URI>[,<URI>[,...]] ORCA_R2_zps_domcfg.nc, \\ SHA256=736500c34b2f5959070d961ca64a0649895cfa27101368eff90edb7f90c5097f\\ DOI=10.5281/zenodo.3767939 \\ https://doi.org/10.5281/zenodo.3767939, \\ https://zenodo.org/record/3767939/files/ORCA2_ICE_v4.2.tar?download=1 data_1m_salinity_nomask.nc, \\ SHA256=b3f60e3507bbea3466834a363f366b45ef8aec19495ae0975ea3dcbbbfc70aa2\\ DOI=10.5281/zenodo.3767939 \\ https://doi.org/10.5281/zenodo.3767939, \\ https://zenodo.org/record/3767939/files/ORCA2_ICE_v4.2.tar?download=1 geothermal_heating.nc, \\ SHA256=a72baf9af15e53bce87a53148ed8fddf8d9948449f5c04da5d84526edf39ccc3\\ DOI=10.5281/zenodo.3767939 \\ https://doi.org/10.5281/zenodo.3767939, \\ https://zenodo.org/record/3767939/files/ORCA2_ICE_v4.2.tar?download=1 eddy_viscosity_3D.nc, \\ SHA256=a3083b470710a32bb83678632904f3b3d09f96d47110440dfac7d6ddc978c269\\ DOI=10.5281/zenodo.3767939 \\ https://doi.org/10.5281/zenodo.3767939, \\ https://zenodo.org/record/3767939/files/ORCA2_ICE_v4.2.tar?download=1 mixing_power_pyc.nc, \\ SHA256=4c1d530408921c6418e91a0c4f2451420407e0a3ac9176d7cf2125b417f1233f\\ DOI=10.5281/zenodo.3767939 \\ https://doi.org/10.5281/zenodo.3767939, \\ https://zenodo.org/record/3767939/files/ORCA2_ICE_v4.2.tar?download=1 mixing_power_cri.nc, \\ SHA256=13d3c239277f39a7bf2f082deb4b5507b467c03120ceed15e6e79fc2e2c2d84b\\ DOI=10.5281/zenodo.3767939 \\ https://doi.org/10.5281/zenodo.3767939, \\ https://zenodo.org/record/3767939/files/ORCA2_ICE_v4.2.tar?download=1 mixing_power_bot.nc, \\ SHA256=c2485f028fe8d7978d924737d2c2eb2f61cb780ab906ac8ceecd18e8b6e9b343\\ DOI=10.5281/zenodo.3767939 \\ https://doi.org/10.5281/zenodo.3767939, \\ https://zenodo.org/record/3767939/files/ORCA2_ICE_v4.2.tar?download=1 runoff_core_monthly.nc, \\ SHA256=e5f3b92205561d78731b9253caf302ddf82d98cd3eabe46ab0cf152be6d74ffb\\ DOI=10.5281/zenodo.3767939 \\ https://doi.org/10.5281/zenodo.3767939, \\ https://zenodo.org/record/3767939/files/ORCA2_ICE_v4.2.tar?download=1 resto.nc, \\ SHA256=b3ac69284d46276497928a55a69c167cdb579443f85383186c442c4e235ee032\\ DOI=10.5281/zenodo.3767939 \\ https://doi.org/10.5281/zenodo.3767939, \\ https://zenodo.org/record/3767939/files/ORCA2_ICE_v4.2.tar?download=1 data_1m_potential_temperature_nomask.nc, \\ SHA256=302179020c3c8c1ca02d8f749206f13eca522a9de8704a1a148f5e1eddcc70b8\\ DOI=10.5281/zenodo.3767939 \\ https://doi.org/10.5281/zenodo.3767939, \\ https://zenodo.org/record/3767939/files/ORCA2_ICE_v4.2.tar?download=1 u_10.15JUNE2009_fill.nc, \\ SHA256=a226c422488b78fdcccb31c64219787510cb383dc9bd9f27a3fef3cc2052a171\\ DOI=10.5281/zenodo.3767939 \\ https://doi.org/10.5281/zenodo.3767939, \\ https://zenodo.org/record/3767939/files/ORCA2_ICE_v4.2.tar?download=1 weights_core_orca2_bicubic_noc.nc, \\ SHA256=9bbdbbdf773307e08b7372712123a2cefdd9f2ea1928d61aae3f27a10cb065b2\\ DOI=10.5281/zenodo.3767939 \\ https://doi.org/10.5281/zenodo.3767939, \\ https://zenodo.org/record/3767939/files/ORCA2_ICE_v4.2.tar?download=1 weights_core_orca2_bilinear_noc.nc, \\ SHA256=20c7e0af58792b9401b9a47dc5f3c9a5726f44d0454f2d6fe01ccaa5e3af725e\\ DOI=10.5281/zenodo.3767939 \\ https://doi.org/10.5281/zenodo.3767939, \\ https://zenodo.org/record/3767939/files/ORCA2_ICE_v4.2.tar?download=1 v_10.15JUNE2009_fill.nc, , https://zenodo.org/record/3767939/files/ORCA2_ICE_v4.2.tar?download=1 t_10.15JUNE2009_fill.nc, , https://zenodo.org/record/3767939/files/ORCA2_ICE_v4.2.tar?download=1 q_10.15JUNE2009_fill.nc, , https://zenodo.org/record/3767939/files/ORCA2_ICE_v4.2.tar?download=1 ncar_rad.15JUNE2009_fill.nc, , https://zenodo.org/record/3767939/files/ORCA2_ICE_v4.2.tar?download=1 ncar_precip.15JUNE2009_fill.nc, , https://zenodo.org/record/3767939/files/ORCA2_ICE_v4.2.tar?download=1 slp.15JUNE2009_fill.nc, , https://zenodo.org/record/3767939/files/ORCA2_ICE_v4.2.tar?download=1 sss_data.nc, , https://zenodo.org/record/3767939/files/ORCA2_ICE_v4.2.tar?download=1 chlorophyll.nc, , https://zenodo.org/record/3767939/files/ORCA2_ICE_v4.2.tar?download=1 decay_scale_cri.nc, , https://zenodo.org/record/3767939/files/ORCA2_ICE_v4.2.tar?download=1 decay_scale_bot.nc, , https://zenodo.org/record/3767939/files/ORCA2_ICE_v4.2.tar?download=1","title":"Example Nemo session"},{"location":"orca2_ice_log.html#example-nemo-session","text":"During this session we will create a new configuration ORCA2-ICE which will be then published/shared in a (private) git repository with nemo-simsar.","title":"Example Nemo session"},{"location":"orca2_ice_log.html#1-install-nemo","text":"This step installs NEMO from scratch and creates the new configuration if both do not exist yet.","title":"(1) Install NEMO"},{"location":"orca2_ice_log.html#clone-checkout-nemo-repo","text":"If you're going to run your experiments within the NEMO repository tree, make sure, you're not working within your $HOME directory. You may want to use a 'scratch disk' instead (e.g. $WORK ) which can also store large input and output files. cd $WORK svn co https://forge.ipsl.jussieu.fr/nemo/svn/NEMO/releases/release-4.0 NEMO-release-4.0","title":"+ Clone / Checkout NEMO repo"},{"location":"orca2_ice_log.html#new-arch","text":"For simplicity we us a new ARCH file which would run the model in a serial mode (instead of a parallel mode): arch-linux_gfortran_serial.fcm : %NCDF_HOME /usr %HDF5_HOME /usr %XIOS_HOME %OASIS_HOME %NCDF_INC -I%NCDF_HOME/include -I%HDF5_HOME/include/hdf5/serial %NCDF_LIB -L%NCDF_HOME/lib/x86_64-linux-gnu -lnetcdff -lnetcdf %XIOS_INC %XIOS_LIB %OASIS_INC %OASIS_LIB %CPP cpp -Dkey_nosignedzero %FC /usr/bin/gfortran -c -cpp %FCFLAGS -fdefault-real-8 -O3 -funroll-all-loops -fcray-pointer -ffree-line-length-none %FFLAGS %FCFLAGS #%LD /usr/bin/gfortran -Wl,-rpath=$HOME/INSTALL/lib:/usr/lib %LD /usr/bin/gfortran %LDFLAGS %FPPFLAGS -P -C -traditional %AR ar %ARFLAGS rs %MK make %USER_INC %XIOS_INC %OASIS_INC %NCDF_INC %USER_LIB %XIOS_LIB %OASIS_LIB %NCDF_LIB %CC cc %CFLAGS -O0","title":"+ New ARCH"},{"location":"orca2_ice_log.html#create-new-orca2_ice-configuration","text":"The next commands will create the new configuration \"ORCA2_ICE\" based on the existing reference configuration ORCA2_ICE_PISCES\" (which originally also uses the NST component). The model components are reduced to OCE and ICE and all CPP keys that'd require MPI (parallel computing) are removed, too. cd NEMO-release-4.0 ./makenemo -m linux_gfortran_serial -r ORCA2_ICE_PISCES -n ORCA2_ICE -j 0 ./makenemo -m linux_gfortran_serial -r ORCA2_ICE -j 0 -d OCE,ICE ./makenemo -m linux_gfortran_serial -r ORCA2_ICE -j 0 del_key 'key_top key_iomput key_mpp_mpi' Now, there is also a new file cfgs/work_cfgs.txt listing the user configurations and their model components: ORCA2_ICE OCE TOP ICE NST and the cpp file cpp_ORCA2_ICE.fcm only contains now the macro key for the sea ice model: bld::tool::fppkeys key_si3","title":"+ Create new ORCA2_ICE configuration"},{"location":"orca2_ice_log.html#my_src","text":"We will just copy a file from the original source tree in order to simulate the existence of a user-modified file in MY_SRC/ : cd cfgs/ORCA2_ICE/MY_SRC cp src/OCE/SBC/sbcblk.F90 cfgs/ORCA2_ICE/MY_SRC/.","title":"+ MY_SRC"},{"location":"orca2_ice_log.html#compilation","text":"Still in NEMO-release-4.0/ folder: ./makenemo -m linux_gfortran_serial -r ORCA2_ICE","title":"+ COMPILATION"},{"location":"orca2_ice_log.html#experiment-ref","text":"cp -R EXP00 REF","title":"+ Experiment REF"},{"location":"orca2_ice_log.html#2-install-nemo-simsar","text":"cd $HOME git clone https:// export PATH=$HOME/nemo-simsar/bin:$PATH","title":"(2) Install nemo-simsar"},{"location":"orca2_ice_log.html#3-prepare-software-package","text":"","title":"(3) Prepare Software Package"},{"location":"orca2_ice_log.html#list-input-files-in-inputdef","text":"cd $WORK/NEMO-release-4.0/cfgs/ORCA2_ICE/RE vi input.def REF/input.def : #-------------------------------------------------------------------------------------- # NEMO Input File Definition # # <NEMO-FileName>, <'DOI|Reference SHA256=xxxx...'>, <URI>[,<URI>[,...]] # # Each 'Reference' can also contain a SHA256-hash for verifying the file. This entry # is separated with spaces and has the preceding key-word SHA256= without any blanks # # You can use hash character (#) to comment the rest of the line out # Long lines can be split by backslashes (\\); trailing comments (#) are allowed. # #-------------------------------------------------------------------------------------- # <NEMO-FileName>, <'DOI|Reference SHA256=xxxx...'>, <URI>[,<URI>[,...]] ORCA_R2_zps_domcfg.nc, \\ SHA256=736500c34b2f5959070d961ca64a0649895cfa27101368eff90edb7f90c5097f\\ DOI=10.5281/zenodo.3767939 \\ https://doi.org/10.5281/zenodo.3767939, \\ https://zenodo.org/record/3767939/files/ORCA2_ICE_v4.2.tar?download=1 data_1m_salinity_nomask.nc, \\ SHA256=b3f60e3507bbea3466834a363f366b45ef8aec19495ae0975ea3dcbbbfc70aa2\\ DOI=10.5281/zenodo.3767939 \\ https://doi.org/10.5281/zenodo.3767939, \\ https://zenodo.org/record/3767939/files/ORCA2_ICE_v4.2.tar?download=1 geothermal_heating.nc, \\ SHA256=a72baf9af15e53bce87a53148ed8fddf8d9948449f5c04da5d84526edf39ccc3\\ DOI=10.5281/zenodo.3767939 \\ https://doi.org/10.5281/zenodo.3767939, \\ https://zenodo.org/record/3767939/files/ORCA2_ICE_v4.2.tar?download=1 eddy_viscosity_3D.nc, \\ SHA256=a3083b470710a32bb83678632904f3b3d09f96d47110440dfac7d6ddc978c269\\ DOI=10.5281/zenodo.3767939 \\ https://doi.org/10.5281/zenodo.3767939, \\ https://zenodo.org/record/3767939/files/ORCA2_ICE_v4.2.tar?download=1 mixing_power_pyc.nc, \\ SHA256=4c1d530408921c6418e91a0c4f2451420407e0a3ac9176d7cf2125b417f1233f\\ DOI=10.5281/zenodo.3767939 \\ https://doi.org/10.5281/zenodo.3767939, \\ https://zenodo.org/record/3767939/files/ORCA2_ICE_v4.2.tar?download=1 mixing_power_cri.nc, \\ SHA256=13d3c239277f39a7bf2f082deb4b5507b467c03120ceed15e6e79fc2e2c2d84b\\ DOI=10.5281/zenodo.3767939 \\ https://doi.org/10.5281/zenodo.3767939, \\ https://zenodo.org/record/3767939/files/ORCA2_ICE_v4.2.tar?download=1 mixing_power_bot.nc, \\ SHA256=c2485f028fe8d7978d924737d2c2eb2f61cb780ab906ac8ceecd18e8b6e9b343\\ DOI=10.5281/zenodo.3767939 \\ https://doi.org/10.5281/zenodo.3767939, \\ https://zenodo.org/record/3767939/files/ORCA2_ICE_v4.2.tar?download=1 runoff_core_monthly.nc, \\ SHA256=e5f3b92205561d78731b9253caf302ddf82d98cd3eabe46ab0cf152be6d74ffb\\ DOI=10.5281/zenodo.3767939 \\ https://doi.org/10.5281/zenodo.3767939, \\ https://zenodo.org/record/3767939/files/ORCA2_ICE_v4.2.tar?download=1 resto.nc, \\ SHA256=b3ac69284d46276497928a55a69c167cdb579443f85383186c442c4e235ee032\\ DOI=10.5281/zenodo.3767939 \\ https://doi.org/10.5281/zenodo.3767939, \\ https://zenodo.org/record/3767939/files/ORCA2_ICE_v4.2.tar?download=1 data_1m_potential_temperature_nomask.nc, \\ SHA256=302179020c3c8c1ca02d8f749206f13eca522a9de8704a1a148f5e1eddcc70b8\\ DOI=10.5281/zenodo.3767939 \\ https://doi.org/10.5281/zenodo.3767939, \\ https://zenodo.org/record/3767939/files/ORCA2_ICE_v4.2.tar?download=1 u_10.15JUNE2009_fill.nc, \\ SHA256=a226c422488b78fdcccb31c64219787510cb383dc9bd9f27a3fef3cc2052a171\\ DOI=10.5281/zenodo.3767939 \\ https://doi.org/10.5281/zenodo.3767939, \\ https://zenodo.org/record/3767939/files/ORCA2_ICE_v4.2.tar?download=1 weights_core_orca2_bicubic_noc.nc, \\ SHA256=9bbdbbdf773307e08b7372712123a2cefdd9f2ea1928d61aae3f27a10cb065b2\\ DOI=10.5281/zenodo.3767939 \\ https://doi.org/10.5281/zenodo.3767939, \\ https://zenodo.org/record/3767939/files/ORCA2_ICE_v4.2.tar?download=1 weights_core_orca2_bilinear_noc.nc, \\ SHA256=20c7e0af58792b9401b9a47dc5f3c9a5726f44d0454f2d6fe01ccaa5e3af725e\\ DOI=10.5281/zenodo.3767939 \\ https://doi.org/10.5281/zenodo.3767939, \\ https://zenodo.org/record/3767939/files/ORCA2_ICE_v4.2.tar?download=1 v_10.15JUNE2009_fill.nc, , https://zenodo.org/record/3767939/files/ORCA2_ICE_v4.2.tar?download=1 t_10.15JUNE2009_fill.nc, , https://zenodo.org/record/3767939/files/ORCA2_ICE_v4.2.tar?download=1 q_10.15JUNE2009_fill.nc, , https://zenodo.org/record/3767939/files/ORCA2_ICE_v4.2.tar?download=1 ncar_rad.15JUNE2009_fill.nc, , https://zenodo.org/record/3767939/files/ORCA2_ICE_v4.2.tar?download=1 ncar_precip.15JUNE2009_fill.nc, , https://zenodo.org/record/3767939/files/ORCA2_ICE_v4.2.tar?download=1 slp.15JUNE2009_fill.nc, , https://zenodo.org/record/3767939/files/ORCA2_ICE_v4.2.tar?download=1 sss_data.nc, , https://zenodo.org/record/3767939/files/ORCA2_ICE_v4.2.tar?download=1 chlorophyll.nc, , https://zenodo.org/record/3767939/files/ORCA2_ICE_v4.2.tar?download=1 decay_scale_cri.nc, , https://zenodo.org/record/3767939/files/ORCA2_ICE_v4.2.tar?download=1 decay_scale_bot.nc, , https://zenodo.org/record/3767939/files/ORCA2_ICE_v4.2.tar?download=1","title":"+ List input files in input.def"},{"location":"privacy.html","text":"Privacy Policy for nemo-simsar \ud83d\udd17 At nemo-simsar, accessible from https://immerse-ocean.eu/nemo-simsar, one of our main priorities is the privacy of our visitors. This Privacy Policy document contains types of information that is collected and recorded by nemo-simsar and how we use it. If you have additional questions or require more information about our Privacy Policy, do not hesitate to contact us. This Privacy Policy applies only to our online activities and is valid for visitors to our website with regards to the information that they shared and/or collect in nemo-simsar. This policy is not applicable to any information collected offline or via channels other than this website. Our Privacy Policy was created with the help of the Privacy Policy Generator and the Free Privacy Policy Generator . Consent By using our website, you hereby consent to our Privacy Policy and agree to its terms. For our Terms and Conditions, please visit the Terms & Conditions Generator . Information we collect The personal information that you are asked to provide, and the reasons why you are asked to provide it, will be made clear to you at the point we ask you to provide your personal information. If you contact us directly, we may receive additional information about you such as your name, email address, phone number, the contents of the message and/or attachments you may send us, and any other information you may choose to provide. When you register for an Account, we may ask for your contact information, including items such as name, company name, address, email address, and telephone number. How we use your information We use the information we collect in various ways, including to: Provide, operate, and maintain our webste Improve, personalize, and expand our webste Understand and analyze how you use our webste Develop new products, services, features, and functionality Communicate with you, either directly or through one of our partners, including for customer service, to provide you with updates and other information relating to the webste, and for marketing and promotional purposes Send you emails Find and prevent fraud Log Files nemo-simsar follows a standard procedure of using log files. These files log visitors when they visit websites. All hosting companies do this and a part of hosting services' analytics. The information collected by log files include internet protocol (IP) addresses, browser type, Internet Service Provider (ISP), date and time stamp, referring/exit pages, and possibly the number of clicks. These are not linked to any information that is personally identifiable. The purpose of the information is for analyzing trends, administering the site, tracking users' movement on the website, and gathering demographic information. Advertising Partners Privacy Policies You may consult this list to find the Privacy Policy for each of the advertising partners of nemo-simsar. Third-party ad servers or ad networks uses technologies like cookies, JavaScript, or Web Beacons that are used in their respective advertisements and links that appear on nemo-simsar, which are sent directly to users' browser. They automatically receive your IP address when this occurs. These technologies are used to measure the effectiveness of their advertising campaigns and/or to personalize the advertising content that you see on websites that you visit. Note that nemo-simsar has no access to or control over these cookies that are used by third-party advertisers. Third Party Privacy Policies nemo-simsar's Privacy Policy does not apply to other advertisers or websites. Thus, we are advising you to consult the respective Privacy Policies of these third-party ad servers for more detailed information. It may include their practices and instructions about how to opt-out of certain options. You can choose to disable cookies through your individual browser options. To know more detailed information about cookie management with specific web browsers, it can be found at the browsers' respective websites. CCPA Privacy Rights (Do Not Sell My Personal Information) Under the CCPA, among other rights, California consumers have the right to: Request that a business that collects a consumer's personal data disclose the categories and specific pieces of personal data that a business has collected about consumers. Request that a business delete any personal data about the consumer that a business has collected. Request that a business that sells a consumer's personal data, not sell the consumer's personal data. If you make a request, we have one month to respond to you. If you would like to exercise any of these rights, please contact us. GDPR Data Protection Rights We would like to make sure you are fully aware of all of your data protection rights. Every user is entitled to the following: The right to access \u2013 You have the right to request copies of your personal data. We may charge you a small fee for this service. The right to rectification \u2013 You have the right to request that we correct any information you believe is inaccurate. You also have the right to request that we complete the information you believe is incomplete. The right to erasure \u2013 You have the right to request that we erase your personal data, under certain conditions. The right to restrict processing \u2013 You have the right to request that we restrict the processing of your personal data, under certain conditions. The right to object to processing \u2013 You have the right to object to our processing of your personal data, under certain conditions. The right to data portability \u2013 You have the right to request that we transfer the data that we have collected to another organization, or directly to you, under certain conditions. If you make a request, we have one month to respond to you. If you would like to exercise any of these rights, please contact us. Children's Information Another part of our priority is adding protection for children while using the internet. We encourage parents and guardians to observe, participate in, and/or monitor and guide their online activity. nemo-simsar does not knowingly collect any Personal Identifiable Information from children under the age of 13. If you think that your child provided this kind of information on our website, we strongly encourage you to contact us immediately and we will do our best efforts to promptly remove such information from our records.","title":"Privacy Policy for nemo-simsar"},{"location":"privacy.html#privacy-policy-for-nemo-simsar","text":"At nemo-simsar, accessible from https://immerse-ocean.eu/nemo-simsar, one of our main priorities is the privacy of our visitors. This Privacy Policy document contains types of information that is collected and recorded by nemo-simsar and how we use it. If you have additional questions or require more information about our Privacy Policy, do not hesitate to contact us. This Privacy Policy applies only to our online activities and is valid for visitors to our website with regards to the information that they shared and/or collect in nemo-simsar. This policy is not applicable to any information collected offline or via channels other than this website. Our Privacy Policy was created with the help of the Privacy Policy Generator and the Free Privacy Policy Generator .","title":"Privacy Policy for nemo-simsar"},{"location":"publish_cloud.html","text":"Publish via cloud \ud83d\udd17","title":"Publish via cloud"},{"location":"publish_cloud.html#publish-via-cloud","text":"","title":"Publish via cloud"},{"location":"publish_general.html","text":"General Remarks \ud83d\udd17 Before publishing your simulation, please make sure you have read the Introduction and the Getting Started sections. Essential part of publishing is an easy way to acknowledge your work by using persistent handlers/object identifiers as a reference.","title":"General Remarks"},{"location":"publish_general.html#general-remarks","text":"Before publishing your simulation, please make sure you have read the Introduction and the Getting Started sections. Essential part of publishing is an easy way to acknowledge your work by using persistent handlers/object identifiers as a reference.","title":"General Remarks"},{"location":"publish_git.html","text":"Publish via GIT \ud83d\udd17 There are several service providers hosting remote git servers which can be used free of charge. You may even have access to your own git server on premise. No matter which way, choose one which can be easily accessed and is available even on the long run . Preparation \ud83d\udd17 Before you proceed, make sure you have a local git repository for your simulation ready as it is shown in the Bundle Up section. If not, please follow the instructions therein and come back afterward. Make sure, you have access to the git remote server and you have permission to create new repositories/projects or modify existing ones. I.e. you have registered a ssh key for authentication via SSH-connections, or you have a private or project related token for HTTPS-connections. If you're going to create a new repository within a special name space (group/team/organization) make sure you're granted with some write/maintain permissions therein as well; contact the group/team/organization leader (owner) to request permission. New git project \ud83d\udd17 If this is the first time, your Simulation Package will be submitted to a remote repository, you'll have t create a new remote project. Please follow the instructions for new repositories given by your git provider . In some cases you might be just able to create it on-the-fly by pushing into a project with a not-yet existing URL (If not, step 2 will fail). 1. Add remote host \ud83d\udd17 Go into your local git repository containing your Simulation Package and add a new git remote . In the example below, the name 'origin' is used to identify the remote, which is the default for the first remote repository. But you can choose another name of course as you like; in particular if you are going to have more than one remote and you want to reserve the name 'origin' for your private repository, or origin already exists. You can check existing remote entries with the command git remote -v while git remote add registers a new remote connection. cd $WORK/NEMO/release-4.0/cfgs/ORCA2_ICE/ git remote add origin git@github.com:mscheinert/ORCA2_ICE.git Name of the Repository/Project The directory you're going to push into a remote repository is a configuration folder. Nevertheless you may want to name the repository using a composite of both the configuration and experiment name if your repository will only contain one experiment: ConfigurationName - ExperimentName Access Level Most git hosts provide different types of repositories: private and public ones and those with ACL (Access Control List). Please make yourself familiar with the available options and choose wisely. Submitting to a group though may constrict your choices (e.g. no public repo in a closed group). Simulation Packages with a DOI MUST BE PUBLIC! 2. Push to Remote \ud83d\udd17 git push -u origin release-4.0 EXAMPLE See git repository ORCA2_ICE on GitHUB . 3. Update \ud83d\udd17 If you have changes you want to submit to remote, just add them, commit with a short message what has changed and push it to the remote. For example, if something was updated in the README: git add README.md git commit -m \"UPDATE Readme file: Added DOI\" git push","title":"publish via git"},{"location":"publish_git.html#publish-via-git","text":"There are several service providers hosting remote git servers which can be used free of charge. You may even have access to your own git server on premise. No matter which way, choose one which can be easily accessed and is available even on the long run .","title":"Publish via GIT"},{"location":"publish_git.html#preparation","text":"Before you proceed, make sure you have a local git repository for your simulation ready as it is shown in the Bundle Up section. If not, please follow the instructions therein and come back afterward. Make sure, you have access to the git remote server and you have permission to create new repositories/projects or modify existing ones. I.e. you have registered a ssh key for authentication via SSH-connections, or you have a private or project related token for HTTPS-connections. If you're going to create a new repository within a special name space (group/team/organization) make sure you're granted with some write/maintain permissions therein as well; contact the group/team/organization leader (owner) to request permission.","title":"Preparation"},{"location":"publish_git.html#new-git-project","text":"If this is the first time, your Simulation Package will be submitted to a remote repository, you'll have t create a new remote project. Please follow the instructions for new repositories given by your git provider . In some cases you might be just able to create it on-the-fly by pushing into a project with a not-yet existing URL (If not, step 2 will fail).","title":"New git project"},{"location":"publish_git.html#1-add-remote-host","text":"Go into your local git repository containing your Simulation Package and add a new git remote . In the example below, the name 'origin' is used to identify the remote, which is the default for the first remote repository. But you can choose another name of course as you like; in particular if you are going to have more than one remote and you want to reserve the name 'origin' for your private repository, or origin already exists. You can check existing remote entries with the command git remote -v while git remote add registers a new remote connection. cd $WORK/NEMO/release-4.0/cfgs/ORCA2_ICE/ git remote add origin git@github.com:mscheinert/ORCA2_ICE.git Name of the Repository/Project The directory you're going to push into a remote repository is a configuration folder. Nevertheless you may want to name the repository using a composite of both the configuration and experiment name if your repository will only contain one experiment: ConfigurationName - ExperimentName Access Level Most git hosts provide different types of repositories: private and public ones and those with ACL (Access Control List). Please make yourself familiar with the available options and choose wisely. Submitting to a group though may constrict your choices (e.g. no public repo in a closed group). Simulation Packages with a DOI MUST BE PUBLIC!","title":"1. Add remote host"},{"location":"publish_git.html#2-push-to-remote","text":"git push -u origin release-4.0 EXAMPLE See git repository ORCA2_ICE on GitHUB .","title":"2. Push to Remote"},{"location":"publish_git.html#3-update","text":"If you have changes you want to submit to remote, just add them, commit with a short message what has changed and push it to the remote. For example, if something was updated in the README: git add README.md git commit -m \"UPDATE Readme file: Added DOI\" git push","title":"3. Update"},{"location":"publish_gitpages.html","text":"Create Static Webpage (git pages) \ud83d\udd17 Info COMING SOON","title":"Create Static Webpage (git pages)"},{"location":"publish_gitpages.html#create-static-webpage-git-pages","text":"Info COMING SOON","title":"Create Static Webpage (git pages)"},{"location":"publish_pid.html","text":"Persistent Handlers/Object Identifiers \ud83d\udd17 Handlers , Persistent Identifiers (PID) or Document Object Identifiers (DOI) provide a convenient way for referring to your work, your Simulation Package. There are several ways of how to obtain such an ID. The easiest one might be the zenodo.org service which has been already mentioned in \"How to refer to Input Data\" . Please login to zenodo and follow the upload instructions . There will be a step for requesting a DOI before actually submitting any files (see also the last question in the \"General\" section of the zenodo FAQ ). You may want to request such a preliminary DOI before the final submit to your git repository in order to add this DOI to the package description (README.md).","title":"Persistent Handlers/Object Identifiers"},{"location":"publish_pid.html#persistent-handlersobject-identifiers","text":"Handlers , Persistent Identifiers (PID) or Document Object Identifiers (DOI) provide a convenient way for referring to your work, your Simulation Package. There are several ways of how to obtain such an ID. The easiest one might be the zenodo.org service which has been already mentioned in \"How to refer to Input Data\" . Please login to zenodo and follow the upload instructions . There will be a step for requesting a DOI before actually submitting any files (see also the last question in the \"General\" section of the zenodo FAQ ). You may want to request such a preliminary DOI before the final submit to your git repository in order to add this DOI to the package description (README.md).","title":"Persistent Handlers/Object Identifiers"},{"location":"simulation-meta.html","text":"Simulation Meta Data \ud83d\udd17 It is the meta data that allows objects, like data sets and model setups to be findable by both humans and machines. They are therefore an essential part of a simulation package that is going to be published or shared with others for further development. However, the compilation of the meta data can be a bold venture: on the one hand it is extremely useful to have every tiny detail to look for. On the other hand the user has to provide all the information in the first place which costs time, especially if the meta data requires a lots of tweaking and transformation. Which rises immediately the question What is the adequate set of meta data that supports effective search processes while keeping the effort at a low level? \" Before answering this question, we need to know the overall extent and the major components of the sharable object, the \"Simulation Package\". The Simulation Package \ud83d\udd17 The Simulation Package comprises the aforementioned components: The source code (code base and user modifications) The setting and environment for the build process (model conponents, macros and compiler choices) The run-time environment for a specific simulation (parameters and input) Control output for evaluation 1. Source Code \ud83d\udd17 The code base , a simulation is build from, must be unequivocally identifiable, i.e. the code must be version controlled and the exact revision must be known. NEMO uses Subversion as a version control system. Changes are tracked on the server globally and each modification (commit) is associated with a globel changeset/revision number. This can lead to situations where two checkouts represent the exact same code although the revision numbers are different. But together with the directory structure for the different development and release branches the code base for a specific simulation can be sufficently characterized and referenced . Code modifications and extensions on top for a simulation must be be tracked and controlled by the user. Refering to a private repository (svn or git) however might not be sufficient and implicates some risk regarding mid- and long-term documentation. This part of the code should be therefore included in the package . 2. Build Environment \ud83d\udd17 Beside the code base and the code modifications by the user, the build environment is another essential module in order to sustain a reproducible simulation development. It must be documented, which components of the code have been included ( model components ) and whether and how macro definitions ( CPP Keys ) for masking the code were involved. Furthermore, the manufacturer and the version of the compiler itself as well as the options and arguments of the compiler command must be put on record. 3. Run-time Environment \ud83d\udd17 Even with the same executable, complete different simulations can be achieved by slightly changing only a few parameters, boundary conditions or the initial state. While the run-time parameters (FORTRAN namelists) can be easily documented (they could be even transferred to some Database), input files have been neglected somehow. These data files are often hard to handle due to the size of a single file or a voluminous data collection. The size is also often the reason why there is no version control of such files and modifications are not tracked. Unfortunately, this compromises every effort to perform reproducible simulations and thus obstructs comprehensible research. SIMSAR provides a strategy how to overcome this huddle as laid out in the section Citable Input Data . For that purpose, the Simulation Package will contain a file ( input.ini ) which lists all necessary input data files each with an entry how to obtain the data and with the option to attach references , citations and a checksums . This is not a description of the input data as extensive as it is propsed for instance by the DataCite Metadata Schema , but it provides a first partial compliance with modern data management. Special attention should be also payed to the setup which defines the output data written during the run. Not only does this permit the experienced user to learn about what to expect from the output. But the user can also find more information about the structure of the output data if questions or uncertainties emerge during the analysis of the output. 4. Evaluation \ud83d\udd17 Part of the reproduction of a simulation is some check if the new output matches the results from the original simulation. Therefore, graphics and data fields from the original run are needed and should be attached to the Simulation Package (e.g. simple timeseries of indices or similar) while volumetric and/or raw data could be referenced using a persistent identifier (PID) for the published output data set. Assemble the Meta-Data \ud83d\udd17 In response to the question in the first paragraph, here is an overview of the meta-data you're going to assemble with SIMSAR: Pos. Scope Meta-Data Procedure 1 source code Repository, Branch, Revision, User Contact, README, git repo 2 build environment Model Components, CPP Keys, ~~Compiler Info~~ ( future version ) README 3 run-time environment FORTRAN namelists, XIOS XML, README, EXP folder 4 evaluation data graphics, time series, 2D fields DIAGS/ Mot of the meta-data can be gathered using the mkReadme script provided by SIMSAR. This script is run in the experiment folder and expects little input from the user while the majority is retrieved automatically. See the section Create the README file with mkReadme for instructions how to invoke the script or click on the button below. Create the README file with mkReadme","title":"Simulation Meta Data"},{"location":"simulation-meta.html#simulation-meta-data","text":"It is the meta data that allows objects, like data sets and model setups to be findable by both humans and machines. They are therefore an essential part of a simulation package that is going to be published or shared with others for further development. However, the compilation of the meta data can be a bold venture: on the one hand it is extremely useful to have every tiny detail to look for. On the other hand the user has to provide all the information in the first place which costs time, especially if the meta data requires a lots of tweaking and transformation. Which rises immediately the question What is the adequate set of meta data that supports effective search processes while keeping the effort at a low level? \" Before answering this question, we need to know the overall extent and the major components of the sharable object, the \"Simulation Package\".","title":"Simulation Meta Data"},{"location":"simulation-meta.html#the-simulation-package","text":"The Simulation Package comprises the aforementioned components: The source code (code base and user modifications) The setting and environment for the build process (model conponents, macros and compiler choices) The run-time environment for a specific simulation (parameters and input) Control output for evaluation","title":"The Simulation Package"},{"location":"simulation-meta.html#1-source-code","text":"The code base , a simulation is build from, must be unequivocally identifiable, i.e. the code must be version controlled and the exact revision must be known. NEMO uses Subversion as a version control system. Changes are tracked on the server globally and each modification (commit) is associated with a globel changeset/revision number. This can lead to situations where two checkouts represent the exact same code although the revision numbers are different. But together with the directory structure for the different development and release branches the code base for a specific simulation can be sufficently characterized and referenced . Code modifications and extensions on top for a simulation must be be tracked and controlled by the user. Refering to a private repository (svn or git) however might not be sufficient and implicates some risk regarding mid- and long-term documentation. This part of the code should be therefore included in the package .","title":"1. Source Code"},{"location":"simulation-meta.html#2-build-environment","text":"Beside the code base and the code modifications by the user, the build environment is another essential module in order to sustain a reproducible simulation development. It must be documented, which components of the code have been included ( model components ) and whether and how macro definitions ( CPP Keys ) for masking the code were involved. Furthermore, the manufacturer and the version of the compiler itself as well as the options and arguments of the compiler command must be put on record.","title":"2. Build Environment"},{"location":"simulation-meta.html#3-run-time-environment","text":"Even with the same executable, complete different simulations can be achieved by slightly changing only a few parameters, boundary conditions or the initial state. While the run-time parameters (FORTRAN namelists) can be easily documented (they could be even transferred to some Database), input files have been neglected somehow. These data files are often hard to handle due to the size of a single file or a voluminous data collection. The size is also often the reason why there is no version control of such files and modifications are not tracked. Unfortunately, this compromises every effort to perform reproducible simulations and thus obstructs comprehensible research. SIMSAR provides a strategy how to overcome this huddle as laid out in the section Citable Input Data . For that purpose, the Simulation Package will contain a file ( input.ini ) which lists all necessary input data files each with an entry how to obtain the data and with the option to attach references , citations and a checksums . This is not a description of the input data as extensive as it is propsed for instance by the DataCite Metadata Schema , but it provides a first partial compliance with modern data management. Special attention should be also payed to the setup which defines the output data written during the run. Not only does this permit the experienced user to learn about what to expect from the output. But the user can also find more information about the structure of the output data if questions or uncertainties emerge during the analysis of the output.","title":"3. Run-time Environment"},{"location":"simulation-meta.html#4-evaluation","text":"Part of the reproduction of a simulation is some check if the new output matches the results from the original simulation. Therefore, graphics and data fields from the original run are needed and should be attached to the Simulation Package (e.g. simple timeseries of indices or similar) while volumetric and/or raw data could be referenced using a persistent identifier (PID) for the published output data set.","title":"4. Evaluation"},{"location":"simulation-meta.html#assemble-the-meta-data","text":"In response to the question in the first paragraph, here is an overview of the meta-data you're going to assemble with SIMSAR: Pos. Scope Meta-Data Procedure 1 source code Repository, Branch, Revision, User Contact, README, git repo 2 build environment Model Components, CPP Keys, ~~Compiler Info~~ ( future version ) README 3 run-time environment FORTRAN namelists, XIOS XML, README, EXP folder 4 evaluation data graphics, time series, 2D fields DIAGS/ Mot of the meta-data can be gathered using the mkReadme script provided by SIMSAR. This script is run in the experiment folder and expects little input from the user while the majority is retrieved automatically. See the section Create the README file with mkReadme for instructions how to invoke the script or click on the button below. Create the README file with mkReadme","title":"Assemble the Meta-Data"}]}