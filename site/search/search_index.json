{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"nemo-simsar \ud83d\udd17 Document your NEMO ocean model simulations and share them with others using git remote repositories. This project is part of the IMMERSE Project funded by the EC. 1. Description \ud83d\udd17 Ocean model simulations that are based on the NEMO ocean modelling framework ( nemo-ocean.eu ) consists of several components: The source code provided by NEMO and by the user (FORTRAN code) Build settings (model components, compiler options) Runtime parameters (FORTRAN and XML namelists) Input data fIles (e.g. grid, bathymetry, boundary conditions, initialisation) While the first two components define a certain \" configuration \", the latter two provide the details for a specific experiment with the said configuration. Both together define a simulation . The recipes and the tools in this project allows users to create a package containing all the necessary information in order to share it with other users intending to reproduce the simulation or to start from this simulation with their own settings. See also the documentation in the doc/ folder for more details. Features \ud83d\udd17 Interactive script in order to create a README file (Markdown format) giving an overview of the simulation's settings and providing instructions how to include it in your own NEMO framework. Recipe to extract and upload a configuration from inside the NEMO framework into a remote git repository 2. Requirements \ud83d\udd17 Assuming you're working on a *nix like system you have to meet the following pre-requisits before running a tool or following a recipe from this project: A working NEMO framework (see nemo-ocean.eu ) A NEMO configuration + experiment details (=simulation) to share A definition list ( input.def ) containing names and remote sources of the citable, version-controlled input data files. See doc/inputfiles.md for details git client is installed and working access to a remote git server Python3 including these standard libraries: os re subprocess pathlib textwrap The following additional Python3 packages must be installed (e.g. with pip or conda or through your favorite package manager): svn ( pip ) wget ( pip ) GitPython ( pip ) Jinja2 ( pip ) pycurl ( pip ) A local copy of this git project. Terms of Use & License Agreement \ud83d\udd17 Before using this software, the user must agree to the license given by the LICENSE file in the project's repository. This software can be used free of charge. 3. Download & Installation \ud83d\udd17 First make sure that the required Python3 packages are installed on your local machine. If you're using pip for example, you can run the following command: pip3 install svn wget GitPython Jinja2 pycurl Then change to the directory where you want to keep your local copy of this project and clone it: git clone git@github.com:immerse-project/nemo-simsar.git Updates \ud83d\udd17 Go into your local copy of the nemo-simsar repository and run git fetch and review any changes before merging manually. git fetch Or, if you're inclined to merge any changes immediately into your local repository, just run a git pull : git pull 4. Usage \ud83d\udd17 Short notes on how to start/use the program and the command syntax (if necessary) The most important tool is the mkReadme script. Make sure, the full path to nemo-simsar/bin is part of your $PATH environment variable: # Bash-like: export PATH = /path/to/nemo-simsar/bin: ${ PATH } # or csh: setenv PATH /path/to/nemo-simsar/bin: ${ PATH } Before you can run the mkReadme tool, make sure, that the following information is available: The NEMO code repository , branch identifier and revision number the simulation's code is based on An input.def file listing file names of the input files used by NEMO and their remote sources as well as references (see the input.def template in the doc/ folder) Then go into your configuration's folder and run mkReadme mkReadme NOTE : If the nemo-simsar/bin is not part of your $PATH variable, run the script using the full path, something like: /home/myname/nemo-simsar/bin/mkReadme The script does not accept any arguments yet (May change in the future). Example \ud83d\udd17 Provide one ore more examples # Example 1: cd $HOME /NEMO/release-4.0/cfg/CrazyWhirl mkReadme Testing \ud83d\udd17 Currently, there is no testing implemented. 5. Documentation \ud83d\udd17 See the files in the doc/ sub-folder of this project. 6. Support \ud83d\udd17 There is only a limited support during the introduction phase of this package. Please, use the issue reporting on GitHub.","title":"nemo-simsar"},{"location":"index.html#nemo-simsar","text":"Document your NEMO ocean model simulations and share them with others using git remote repositories. This project is part of the IMMERSE Project funded by the EC.","title":"nemo-simsar"},{"location":"index.html#1-description","text":"Ocean model simulations that are based on the NEMO ocean modelling framework ( nemo-ocean.eu ) consists of several components: The source code provided by NEMO and by the user (FORTRAN code) Build settings (model components, compiler options) Runtime parameters (FORTRAN and XML namelists) Input data fIles (e.g. grid, bathymetry, boundary conditions, initialisation) While the first two components define a certain \" configuration \", the latter two provide the details for a specific experiment with the said configuration. Both together define a simulation . The recipes and the tools in this project allows users to create a package containing all the necessary information in order to share it with other users intending to reproduce the simulation or to start from this simulation with their own settings. See also the documentation in the doc/ folder for more details.","title":"1. Description"},{"location":"index.html#features","text":"Interactive script in order to create a README file (Markdown format) giving an overview of the simulation's settings and providing instructions how to include it in your own NEMO framework. Recipe to extract and upload a configuration from inside the NEMO framework into a remote git repository","title":"Features"},{"location":"index.html#2-requirements","text":"Assuming you're working on a *nix like system you have to meet the following pre-requisits before running a tool or following a recipe from this project: A working NEMO framework (see nemo-ocean.eu ) A NEMO configuration + experiment details (=simulation) to share A definition list ( input.def ) containing names and remote sources of the citable, version-controlled input data files. See doc/inputfiles.md for details git client is installed and working access to a remote git server Python3 including these standard libraries: os re subprocess pathlib textwrap The following additional Python3 packages must be installed (e.g. with pip or conda or through your favorite package manager): svn ( pip ) wget ( pip ) GitPython ( pip ) Jinja2 ( pip ) pycurl ( pip ) A local copy of this git project.","title":"2. Requirements"},{"location":"index.html#terms-of-use-license-agreement","text":"Before using this software, the user must agree to the license given by the LICENSE file in the project's repository. This software can be used free of charge.","title":"Terms of Use &amp; License Agreement"},{"location":"index.html#3-download-installation","text":"First make sure that the required Python3 packages are installed on your local machine. If you're using pip for example, you can run the following command: pip3 install svn wget GitPython Jinja2 pycurl Then change to the directory where you want to keep your local copy of this project and clone it: git clone git@github.com:immerse-project/nemo-simsar.git","title":"3. Download &amp; Installation"},{"location":"index.html#updates","text":"Go into your local copy of the nemo-simsar repository and run git fetch and review any changes before merging manually. git fetch Or, if you're inclined to merge any changes immediately into your local repository, just run a git pull : git pull","title":"Updates"},{"location":"index.html#4-usage","text":"Short notes on how to start/use the program and the command syntax (if necessary) The most important tool is the mkReadme script. Make sure, the full path to nemo-simsar/bin is part of your $PATH environment variable: # Bash-like: export PATH = /path/to/nemo-simsar/bin: ${ PATH } # or csh: setenv PATH /path/to/nemo-simsar/bin: ${ PATH } Before you can run the mkReadme tool, make sure, that the following information is available: The NEMO code repository , branch identifier and revision number the simulation's code is based on An input.def file listing file names of the input files used by NEMO and their remote sources as well as references (see the input.def template in the doc/ folder) Then go into your configuration's folder and run mkReadme mkReadme NOTE : If the nemo-simsar/bin is not part of your $PATH variable, run the script using the full path, something like: /home/myname/nemo-simsar/bin/mkReadme The script does not accept any arguments yet (May change in the future).","title":"4. Usage"},{"location":"index.html#example","text":"Provide one ore more examples # Example 1: cd $HOME /NEMO/release-4.0/cfg/CrazyWhirl mkReadme","title":"Example"},{"location":"index.html#testing","text":"Currently, there is no testing implemented.","title":"Testing"},{"location":"index.html#5-documentation","text":"See the files in the doc/ sub-folder of this project.","title":"5. Documentation"},{"location":"index.html#6-support","text":"There is only a limited support during the introduction phase of this package. Please, use the issue reporting on GitHub.","title":"6. Support"},{"location":"INDEX.html","text":"INTRODUCTION \ud83d\udd17 Document and share your NEMO ocean model simulations using remote git repositories This project is part of the EC funded IMMERSE project ( immerse-ocean.eu ) 1. Description \ud83d\udd17 Ocean model simulations that are based on the NEMO ocean modelling framework ( nemo-ocean.eu ) consists of several components: The source code provided by NEMO and by the user (FORTRAN code) Build settings (model components, compiler options) Runtime parameters (FORTRAN and XML namelists) Input data fIles (e.g. grid, bathymetry, boundary conditions, initialisation) While the first two components define a certain \" configuration \", the latter two provide the details for a specific experiment with the said configuration. Both together define a simulation . The recipes and the tools in this project allows users to create a package containing all the necessary information in order to share it with other users intending to reproduce the simulation or to start from this simulation with their own settings. See also the documentation in the doc/ folder for more details. Features \ud83d\udd17 Interactive script in order to create a README file (Markdown format) giving an overview of the simulation's settings and providing instructions how to include it in your own NEMO framework. Recipe to extract and upload a configuration from inside the NEMO framework into a remote git repository 2. Requirements \ud83d\udd17 Assuming you're working on a *nix like system you have to meet the following pre-requisits before running a tool or following a recipe from this project: A working NEMO framework (see nemo-ocean.eu ) A NEMO configuration + experiment details (=simulation) to share A definition list ( input.def ) containing names and remote sources of the citable, version-controlled input data files. See doc/inputfiles.md for details git client is installed and working access to a remote git server Python3 including these standard libraries: os re subprocess pathlib textwrap The following additional Python3 packages must be installed (e.g. with pip or conda or through your favorite package manager): svn ( pip ) wget ( pip ) GitPython ( pip ) Jinja2 ( pip ) pycurl ( pip ) A local copy of this git project. Terms of Use & License Agreement \ud83d\udd17 Before using this software, the user must agree to the license given by the LICENSE file in the project's repository. This software can be used free of charge. 3. Download & Installation \ud83d\udd17 First make sure that the required Python3 packages are installed on your local machine. If you're using pip for example, you can run the following command: pip3 install svn wget GitPython Jinja2 pycurl Then change to the directory where you want to keep your local copy of this project and clone it: git clone git@github.com:immerse-project/nemo-simsar.git Updates \ud83d\udd17 Go into your local copy of the nemo-simsar repository and run git fetch and review any changes before merging manually. git fetch Or, if you're inclined to merge any changes immediately into your local repository, just run a git pull : git pull 4. Usage \ud83d\udd17 Short notes on how to start/use the program and the command syntax (if necessary) The most important tool is the mkReadme script. Make sure, the full path to nemo-simsar/bin is part of your $PATH environment variable: # Bash-like: export PATH = /path/to/nemo-simsar/bin: ${ PATH } # or csh: setenv PATH /path/to/nemo-simsar/bin: ${ PATH } Before you can run the mkReadme tool, make sure, that the following information is available: The NEMO code repository , branch identifier and revision number the simulation's code is based on An input.def file listing file names of the input files used by NEMO and their remote sources as well as references (see the input.def template in the doc/ folder) Then go into your configuration's folder and run mkReadme mkReadme NOTE : If the nemo-simsar/bin is not part of your $PATH variable, run the script using the full path, something like: /home/myname/nemo-simsar/bin/mkReadme The script does not accept any arguments yet (May change in the future). Example \ud83d\udd17 Provide one ore more examples # Example 1: cd $HOME /NEMO/release-4.0/cfg/CrazyWhirl mkReadme Testing \ud83d\udd17 Currently, there is no testing implemented. 5. Documentation \ud83d\udd17 See the files in the doc/ sub-folder of this project. 6. Support \ud83d\udd17 There is only a limited support during the introduction phase of this package. Please, use the issue reporting on GitHub.","title":"INTRODUCTION"},{"location":"INDEX.html#introduction","text":"Document and share your NEMO ocean model simulations using remote git repositories This project is part of the EC funded IMMERSE project ( immerse-ocean.eu )","title":"INTRODUCTION"},{"location":"INDEX.html#1-description","text":"Ocean model simulations that are based on the NEMO ocean modelling framework ( nemo-ocean.eu ) consists of several components: The source code provided by NEMO and by the user (FORTRAN code) Build settings (model components, compiler options) Runtime parameters (FORTRAN and XML namelists) Input data fIles (e.g. grid, bathymetry, boundary conditions, initialisation) While the first two components define a certain \" configuration \", the latter two provide the details for a specific experiment with the said configuration. Both together define a simulation . The recipes and the tools in this project allows users to create a package containing all the necessary information in order to share it with other users intending to reproduce the simulation or to start from this simulation with their own settings. See also the documentation in the doc/ folder for more details.","title":"1. Description"},{"location":"INDEX.html#features","text":"Interactive script in order to create a README file (Markdown format) giving an overview of the simulation's settings and providing instructions how to include it in your own NEMO framework. Recipe to extract and upload a configuration from inside the NEMO framework into a remote git repository","title":"Features"},{"location":"INDEX.html#2-requirements","text":"Assuming you're working on a *nix like system you have to meet the following pre-requisits before running a tool or following a recipe from this project: A working NEMO framework (see nemo-ocean.eu ) A NEMO configuration + experiment details (=simulation) to share A definition list ( input.def ) containing names and remote sources of the citable, version-controlled input data files. See doc/inputfiles.md for details git client is installed and working access to a remote git server Python3 including these standard libraries: os re subprocess pathlib textwrap The following additional Python3 packages must be installed (e.g. with pip or conda or through your favorite package manager): svn ( pip ) wget ( pip ) GitPython ( pip ) Jinja2 ( pip ) pycurl ( pip ) A local copy of this git project.","title":"2. Requirements"},{"location":"INDEX.html#terms-of-use-license-agreement","text":"Before using this software, the user must agree to the license given by the LICENSE file in the project's repository. This software can be used free of charge.","title":"Terms of Use &amp; License Agreement"},{"location":"INDEX.html#3-download-installation","text":"First make sure that the required Python3 packages are installed on your local machine. If you're using pip for example, you can run the following command: pip3 install svn wget GitPython Jinja2 pycurl Then change to the directory where you want to keep your local copy of this project and clone it: git clone git@github.com:immerse-project/nemo-simsar.git","title":"3. Download &amp; Installation"},{"location":"INDEX.html#updates","text":"Go into your local copy of the nemo-simsar repository and run git fetch and review any changes before merging manually. git fetch Or, if you're inclined to merge any changes immediately into your local repository, just run a git pull : git pull","title":"Updates"},{"location":"INDEX.html#4-usage","text":"Short notes on how to start/use the program and the command syntax (if necessary) The most important tool is the mkReadme script. Make sure, the full path to nemo-simsar/bin is part of your $PATH environment variable: # Bash-like: export PATH = /path/to/nemo-simsar/bin: ${ PATH } # or csh: setenv PATH /path/to/nemo-simsar/bin: ${ PATH } Before you can run the mkReadme tool, make sure, that the following information is available: The NEMO code repository , branch identifier and revision number the simulation's code is based on An input.def file listing file names of the input files used by NEMO and their remote sources as well as references (see the input.def template in the doc/ folder) Then go into your configuration's folder and run mkReadme mkReadme NOTE : If the nemo-simsar/bin is not part of your $PATH variable, run the script using the full path, something like: /home/myname/nemo-simsar/bin/mkReadme The script does not accept any arguments yet (May change in the future).","title":"4. Usage"},{"location":"INDEX.html#example","text":"Provide one ore more examples # Example 1: cd $HOME /NEMO/release-4.0/cfg/CrazyWhirl mkReadme","title":"Example"},{"location":"INDEX.html#testing","text":"Currently, there is no testing implemented.","title":"Testing"},{"location":"INDEX.html#5-documentation","text":"See the files in the doc/ sub-folder of this project.","title":"5. Documentation"},{"location":"INDEX.html#6-support","text":"There is only a limited support during the introduction phase of this package. Please, use the issue reporting on GitHub.","title":"6. Support"},{"location":"RequiredInfo.html","text":"Required Meta Information \ud83d\udd17","title":"Preparation"},{"location":"RequiredInfo.html#required-meta-information","text":"","title":"Required Meta Information"},{"location":"api-mkreadme.html","text":"mkReadme \ud83d\udd17 \ud83d\udd17 Created on Fri Jan 10 10:31:20 2020 @author: luciennemicallef color \ud83d\udd17 This class stores a list of colours and font styles ask_exp00 ( exp ) \ud83d\udd17 exp is the configuration name Source code in mk_readme/clsmkReadme.py def ask_exp00 ( exp ): '''exp is the configuration name''' '''The purpose of this function is to show all directories for the chosen configuration ''' print ( \" \\n Chosen configuration is : \" , exp ) #list to store all the directories inside this configuration listWithAllDir = [] configPath = getNemoConfig () + \"/\" + exp #print(\"Config path\" , configPath) print ( \" \\n Directories for : \" , exp ) for r , d , f in os . walk ( configPath ): for directory in d : listWithAllDir . append ( directory ) #sort list listWithAllDir . sort () for i in listWithAllDir : print ( i ) choice = input ( \" \\n --> Are you sure that this is the configuration you would like to work with? Proceed with [Y] or [N] \\n\\n \" ) choice = choice . lower () if choice == 'y' : return True else : return False center ( text ) \ud83d\udd17 Centers the text to the midddle of the screen Source code in mk_readme/clsmkReadme.py def center ( text ): '''Centers the text to the midddle of the screen''' command = [ 'tput' , 'cols' ] width = int ( subprocess . check_output ( command )) print ( text . center ( width ), \" \\n \" ) check_confdir () \ud83d\udd17 The purpose of this function is to check if the script is in a configuration sub-folder in NEMOGCM/CONFIG Source code in mk_readme/clsmkReadme.py def check_confdir (): '''The purpose of this function is to check if the script is in a configuration sub-folder in NEMOGCM/CONFIG ''' pathLst = [] currentDirectory = os . getcwd () words = currentDirectory . split ( \"/\" , 4 ) for w in words : pathLst . append ( w ) lastElement = str ( pathLst [ len ( pathLst ) - 1 ]) #should be CONFIG print ( \"last Element \" , lastElement ) if ( lastElement != \"CONFIG\" ): errmsg ( \"It seems, we are not in a configuration sub-folder of NEMOGCM/CONFIG. I'm lost. \" + BOLD + \"Please run this script within a configuration folder!\" + NORMAL ) check_EXPref () \ud83d\udd17 This function will check whether the current location contains, EXP00 and EXPREF folder Source code in mk_readme/clsmkReadme.py def check_EXPref (): '''This function will check whether the current location contains, EXP00 and EXPREF folder''' path = os . getcwd () expRef = False for root , directories , files in os . walk ( path ): for folder in directories : #release 3 if \"EXP00\" in folder : expRef = True break #release 4 elif \"EXPREF\" in folder : expRef = True break return expRef check_gitorsvn () \ud83d\udd17 The purpose of this function is to check whether the current script is stored as a git repo or as an svn repo Source code in mk_readme/clsmkReadme.py def check_gitorsvn (): '''The purpose of this function is to check whether the current script is stored as a git repo or as an svn repo''' '''if LNGIT is True - the script is stored as a git repo''' '''if LNSVN is True - the script is stored as an svn svn repo''' global repo try : repo = git . Repo ( \".\" , search_parent_directories = True ) except git . InvalidGitRepositoryError : print ( BLUE + \"This is not a git repo \\n \" + NORMAL ) else : print ( BLUE + \"This is a Git Repo\" + NORMAL ) global LNGIT LNGIT = True if ( LNGIT == False ): try : repo = subprocess . check_output ( \"svn info | awk '/^Kind:/ {print $2}'\" , shell = True ) . strip () except svn . exception . SvnException : print ( BLUE + \"This is not an svn repo \\n \" + NORMAL ) except OSError as e : print ( \"Error - \" , e ) else : print ( BLUE + \"This is an SVN Repo\" + NORMAL ) global LNSVN LNSVN = True check_inputDef_exists () \ud83d\udd17 This function checks whether input.def file exists in the directory of the chosen configuration. If not the script will exit. Source code in mk_readme/clsmkReadme.py def check_inputDef_exists (): '''This function checks whether input.def file exists in the directory of the chosen configuration. If not the script will exit.''' if ( CURRCONFIG == True ): parent = os . path . dirname ( os . getcwd ()) else : parent = os . getcwd () #print(\"Parent \", parent) found = False files = [] #r=root, d=directories, f = files for r , d , f in os . walk ( parent ): for file in f : if 'input.def' in file : found = True files . append ( os . path . join ( r , file )) if found == True : return True else : return False check_prereq () \ud83d\udd17 This function will check that EXP00 or EXPREF directory is present in the current file structure Source code in mk_readme/clsmkReadme.py def check_prereq (): '''This function will check that EXP00 or EXPREF directory is present in the current file structure ''' if ( EXPref != \"EXP00\" ) and ( EXPref != \"EXPREF\" ): errmsg ( \"No EXP00/EXPREF folder with default settings was found. Please create one and re-run this script.\" ) else : cwflag = 0 #check_confdir() git_X = git . __version__ if len ( git_X ) > 0 : sucssmsg ( \"GIT found\" ) else : errmsg ( \"GIT not found\" ) svn_X = svn . __version__ if len ( svn_X ) > 0 : sucssmsg ( \"SVN found\" ) else : errmsg ( \"SVN not found\" ) ssh_X = os . system ( 'ssh -V' ) if len ( str ( ssh_X )) > 0 : sucssmsg ( \"SSH found\" ) else : errmsg ( \"SSH not found\" ) curl_X = pycurl . version if len ( curl_X ) > 0 : sucssmsg ( \"CURL found\" ) else : errmsg ( \"CURL not found\" ) cwflag = cwflag + 1 wget_X = wget . __version__ if len ( wget_X ) > 0 : sucssmsg ( \"WGET found\" ) else : errmsg ( \"WGET not found\" ) cwflag = cwflag + 1 if ( cwflag > 0 ): errmsg ( \"Neither CURL nor WGET was found. Abort\" ) m4_X = os . system ( 'm4 --version' ) if len ( str ( m4_X )) > 0 : sucssmsg ( \"m4 found\" ) else : errmsg ( \"m4 not found\" ) global zGITSERVER zGITSERVER = get_zGITSERVER () global zGITNMSPC zGITNMSPC = get_zGITNMSPC () print ( \"zGITSERVER: \" , zGITSERVER ) print ( \"zGITNMSPC: \" , zGITNMSPC ) checkScriptLocation () \ud83d\udd17 The purpose of this function is to check whether the script is being run from a particular configuration Source code in mk_readme/clsmkReadme.py def checkScriptLocation (): '''The purpose of this function is to check whether the script is being run from a particular configuration''' path2 = os . getcwd () configName = os . path . basename ( path2 ) #print(\"This script is saved in \", configName) for x in getAllConfigFolders (): if x == configName : global CURRCONFIG CURRCONFIG = True return x chooseConfigFolder () \ud83d\udd17 This function will ask the user to select one configuration from the list generated from getAllConfigFolders. The chosen config is stored in a global variable called exp which will be used throughout the script Source code in mk_readme/clsmkReadme.py def chooseConfigFolder (): '''This function will ask the user to select one configuration from the list generated from getAllConfigFolders. The chosen config is stored in a global variable called exp which will be used throughout the script''' valid = False global exp configList = [] print ( \" \\n\\n Config List: \\n \" ) for i in getAllConfigFolders (): configList . append ( i ) print ( i ) while valid == False : exp = input ( \" \\n Choose one of the above configurations : \\n\\n \" ) if exp in configList : valid = True return exp else : print ( \"Invalid entry, input has to match exactly (including capital letters)\" ) config_table () \ud83d\udd17 The purpose of this function is to generate the 'Configuration' section in the readme file Source code in mk_readme/clsmkReadme.py def config_table (): '''The purpose of this function is to generate the 'Configuration' section in the readme file ''' configLst = [ [ \"Characteristic\" , \"Specs\" ],[ \"**NEMOGCM repository**\" , _CURREPO_ ], [ \"**Git Branch**\" , _NEMOBRANCH_ ],[ \"**Nemo-ocean repository**\" , _NEMOREPO_ ], [ \"**Nemo-ocean revision**\" , _NEMOREVISION_ ],[ \"**Components**\" , _COMPONENTS_ ], [ \"**Reference Configuration**\" , _REFCONFIG_ ], [ \"**CPP keys**\" , _CPPKEYS_ ], [ \"**Grid**\" , _GRID_ ], [ \"**Resolution**\" , _RESOLUTION_ ], [ \"**Horizontal Gridpoints**\" , _HGRIDPT_ ],[ \"**Vertical Levels**\" , _VGRIDPTZ_ ], [ \"**Atmospheric Condition**\" , _ATMOS_ ],[ \"**Time Step [s]**\" , _OCEANRDT_ ], [ \"**Passive Tracers**\" , _PASSIVTRACERS_ ],[ \"**Number of Nests**\" , _NESTNUMBER_ ], ] markdown = \" \\n \" + str ( \"| \" ) for e in configLst [ 0 ]: to_add = \" \" + str ( e ) + str ( \" |\" ) markdown += to_add markdown += \" \\n \" markdown += '|' for i in range ( len ( configLst [ 0 ])): markdown += str ( \"-------------- | \" ) markdown += \" \\n \" for entry in configLst [ 1 :]: markdown += str ( \"| \" ) for e in entry : to_add = str ( e ) + str ( \" | \" ) markdown += to_add markdown += \" \\n \" return markdown + \" \\n \" errmsg ( msg ) \ud83d\udd17 Displays an error message in RED and reset text colour - Message will be passed as a parameter Source code in mk_readme/clsmkReadme.py def errmsg ( msg ): ''' Displays an error message in RED and reset text colour - Message will be passed as a parameter''' print ( RED + ' \\n ERROR: ' + msg + ' \\n\\n ' + NORMAL ) fillenv () \ud83d\udd17 This function returns variables which will be used to create the readme file Source code in mk_readme/clsmkReadme.py def fillenv (): '''This function returns variables which will be used to create the readme file''' global _CONFNAME_ _CONFNAME_ = get_confname () global _CONTACT_ _CONTACT_ = get_username () + \" - \" + get_useremail () global _PURPOSE_ _PURPOSE_ = get_purpose () global _CURREPO_ _CURREPO_ = get_currepo () global _NEMOREPO_ _NEMOREPO_ = get_nemorepo () global _NEMOREVISION_ _NEMOREVISION_ = get_nemorevision () global _NEMOBRANCH_ _NEMOBRANCH_ = get_branch () global _COMPONENTS_ _COMPONENTS_ = get_components () global _REFCONFIG_ _REFCONFIG_ = get_refconfig () global _CPPKEYS_ _CPPKEYS_ = get_cppkeys () global _RESOLUTION_ _RESOLUTION_ = get_resolution () global _GRID_ _GRID_ = get_hgridtype () + \", \" + get_vgridtype () global _HGRIDPT_ _HGRIDPT_ = get_hgridpt () global _VGRIDPTZ_ _VGRIDPTZ_ = get_vgridpt () global _ATMOS_ _ATMOS_ = get_atmos () global _OCEANRDT_ _OCEANRDT_ = get_oceanrdt () global _NESTNUMBER_ _NESTNUMBER_ = get_nestnumber () global _PASSIVTRACERS_ _PASSIVTRACERS_ = get_passivetracers () global _zGITSERVER_ _zGITSERVER_ = get_zGITSERVER () global _zGITNMSPC_ _zGITNMSPC_ = get_zGITNMSPC () global _zPAGE_ _zPAGE_ = get_zPAGESRV () get_atmos () \ud83d\udd17 This function will return the number of surface boundary condition from namelist_cfg file. Returns unknown if value is not available Source code in mk_readme/clsmkReadme.py def get_atmos (): '''This function will return the number of surface boundary condition from namelist_cfg file. Returns unknown if value is not available''' stringToMatch = '&namsbc ' matchedLine = '' namsbcLst = [] #stores all elements in &namsbc lnLst = [] #stores all ln_ elements nnLst = [] #stores all nn_ elements vaxLst = [] #stores the prefix e.g. blk_core, ana etc.. v = \"\" #returns the line with .true. vax = \"\" default = \"\" #get list of namelists allCFG = getNameLists () #remove empty spaces allCFG = allCFG . replace ( \" \" , \"\" ) print ( \" \\n --> Defining the surface boundary condition. Accept with [ENTER]: \\n\\n \" ) f = open ( allCFG , \"r\" ) for line in f : if stringToMatch in line : matchedLine = line for line in f : if not ( line . startswith ( \"/\" )): namsbcLst . append ( line ) else : break #check for ln_ for item in namsbcLst : if item . find ( \"ln_\" ) != - 1 : lnLst . append ( item ) for i in lnLst : if \"true\" in i : v = i #get last part after the ln_ _index = v . find ( \"_\" ) eqIndex = v . find ( \"=\" ) vax = v [ _index + 1 : eqIndex ] #retrieve the value after _ vax = vax . strip () #remove white spaces vaxLst . append ( vax ) for v in vaxLst : if ( v == \"ana\" ): default = \"Analytical forcing\" #output = BOLD + \"Surface Boundary Condition: \" + NORMAL + \"\" + default #print(output) elif ( v == \"flx\" ): default = \"Flux formulation\" #output = BOLD + \"Surface Boundary Condition: \" + NORMAL + \"\" + default #print(output) elif ( v == \"blk_clio\" ): default = \"CLIO bulk formulation\" #output = BOLD + \"Surface Boundary Condition: \" + NORMAL + \"\" + default #print(output) elif ( v == \"blk_core\" ): default = \"CORE bulk formulation\" #output = BOLD + \"Surface Boundary Condition: \" + NORMAL + \"\" + default #print(output) elif ( v == \"blk_mfs\" ): default = \"MFS bulk formulation\" #output = BOLD + \"Surface Boundary Condition: \" + NORMAL + \"\" + default #print(output) elif ( v == \"cpl\" ): default = \"Coupled to atmosphere\" #output = BOLD + \"Surface Boundary Condition: \" + NORMAL + \"\" + default #print(output) elif ( v == \"mixcpl\" ): default = \"Forced & coupled atmosphere\" #output = BOLD + \"Surface Boundary Condition: \" + NORMAL + \"\" + default #print(output) elif ( v == \"rnf\" ): default = default + \" + separate runoff\" # check for nn_ for itemN in namsbcLst : if itemN . find ( \"nn_fwb\" ) != - 1 : #get the digits between = and . eqIndex = itemN . find ( \"=\" ) dotIndex = itemN . find ( \"!\" ) output = itemN [ eqIndex + 1 : dotIndex ] #retrieve the value after _ output = output . strip () #remove white spaces if default == \"\" : print ( PURPLE + \"Unknown\" + NORMAL ) return \"Unknown\" else : print ( PURPLE + default + \" + Freshwater Budget Correction (Mode \" + output + \")\" + NORMAL ) return str ( default + \" + Freshwater Budget Correction (Mode \" + output + \")\" ) get_branch () \ud83d\udd17 This function will return the branch number for this repo Source code in mk_readme/clsmkReadme.py def get_branch (): '''This function will return the branch number for this repo''' print ( \" \\n \" ) print ( \"--> Which branch are you using? Try to get it from git/svn. Accept with [ENTER]: \" ) if ( LNGIT == True ): repo = git . Repo ( \".\" , search_parent_directories = True ) default = repo . active_branch print ( PURPLE + str ( default ) + NORMAL ) return default #else: #print (\"LNGIT is false\") if ( LNSVN == True ): getBranchInfo = subprocess . check_output ( \"svn info | awk '/^URL:/ {print $2}'\" , shell = True ) . strip () getBranch = str ( getBranchInfo ) branchSplit = getBranch . split ( '/' ) #Get the last part of the string getBranch = branchSplit [ - 1 ] getBranch = getBranch . replace ( \"'\" , \"\" ) print ( PURPLE + str ( getBranch ) + NORMAL ) return getBranch get_components () \ud83d\udd17 This function returns the NEMO components for this repo from cfg.txt or ref_cfg.txt Source code in mk_readme/clsmkReadme.py def get_components (): '''This function returns the NEMO components for this repo from cfg.txt or ref_cfg.txt''' cfgPath = \"\" componentsLst = [] findExactComponent = [] componentsLst . append ( ' \\n ' ) print ( \" \\n --> What NEMO components are we using? Try to get a comma-separated list from ../cfg.txt. Accept with [ENTER]: \\n \" ) #get file path for /cfg.txt currentDirectory = getNemoConfig () confName = os . path . basename ( currentDirectory ) if release3 == True : cfgPath = open ( getNemoConfig () + \"/cfg.txt\" , \"r\" ) elif release4 == True : cfgPath = open ( getNemoConfig () + \"/ref_cfgs.txt\" , \"r\" ) for i in cfgPath : if exp in i : componentsLst . append ( i ) #go through the list to check for multiplies if ( len ( componentsLst ) == 1 ): #print(cfgNameLists) output = componentsLst else : #add each item to the list for i in range ( len ( componentsLst )): findExactComponent . append ( componentsLst [ i ]) #Search through each item for the exact configuration name for item in findExactComponent : #for i in item: pathSplit = item . split ( ' ' ) #Get the first element from the last output = str ( pathSplit [ 0 ]) print ( PURPLE + '' . join ([ str ( elem ) for elem in output ]) + NORMAL ) return '' . join ([ str ( elem ) for elem in output ]) get_confname () \ud83d\udd17 Returns the configuration name which is the variable stored as 'exp' Source code in mk_readme/clsmkReadme.py def get_confname (): '''Returns the configuration name which is the variable stored as 'exp' ''' print ( \" \\n --> What is the name you want to use for publishing this configuration with DRAKKARshare? Our first guess is, that it's the configuration name in the current path. Accept with [ENTER] or modify accordingly: \\n\\n \" ) currentDirectory = os . getcwd () confName = os . path . basename ( currentDirectory ) pathSplit = currentDirectory . split ( '/' ) print ( PURPLE + \"Configuration's name: \" + exp + \"\" + NORMAL ) #returns the chosen configuration by the use return exp get_cppkeys () \ud83d\udd17 This function searches for .fcm file and extracts the cpp keys Source code in mk_readme/clsmkReadme.py def get_cppkeys (): '''This function searches for .fcm file and extracts the cpp keys''' lastElement = \"\" cppList = [] cppList2 = [] findExactCPP = [] output = \"\" matchPath = \"\" multiples = False path = getNemoConfig () found = False for ( dirname , dirs , files ) in os . walk ( path ): # for (dirname, dirs, files) in os.walk('.'): for filename in files : if exp in filename : if filename . endswith ( '.fcm' ) : #ADD filename to list cppList . append ( filename ) if len ( cppList ) == 1 : thefile = os . path . join ( dirname , filename ) #open file and read contents f = open ( thefile , \"r\" ) cppkeysContents = f . read () f . close () else : #multiples is used when the config file appears more than once, e.g. ORCA2_LIM multiples = True #add each item to the list if ( multiples == True ): for i in range ( len ( cppList )): findExactCPP . append ( cppList [ i ]) #Search through each item for the exact CPP key for item in findExactCPP : #item e.g. cpp_GYRE_PISCES.fcm, split by first _ and . underscoreIndex = item . find ( \"_\" ) dotIndex = item . find ( \".\" ) res = item [ underscoreIndex + 1 : dotIndex ] if res == exp : found = True break if ( found == True ): matchPath = os . path . join ( path , res , item ) #print(matchPath) x = open ( matchPath , \"r\" ) cppkeysContents = x . read () x . close () #remove bld::tool::fppkeys by replacing this text empty text #sample: bld::tool::fppkeys key_diaeiv key_dynldf_c2d content = cppkeysContents . replace ( ' \\n ' , ' ' ) content = content . replace ( 'bld::tool::fppkeys ' , '' ) return '' . join ( str ( content )) get_currepo () \ud83d\udd17 The purpose of this function is to display the actual repo from were NEMO was cloned Source code in mk_readme/clsmkReadme.py def get_currepo (): '''The purpose of this function is to display the actual repo from were NEMO was cloned''' print ( \" \\n --> Are we in a git/svn working tree? And from which remote repository was NEMOGCM cloned? Try to get it from git/svn. Accept with [ENTER]: \\n \" ) if ( LNGIT == True ): try : repo = git . Repo ( \".\" , search_parent_directories = True ) remoteLocation = repo . remote ( \"origin\" ) . url default = remoteLocation if ( default != \"\" ) & ( LNGIT == True ): print ( PURPLE + \"This is a GIT Repo \" + NORMAL ) print ( PURPLE + \"Actual Repository = \" + default + \"\" + NORMAL ) return default except git . InvalidGitRepositoryError : print ( PURPLE + \"Not connected to GIT\" + NORMAL ) else : pass if ( LNSVN == True ): try : default = subprocess . check_output ( \"svn info | awk '/^URL:/ {print $2}'\" , shell = True ) . strip () #convert to string default = str ( default ) default = default . replace ( \"'\" , \"\" ) if ( default != \"\" ) & ( LNSVN == True ): print ( PURPLE + \"This is an SVN Repo \" + NORMAL ) print ( PURPLE + \"Actual Repository = \" + str ( default [ 1 :]) + NORMAL ) return default [ 1 :] else : print ( PURPLE + \"Not connected to SVN\" + NORMAL ) except svn . exception . SvnException : print ( \"This is not a working copy of SVN - Not connected to SVN\" ) else : pass get_hgridpt () \ud83d\udd17 This function will return the value corresponding to the hortizonatal grid type from namelist_cfg file. Returns unknown if value is not available Source code in mk_readme/clsmkReadme.py def get_hgridpt (): '''This function will return the value corresponding to the hortizonatal grid type from namelist_cfg file. Returns unknown if value is not available''' stringToMatch = 'namcfg' defaultx = \"\" defaulty = \"\" output = 0 #get list of namelists allCFG = getNameLists () #remove empty spaces allCFG = allCFG . replace ( \" \" , \"\" ) # print ( \" \\n --> Number of grid points in the horizontal. Accept with [ENTER]: \\n\\n \" ) f = open ( allCFG , \"r\" ) #print(\"\\n File name: \", line) for line in f : #find the section namcfg if stringToMatch in line : #print(line) for line in f : if \"jpidta\" in line : defaultx = line #continue printing until line matches \"/\" if \"jpjdta\" in line : #if endStringToMatch2 in line: defaulty = line break #extract digits only from defaultX outputX = 0 repl_str = re . compile ( '^\\d+$' ) line = defaultx . split () for word in line : match = re . search ( repl_str , word ) if match : outputX = float ( match . group ()) #extract digits only from defaultY outputY = 0 #repl_str = re.compile('\\d+.?\\d*') repl_str = re . compile ( '^\\d+$' ) #t = r'\\d+.?\\d*' line = defaulty . split () for word in line : match = re . search ( repl_str , word ) if match : outputY = float ( match . group ()) #multiply two points #output = outputX * outputY output = str ( outputX ) + \" x \" + str ( outputY ) #print(BOLD + \"Horizontal Grid Points (I x J):\" +NORMAL+ \" \"+ str(output)) if str ( output ) == \"\" : print ( PURPLE + \"Unknown\" + NORMAL ) return \"Unknown\" else : print ( PURPLE + str ( output ) + NORMAL ) return str ( output ) get_hgridtype () \ud83d\udd17 This function will return the value corresponding to the horizontal grid type from namelist_cfg file. Returns unknown if value is not available Source code in mk_readme/clsmkReadme.py def get_hgridtype (): '''This function will return the value corresponding to the horizontal grid type from namelist_cfg file. Returns unknown if value is not available''' stringToMatch = 'namcfg' matchedLine = '' endStringToMatch = \"/\" endStringToMatch2 = \"cp_cfg\" output = \"\" #get list of namelists allCFG = getNameLists () #remove empty spaces allCFG = allCFG . replace ( \" \" , \"\" ) result = \"\" #default = \"\" print ( \" \\n --> Horizontal grid type, e.g. ORCA for a global tri-polar grid. Accept our guess with [ENTER]: \\n\\n \" ) #go through the list of files with namelist_cfg # for line in allCFG: #for each file read.. f = open ( allCFG , \"r\" ) #print(\"File Name \", line) for line in f : if stringToMatch in line : matchedLine = line #print(\"Matched Line \", matchedLine) for line in f : output = line result = result + line #print(\"Output \", line) #outputS = BOLD + \"Horizontal Grid Type: \"+NORMAL+output #print(outputS) #hGridType.append(outputS) #continue printing until line matches \"/\" #if (line.startswith(\"/\")): if endStringToMatch2 in line : break x = result . split ( \"!\" ) #remove the dashed line newX = \"\" for i in x [ 1 ]: newX = newX + i . replace ( '-' , '' ) #return only the value in the \"\" and do not print cp_cfg _index = newX . find ( \"=\" ) default = newX [ _index + 1 :] #retrieve the value after = default = default . strip () #remove white space print ( PURPLE + default . strip () + NORMAL ) return default . strip () get_nemoGit () \ud83d\udd17 This function will search for the git file Source code in mk_readme/clsmkReadme.py def get_nemoGit (): '''This function will search for the git file ''' global nemoGitRepo pathSplit = \"\" #find Nemo/.git proc = subprocess . check_output ([ \"locate\" , \"-r\" , \"\\.git$\" ]) proc = str ( proc ) pathSplit = proc . split ( \" \\\\ n\" ) for p in pathSplit : if \"/NEMOGCM/.git\" in p : nemoGitRepo = p return nemoGitRepo get_nemorepo () \ud83d\udd17 This function displays the URL of the repository the NEMO was installed from Source code in mk_readme/clsmkReadme.py def get_nemorepo (): '''This function displays the URL of the repository the NEMO was installed from ''' print ( \" \\n\\n\\n --> What is the URL of the repository you installed NEMO from? Try to get it from git/svn. Accept with [ENTER]:\" ) if ( LNGIT == True ): getIndexHash = \"\" #command = '--grep=\"jussieu\" --pretty=oneline --abbrev-commit --reverse | cut -d ' ' -f 3 |head -n 1' proc = subprocess . check_output ([ \"git\" , \"log\" , \"--pretty=oneline\" , \"--abbrev-commit\" , \"--reverse\" ]) proc = str ( proc ) getSvnIDText = proc . find ( 'http' ) getIndexHash = proc . find ( '@' ) getUrl = proc [ getSvnIDText : getIndexHash ] print ( PURPLE + \"\" + getUrl + \"\" + NORMAL ) return ( getUrl ) if ( LNSVN == True ): #command = '--grep=\"jussieu\" --pretty=oneline --abbrev-commit --reverse | cut -d ' ' -f 3 |head -n 1' getURLsvn = subprocess . check_output ( \"svn info | awk '/^URL:/ {print $2}'\" , shell = True ) . strip () getURLsvn = str ( getURLsvn ) getURLsvn = getURLsvn . replace ( \"'\" , \"\" ) print ( PURPLE + \"\" + str ( getURLsvn [ 1 :]) + \"\" + NORMAL ) return ( getURLsvn [ 1 :]) get_nemorevision () \ud83d\udd17 This function will display the revision number for the current NEMO version Source code in mk_readme/clsmkReadme.py def get_nemorevision (): '''This function will display the revision number for the current NEMO version ''' print ( \" \\n\\n\\n --> What is the NEMO revision you're currently using? Try to get it from git/svn history. Accept with [ENTER]:\" ) if ( LNGIT == True ): try : proc = subprocess . check_output ([ \"git\" , \"log\" , \"--pretty=oneline\" , \"--abbrev-commit\" , \"--reverse\" ]) proc = str ( proc ) getSvnIDText = proc . find ( 'http' ) getIndexHash = proc . find ( '#' ) nemoRev1 = proc [ getSvnIDText : getIndexHash ] getAT = nemoRev1 . find ( '@' ) getspace = nemoRev1 . find ( ' ' ) nemoRev2 = nemoRev1 [ getAT + 1 : getspace ] print ( PURPLE + nemoRev2 + NORMAL ) return ( nemoRev2 ) except git . InvalidGitRepositoryError : print ( PURPLE + \"Not connected to GIT\" + NORMAL ) except OSError as e : print ( \"Error - \" , e ) if ( LNSVN == True ): try : nemoRev = subprocess . check_output ( \"svn info | awk '/^Revision:/ {print $2}'\" , shell = True ) . strip () nemoRev = str ( nemoRev ) nemoRev = nemoRev . replace ( \"'\" , \"\" ) print ( PURPLE + str ( nemoRev [ 1 :]) + NORMAL ) return ( nemoRev [ 1 :]) except svn . exception . SvnException : print ( \"This is not an svn repo \\n \" ) get_nestnumber () \ud83d\udd17 This function will ask for user input to enter number of AGRIF Nests. Returns 0 if value is not available Source code in mk_readme/clsmkReadme.py def get_nestnumber (): '''This function will ask for user input to enter number of AGRIF Nests. Returns 0 if value is not available''' default = 0 print ( \" \\n --> How many \" + BOLD + \"AGRIF nests \" + NORMAL + \" are embedded? Accept our guess with [ENTER] or [M]odify accordingly: \\n\\n \" ) print ( PURPLE + \"Nest Number: \" + NORMAL + \"is \" + str ( default )) choice = input () choice = choice . lower () if choice == 'm' : default = input ( \"Input value: \" ) return default else : return default get_oceanrdt () \ud83d\udd17 This function will return the length of the general ocean time step for dynamics from namelist_cfg file. Returns unknown if value is not available Source code in mk_readme/clsmkReadme.py def get_oceanrdt () : '''This function will return the length of the general ocean time step for dynamics from namelist_cfg file. Returns unknown if value is not available''' stringToMatch = 'namdom' defaultT = \"\" output = 0 allCFG = getNameLists () #remove empty spaces allCFG = allCFG . replace ( \" \" , \"\" ) print ( \" \\n --> The length of the general ocean time step for dynamics. Accept with [ENTER]: \\n\\n \" ) f = open ( allCFG , \"r\" ) for line in f : if stringToMatch in line : #print(line) for line in f : if \"rn_rdt\" in line : defaultT = line #get the digits between = and . eqIndex = defaultT . find ( \"=\" ) dotIndex = defaultT . find ( \".\" ) output = defaultT [ eqIndex + 1 : dotIndex ] #retrieve the value after _ output = output . strip () #remove white spaces #print(BOLD + \"Time Step for Dynamics [sec]: \" + NORMAL + \"\" + str(output)) break #get the digits between = and . eqIndex = defaultT . find ( \"=\" ) dotIndex = defaultT . find ( \".\" ) output = defaultT [ eqIndex + 1 : dotIndex ] #retrieve the value after _ output = output . strip () #remove white spaces if str ( output ) == \"\" : print ( PURPLE + \"Unknown\" + NORMAL ) return \"Unknown\" else : print ( PURPLE + str ( output ) + NORMAL ) return str ( output ) get_passivetracers () \ud83d\udd17 This function will ask for user input which additional passive tracers are implemented. Returns unknown if value is not available Source code in mk_readme/clsmkReadme.py def get_passivetracers (): '''This function will ask for user input which additional passive tracers are implemented. Returns unknown if value is not available''' default = \"Unknown\" print ( \" \\n --> Which additional passive tracers are implemented? Accept our guess with [ENTER] or [M]odify accordingly: \\n\\n \" ) print ( PURPLE + \"List of passive tracers (TOP): \" + NORMAL + \"is \" + default ) choice = input () choice = choice . lower () if choice == 'm' : default = input ( \"Input value: \" ) return default else : return default get_purpose () \ud83d\udd17 This function creates a text file to store the purpose of the readme file or reads the existing text file Source code in mk_readme/clsmkReadme.py def get_purpose (): '''This function creates a text file to store the purpose of the readme file or reads the existing text file ''' pathS = pathlib . Path () . absolute () if ( LNGIT == True ) and ( CURRCONFIG == False ): dirName = str ( pathS ) + \"/CONFIG/\" + exp + \"/.includes\" elif ( LNSVN == True ) and ( CURRCONFIG == False ) and ( release3 == True ): dirName = str ( pathS ) + \"/NEMOGCM/CONFIG/\" + exp + \"/.includes\" elif ( LNSVN == True ) and ( CURRCONFIG == False ) and ( release4 == True ): dirName = str ( pathS ) + \"/cfgs/\" + exp + \"/.includes\" #if current script is stored in one of the configurations elif ( CURRCONFIG == True ): dirName = str ( pathS ) + \"/.includes\" try : # Create target Directory os . mkdir ( dirName ) purpose = input ( \" \\n\\n --> What's the purpose of this configuration?: \\n \" ) f = open ( dirName + \"/.recall_purpose.txt\" , \"w\" ) f . write ( purpose ) f = open ( dirName + \"/.recall_purpose.txt\" , \"r\" ) purpose = f . read () print ( PURPLE + purpose + NORMAL ) return ( purpose ) #if file already exists, read the contents and provide an option for modification (overwritten) except FileExistsError : f = open ( dirName + \"/.recall_purpose.txt\" , \"r\" ) #ask if content is as expected print ( \" \\n\\n --> What's the purpose of this configuration? Trying to remember last answer\" ) purpose = f . read () print ( PURPLE + purpose + NORMAL ) choice = input ( \"Accept with [ENTER] or modify accordingly (press [M] to modify): \" ) choice = choice . lower () if choice == 'm' : purpose = input ( \"Enter a new purpose, this will be overwritten: \" ) f = open ( dirName + \"/.recall_purpose.txt\" , \"w\" ) f . write ( purpose ) f = open ( dirName + \"/.recall_purpose.txt\" , \"r\" ) purpose = f . read () print ( PURPLE + purpose + NORMAL ) return ( purpose ) else : return ( purpose ) f . close () else : print ( \"Unable to create this file, check admin rights\" ) get_refconfig () \ud83d\udd17 This function asks for user input to return the reference configuration for a particular configuration. This may also be left blank Source code in mk_readme/clsmkReadme.py def get_refconfig (): '''This function asks for user input to return the reference configuration for a particular configuration. This may also be left blank ''' zrefconfname = \"\" zrefconfurl = \"\" zrefconfname = input ( \"--> If there is a reference configuration this particular configuration is based on, please type the name. Otherwise leave it blank by typing [ENTER]. \\n \" ) zrefconfurl = input ( \"--> If there is a reference configuration this particular configuration is based on, please type the URL. Otherwise leave it blank by typing [ENTER]. \\n \" ) return zrefconfname + \" - \" + zrefconfurl get_resolution () \ud83d\udd17 This function will return the value corresponding to the resolution of the horizontal grid from namelist_cfg file. Returns unknown if value is not available Source code in mk_readme/clsmkReadme.py def get_resolution (): '''This function will return the value corresponding to the resolution of the horizontal grid from namelist_cfg file. Returns unknown if value is not available ''' stringToMatch = 'namcfg' defaultK = \"\" output = 0 #get list of namelists allCFG = getNameLists () #remove empty spaces allCFG = allCFG . replace ( \" \" , \"\" ) print ( \" \\n --> The resolution of the horizontal grid. Accept with [ENTER]: \\n\\n \" ) f = open ( allCFG , \"r\" ) print ( \"all CFG is \" , allCFG ) for line in f : #find the section namcfg if stringToMatch in line : #print(line) for line in f : if \"jp_cfg\" in line : defaultK = line break #print(defaultK) #extract digits only from defaultK output = 0 repl_str = re . compile ( '^\\d+$' ) line = defaultK . split () for word in line : match = re . search ( repl_str , word ) if match : output = float ( match . group ()) #print(BOLD + \"Vertical Grid Points (K): \" + NORMAL + \"\" + str(output)) print ( PURPLE + str ( output ) + NORMAL ) return str ( output ) get_useremail () \ud83d\udd17 This function returns the user email, if available in the config file Source code in mk_readme/clsmkReadme.py def get_useremail (): '''This function returns the user email, if available in the config file ''' if ( LNGIT == True ): try : repo = git . Repo ( \".\" , search_parent_directories = True ) print ( \" \\n --> What is your email address? We try to get it from git. Accept with [ENTER] or modify accordingly: \\n\\n \" ) reader = repo . config_reader () default = reader . get_value ( 'user' , 'email' ) output = PURPLE + \"User's email :\" + default + NORMAL print ( output ) return default except : try : choice = input ( \"Config file does not include the email address, please amend accordingly in .git > config. Proceed with [ENTER] to continue with 'Unknown' or abort with CTRL-C: \" ) except KeyboardInterrupt : print ( \"You pressed Ctrl+C!\" ) finally : return \"Unknown\" else : pass if ( LNSVN == True ): try : email = input ( \" \\n --> Enter your email address (temporarily) or press [Ctrl-C] to exit and update through git-init \\n\\n \" ) return email except KeyboardInterrupt : print ( \"Exit.. \" ) get_username () \ud83d\udd17 This function returns the username, if available in the config file Source code in mk_readme/clsmkReadme.py def get_username (): '''This function returns the username, if available in the config file ''' if ( LNGIT == True ): try : repo = git . Repo ( \".\" , search_parent_directories = True ) print ( \" \\n --> What is your full name? We try to get it from git. Accept with [ENTER] or modify accordingly: \\n\\n \" ) reader = repo . config_reader () default = reader . get_value ( 'user' , 'name' ) output = PURPLE + \"User's Full Name :\" + default + NORMAL # return output print ( output ) return default except : try : choice = input ( \"Config file does not include the user name, please amend accordingly in .git > config. Proceed with [ENTER] to continue with 'Unknown' or abort with CTRL-C: \" ) except KeyboardInterrupt : print ( \"You pressed Ctrl+C!\" ) finally : return \"Unknown\" else : pass if ( LNSVN == True ): try : username = input ( \" \\n --> Enter your full name (temporarily) or press [Ctrl-C] to exit and update through git-init \\n\\n \" ) return username except KeyboardInterrupt : print ( \"Exit..\" ) get_vgridpt () \ud83d\udd17 This function will return the number of grid points in vertical grid from namelist_cfg file. Returns unknown if value is not available Source code in mk_readme/clsmkReadme.py def get_vgridpt (): '''This function will return the number of grid points in vertical grid from namelist_cfg file. Returns unknown if value is not available''' stringToMatch = 'namcfg' defaultK = \"\" output = 0 #get list of namelists allCFG = getNameLists () #remove empty spaces allCFG = allCFG . replace ( \" \" , \"\" ) print ( \" \\n --> Number of grid points in the vertical? Accept with [ENTER]: \\n\\n \" ) f = open ( allCFG , \"r\" ) for line in f : #find the section namcfg if stringToMatch in line : #print(line) for line in f : if \"jpkdta\" in line : defaultK = line break #print(defaultK) #extract digits only from defaultK output = 0 repl_str = re . compile ( '^\\d+$' ) line = defaultK . split () for word in line : match = re . search ( repl_str , word ) if match : output = float ( match . group ()) #print(BOLD + \"Vertical Grid Points (K): \" + NORMAL + \"\" + str(output)) if str ( output ) == \"\" : print ( PURPLE + \"Unknown\" + NORMAL ) return \"Unknown\" else : print ( PURPLE + str ( output ) + NORMAL ) return str ( output ) get_vgridtype () \ud83d\udd17 This function will return the value corresponding to the vertical grid type from namelist_cfg file. Returns unknown if value is not available Source code in mk_readme/clsmkReadme.py def get_vgridtype (): '''This function will return the value corresponding to the vertical grid type from namelist_cfg file. Returns unknown if value is not available''' stringToMatch = '&namzgr ' default = \"\" #get list of namelists allCFG = getNameLists () #remove empty spaces allCFG = allCFG . replace ( \" \" , \"\" ) result = \"\" print ( \" \\n --> Vertical grid type. Accept with [ENTER]: \\n\\n \" ) f = open ( allCFG , \"r\" ) for line in f : if line . startswith ( stringToMatch ): # print(\"line is \", line) # comma on the end prevents the double spacing from printing a file line for line in f : # #namzgrLst.append(line) if ( \".true.\" in line ): #print(\"Filtered \", line) #add to list to extract #lnLst.append(line) for ext in line : if ( \"zco\" in line ): default = \"zco (z-coordinate with full steps)\" #print(BOLD + \"Vertical Grid Type: \" + NORMAL + \"\" + default) break elif ( \"zps\" in line ): default = \"zps (z-coordinate with partial steps)\" #print(BOLD + \"Vertical Grid Type: \" + NORMAL + \"\" + default) break elif ( \"sco\" in line ): default = \"sco (s- or hybrid z-s-coordinate)\" #print(BOLD + \"Vertical Grid Type: \" + NORMAL + \"\" + default) break #not clear - refer to bash script elif ( \"isfcav\" in line ): default = \"ice shelf cavity\" #print(BOLD + \"Vertical Grid Type: \" + NORMAL + \"\" + default) break if line . startswith ( \"/\" ): break # stop this inner for loop; outer loop picks up on the next line if default == \"\" : print ( PURPLE + \"Unknown\" + NORMAL ) return \"Unknown\" else : print ( PURPLE + default + NORMAL ) return default get_zGITNMSPC () \ud83d\udd17 This function returns the value of a variable zGITNMSPC Source code in mk_readme/clsmkReadme.py def get_zGITNMSPC (): '''This function returns the value of a variable zGITNMSPC''' zGITSERVER = get_zGITSERVER () if zGITSERVER == \"gitlab.de\" : zGITNMSPC = \"DRAKKAshare\" elif zGITSERVER == \"git.geomar.de\" : zGITNMSPC = \"NEMO/EXP\" return zGITNMSPC get_zGITSERVER () \ud83d\udd17 This function returns the value of a variable zGITSERVER Source code in mk_readme/clsmkReadme.py def get_zGITSERVER (): '''This function returns the value of a variable zGITSERVER''' if ( LNGIT == True ): zGITSERVER = \"git.geomar.de\" else : zGITSERVER = \"gitlab.de\" return zGITSERVER get_zPAGESRV () \ud83d\udd17 This function returns the value of a variable zPAGESRV Source code in mk_readme/clsmkReadme.py def get_zPAGESRV (): '''This function returns the value of a variable zPAGESRV''' zGITSERVER = get_zGITSERVER () if zGITSERVER == \"gitlab.de\" : zPAGESRV = \"https://drakkarshare.gitlab.io\" zPAGE = zPAGESRV + \"/\" + _CONFNAME_ elif zGITSERVER == \"git.geomar.de\" : zPAGESRV = \"#\" zPAGE = \"| [Static Page](\" + zPAGESRV + \"/\" + _CONFNAME_ + \")\" return zPAGE getAllConfigFolders () \ud83d\udd17 This function will return a list of configurations, and eventually user will choose which configuration s/he would like to work with: (e.g. AMM12, ORCA2_LIM_CFC_C14b, GYRE, ORCA025.L46.LIM2vp.CORE.XIOS1, ORCA2_LIM etc.. Display only the configurations that include EXP00 folder Source code in mk_readme/clsmkReadme.py def getAllConfigFolders (): '''This function will return a list of configurations, and eventually user will choose which configuration s/he would like to work with: (e.g. AMM12, ORCA2_LIM_CFC_C14b, GYRE, ORCA025.L46.LIM2vp.CORE.XIOS1, ORCA2_LIM etc.. Display only the configurations that include EXP00 folder''' configFolders = [] listWithAllDir = [] listOnlyExp00 = [] configPath = getNemoConfig () #print(\"Config path\" , configPath) for r , d , f in os . walk ( configPath ): for directory in d : if \"EXP00\" in d : #release3 listWithAllDir . append ( os . path . join ( r , directory )) elif \"EXPREF\" in d : #release 4 listWithAllDir . append ( os . path . join ( r , directory )) for i in listWithAllDir : if \"EXP00\" in i : #remove the EXP00 listOnlyExp00 . append ( i ) elif \"EXPREF\" in i : #remove the EXPREF listOnlyExp00 . append ( i ) for c in listOnlyExp00 : last = c . split ( '/' ) configFolders . append ( last [ - 2 ]) #sort configFolders configFolders . sort () return configFolders getNameLists () \ud83d\udd17 This function searches for namelist_cfg file and extracts the namelist path for the chosen configuration Source code in mk_readme/clsmkReadme.py def getNameLists (): ''' This function searches for namelist_cfg file and extracts the namelist path for the chosen configuration''' #to retrieve only the cfg of the chosen configuration cfgNameLists = [] findExactNameList = [] output = \"\" path2 = getNemoConfig () for ( dirname , dirs , files ) in os . walk ( path2 ): #for (dirname, dirs, files) in os.walk('.'): for filename in files : if filename . startswith ( '1_namelist_cfg' ): pass #ignore elif 'namelist_cfg' in filename : thefile = os . path . join ( dirname , filename ) if exp in thefile : cfgNameLists . append ( thefile ) #go through the list to check for entries containing part of the chosen name if ( len ( cfgNameLists ) == 1 ): #print(cfgNameLists) output = cfgNameLists else : #add each item to the list for i in range ( len ( cfgNameLists )): findExactNameList . append ( cfgNameLists [ i ]) #Search through each item for the exact configuration name for item in findExactNameList : #for i in item: pathSplit = item . split ( '/' ) #Get the third element from the last if exp == pathSplit [ - 3 ]: #print(item) output = item #return full path #convert list to str return '' . join ([ str ( elem ) for elem in output ]) getNemoConfig () \ud83d\udd17 This function will look for the directory 'NEMOGCM/CONFIG' for release 3 and 'cfgs' for release 4 anywhere in the system Source code in mk_readme/clsmkReadme.py def getNemoConfig (): '''This function will look for the directory 'NEMOGCM/CONFIG' for release 3 and 'cfgs' for release 4 anywhere in the system''' global release3 , release4 rootPath = pathlib . Path () . absolute () fname = [] configPath = \"\" for root , d_names , f_names in os . walk ( rootPath ): for f in d_names : fname . append ( os . path . join ( root , f )) for i in fname : if \"NEMOGCM/CONFIG\" in i : configPath = i release3 = True #if this is True, the script is being run as a release 3 break elif \"cfgs\" in i : configPath = i release4 = True #if this is True, the script is being run as a release 4 break path = configPath #if release is 4 remove the last two folders since the file structure is different in rel3 and rel4 if (( release3 == True ) or ( release4 == True )) and ( scriptLoc != None ): pathSplit = os . path . dirname ( path ) pathUpdated , tail = os . path . split ( pathSplit ) return pathUpdated else : return path hr () \ud83d\udd17 displays a list of * across the page and moves cursor to next line Source code in mk_readme/clsmkReadme.py def hr (): '''displays a list of * across the page and moves cursor to next line''' command = [ 'tput' , 'cols' ] width = int ( subprocess . check_output ( command )) for i in range ( width ): { print ( \"*\" , end = \"\" ) } print ( \" \\n \" ) indent ( text ) \ud83d\udd17 Indents text to the right Source code in mk_readme/clsmkReadme.py def indent ( text ): '''Indents text to the right''' text = textwrap . indent ( text , ' ' * 4 )[ 4 - 1 :] print ( text ) list_inputfiles () \ud83d\udd17 The purpose of this function is to generate the 'Input Files' section in the readme file Source code in mk_readme/clsmkReadme.py def list_inputfiles (): '''The purpose of this function is to generate the 'Input Files' section in the readme file ''' #count 0 is the header count = 1 col1 = \"\" col2 = \"\" col3 = \"\" path2 = os . getcwd () parent = os . path . dirname ( path2 ) #parent directory #for (dirname, dirs, files) in os.walk('.'): for ( dirname , dirs , files ) in os . walk ( parent ): rowsLst . append ([]) rowsLst . append ([]) rowsLst . append ([]) for filename in files : if filename . endswith ( '.def' ) : thefile = os . path . join ( dirname , filename ) #list path with .def extension with open ( thefile ) as f : url = \"\" infile_nemo = \"\" #print all contents of the file for line in f : line = line . strip () #access only the lines that are not commented and empty if not ( line . startswith ( '#' )): if len ( line ) != 0 : allFieldsFirstLine = line . split ( \",\" ) try : infile_nemo = allFieldsFirstLine [ 0 ] #1st element #print(\"infile_nemo: \" + infile_nemo) col1 = infile_nemo if infile_nemo == \"\" or infile_nemo == \" \\\\ \" : infile_nemo = next ( f ) #move to next line else : infile_nemo = allFieldsFirstLine [ 1 ] except : #print(\"Error for infile_nemo\") print ( \"infile Nemo: \" + infile_nemo ) try : url = allFieldsFirstLine [ 2 ] #tableListing.append(url) if not ( url == \" \\\\ \" or url == \"\" or url == \"' \\' \" ): #print(\"this is the original line\") url = allFieldsFirstLine [ 2 ] else : #print(\"this is the next line\") url = next ( f ) #move to next line #print(\"url: \" + url.strip()) col3 = url . strip () + \" \\n \" except : #two exceptions to cater for in file #./ORCA025.L46.LIM2vp.CFCSF6.JRA.XIOS2/EXP00/input.def #print(\"Skip two lines section\") url = next ( f ) url = next ( f ) #print(\"URL : \", url.strip()) col3 = url . strip () + \" \\n \" #add data to table col1 = col1 . strip () col2 = \"---\" col3 = col3 . strip () if 'thredds' in col3 : col3up = col3 pass elif '@' in col3 : getIndex = col3 . find ( '@' ) col3 = col3 [ getIndex + 1 :] #replace : with / col3 = col3 . replace ( ':' , '/' ) #get last part of the string lastPart = col3 . split ( \"/\" )[ - 1 ] lastIndex = col3 . find ( lastPart ) col3 = col3 [: lastIndex - 1 ] col3up = lastPart + \"<b>\" + \" in \" + \"</b>\" + col3 #col3up = lastPart + \"<b>\" + \" in \" + \"</b>\" + \"<a href=\" + \"'\" + col3 + \"'\" + \">\" + col3 + \"</a>\" rowsLst [ count ] . append ( col1 ) rowsLst [ count ] . append ( col2 ) rowsLst [ count ] . append ( col3up ) count = count + 1 #### Create the table ####### rowsLst [ 0 ] . append ( \"**NEMO Input File**\" ) rowsLst [ 0 ] . append ( \"**Reference (DOI)**\" ) rowsLst [ 0 ] . append ( \"**Download**\" ) #this list will not contain empty tuples and will be used in the markdown template rowsLst2 = [ e for e in rowsLst if e ] return make_markdown_table ( rowsLst2 ) main () \ud83d\udd17 This function will be called if the script is stored in the root Source code in mk_readme/clsmkReadme.py def main (): '''This function will be called if the script is stored in the root''' check_inputDef_exists () #check if input.def is part of this directory if check_inputDef_exists () == True : exp = chooseConfigFolder () #print(ask_exp00()) if ask_exp00 ( exp ) == True : template () else : print ( \"Exiting..Please start again\" ) else : print ( \"Input.def file does not exist, create this file to be able to proceed\" ) mainconfig () \ud83d\udd17 This function will be called if the script is initially saved in one of the configuration folders Source code in mk_readme/clsmkReadme.py def mainconfig (): '''This function will be called if the script is initially saved in one of the configuration folders''' check_inputDef_exists () #check if input.def is part of this directory if check_inputDef_exists () == True : if ask_exp00 ( exp ) == True : template () else : print ( \"Exiting..Please start again\" ) else : print ( \"Input.def file does not exist, create this file to be able to proceed\" ) make_markdown_table ( rowsLst2 ) \ud83d\udd17 This function is used to format the tables in the readme file to replicate the markdown format Source code in mk_readme/clsmkReadme.py def make_markdown_table ( rowsLst2 ): '''This function is used to format the tables in the readme file to replicate the markdown format ''' markdown = \" \\n \" + str ( \"| \" ) for e in rowsLst2 [ 0 ]: to_add = \" \" + str ( e ) + str ( \" |\" ) markdown += to_add markdown += \" \\n \" markdown += '|' for i in range ( len ( rowsLst2 [ 0 ])): markdown += str ( \"-------------- | \" ) markdown += \" \\n \" for entry in rowsLst2 [ 1 :]: markdown += str ( \"| \" ) for e in entry : to_add = str ( e ) + str ( \" | \" ) markdown += to_add markdown += \" \\n \" return markdown + \" \\n \" prep_note () \ud83d\udd17 The purpose of this function is to display a list of prerequistes to successfully render a readme file Source code in mk_readme/clsmkReadme.py def prep_note (): '''The purpose of this function is to display a list of prerequistes to successfully render a readme file''' uName = os . uname () . nodename uName = str ( uName ) print ( \" \\n \" ) hr () print ( \" \\n \" ) center ( \"Prepare DRAKKARshare upload\" ) print ( \" \\n \" ) hr () print ( \" \\n\\n Before we begin, we have to make sure, that the following \" + ULINE + \"conditions are fulfilled\" + NORMAL + \" and you have the \" + ULINE + \"essential information\" + NORMAL + \" at hand right now:\" ) print ( \" \\n\\n \" ) indent ( \" [ ] \" \"You have access to \" + BOLD + BLACK + \"at least one gitlab server\" + NORMAL + \", like \" + BLUE + zGITSERVER + \"/\" + zGITNMSPC + NORMAL + \" and your \" + BOLD + BLACK + \"public ssh-key \" + NORMAL + \"from this host (\" + uName + \") has been deposited under your gitlab profile.\" ) print ( \" \\n \" ) indent ( \" [ ] \" \"Configuration-specific \" + BOLD + BLACK + \" input files \" + NORMAL + \" are \" + ULINE + \"publicly accessible\" + NORMAL + \" at least for members of a specific gitlab group) and you have a \" + BOLD + BLACK + \" reference\" + NORMAL + \" (e.g. DOI) and a \" + BOLD + BLACK + \" Download-URL \" + NORMAL + \" for each file.\" ) print ( \" \\n \" ) indent ( \" [ ] \" \"You know the \" + BOLD + BLACK + \"NEMO revision\" + NORMAL + \" and the \" + BOLD + BLACK + \"URL\" + NORMAL + \" you've installed it from (if it can't be determined automatically, because you're not within a svn or git working directory)\" ) print ( \" \\n \" ) indent ( \" [ ] \" \"If your configuration is build upon another \" + BOLD + BLACK + \"reference configuration \" + NORMAL + \" you'll need the exact name and a reference URL (e.g. another DRAKKARshare repository)\" ) print ( \" \\n \" ) indent ( \" [ ] \" \"Is INPUT.def part of this configuration? \" ) print ( \" \\n \" ) answer = input ( BOLD + RED + \"Do you confirm, that you meet the conditions above? [Y|N]:\" + NORMAL ) answer = answer . lower () if ( answer == \"n\" ): exit () else : return answer sucssmsg ( msg ) \ud83d\udd17 Displays an error message in GREEN and reset text colour - Message will be passed as a parameter Source code in mk_readme/clsmkReadme.py def sucssmsg ( msg ): ''' Displays an error message in GREEN and reset text colour - Message will be passed as a parameter''' print ( GREEN + ' \\n SUCCESS: ' + msg + ' \\n\\n ' + NORMAL ) template () \ud83d\udd17 The purpose of this function is to create a markup template with values generated from previous functions Source code in mk_readme/clsmkReadme.py def template (): '''The purpose of this function is to create a markup template with values generated from previous functions''' readme = Template ( \"\"\" # {{_COMPONENTS_}} ___ [Purpose](#purpose) | [Contact](#contact) | [License](#license) | [Configuration](#configuration) | [Input Files](#input-files) | [Diagnostics](#diagnostics) | [Installation](#installation) {{_zPAGE_}} ____ # Purpose {{_PURPOSE_}} # Contact {{_CONTACT_}} # License **By downloading this repository and using this code you agree to the following conditions.** The code in this project is based on the [NEMO](http://www.nemo-ocean.eu) software (Copyright (c) Centre National de la Recherche Scientifique CNRS). The original code as well as the contribution to this code in this project are licensed under the conditions of [CeCILL](http://www.cecill.info). The person stated under '*Contact*' above is the owner of the intellectual property rights of these contributions and **must be informed afore** publishing and **must be cited** in every published work that is based completely or partially on the modifications and additional code provided by this configuration. Usage is at one's own risk. # Configuration {{config_table}} The default experiment settings can be found in the [EXP00](EXP00) folder. The modified code is located in the [MY_SRC](MY_SRC) directory. # Input Files * **NEMO Input File:** File names as they are expected by NEMO * **Reference:** Citation for an article or report, webpage or even better: DOI * **Download:** Link for direct downloading the file (no user-interaction preferred to make it script-compliant) The actual file names should follow the *Guidelines for Naming DRAKKAR Input File Names*: \"\\`NemoName\\` \\\\ _\\`NemoVersion\\` \\\\ _\\`ConfigGrid\\` \\\\ _\\`Version\\`.nc\" {{list_inputfiles}} # Diagnostics See [DIAG](DIAG) for some standard diagnostics from a simulation with this configuraton. # Installation There are plenty of ways how to install a local copy of this configuration: 1. You can [clone it with git](#install-with-git) (regardless of whether your NEMOGCM path is already under git control or not). 2. Or you just download an archive from the web interface. In some cases there are different versions of the same configuration in separate branches (e.g. to reflect different NEMO revisions); **check the branches/tags** menu on the web interface or use the git branch and checkout commands to select the version you're interested in. <!--For further details, please read the [HELP pages](https://gitlab.com/DRAKKARshare/help/edit/master/GetConfiguration.md).--> ## Install with \\`git\\` **{- IMPORTANT: -}** The following guidelines assume, that you're already registered at https://{{_zGITSERVER_}} and your public SSH key has been deposited under your gitlab profile. #### (A) NEMOGCM already under git control If your **NEMOGCM installation is already under git control** you cannot clone a different repository into the existing working copy. Instead, you can use \\`git subtree\\` to inject files from another remote repository into a particular sub-folder of your existing working tree. Within NEMOGCM directory: **Option - With git commands** ~~~bash cd NEMOGCM git remote add -f remote_{{_CONFNAME_}} git@{{_zGITSERVER_}}:{{_zGITNMSPC_}}/{{_CONFNAME_}}.git # add remote git subtree add --prefix CONFIG/{{_CONFNAME_}} remote_{{_CONFNAME_}} {{_NEMOBRANCH_}}:-master --squash # donwload master branch into sub-folder cd CONFIG/{{_CONFNAME_}} remote_{{_CONFNAME_}} cat cfg.txt >> ../cfg.txt ~~~ > In this case, you keep the information from where you have downloaded the reference configuration (see \\`git remote -v\\`). Or even shorter, without keeping remote source information (not recommended): ~~~bash cd NEMOGCM git subtree add --prefix CONFIG/{{_CONFNAME_}} git@{{_zGITSERVER_}}:{{_zGITNMSPC_}}/{{_CONFNAME_}}.git {{_NEMOBRANCH_}}:-master --squash cd CONFIG/{{_CONFNAME_}} remote_{{_CONFNAME_}} cat cfg.txt >> ../cfg.txt ~~~ #### (B) NEMOGCM not under git control If your NEMOGCM installation **is not under git control already**, you can clone this configuration using the URL specified on the project's front page: ~~~bash cd NEMOGCM/CONFIG git clone git@{{_zGITSERVER_}}:{{_zGITNMSPC_}}/{{_CONFNAME_}}.git cat {{_CONFNAME_}}/cfg.txt >> cfg.txt ~~~ This wil create a new configuration folder, which can be used as a reference case for \\`makenemo -r\\`. Make sure, you add this confiuration to the local registry file \\`cfg.txt\\` before invoking \\`makenemo\\`. #### Other revisions The revision that will be installed, is the most recent one from the **master** branch. If you're seeking another branch/revision of this configuration (e.g. an older one), you can browse available branches/tags via the web-interface or list alternative branches on the command line and swap available branches/tags easily with \\`checkout\\`: ~~~bash cd {{_CONFNAME_}} git branches -r git checkout otherBranch ~~~ Note: *origin/HEAD* in the output listing is not a branch in its own but points to the default branch (master branch in most cases). \"\"\" ) fillenv () pathS = pathlib . Path () . absolute () if ( LNGIT == True ) and ( CURRCONFIG == False ): READMEOUT = str ( pathS ) + \"/CONFIG/\" + exp + \"/README_\" + exp + \".md\" elif ( LNSVN == True ) and ( CURRCONFIG == False ) and ( release3 == True ): READMEOUT = str ( pathS ) + \"/NEMOGCM/CONFIG/\" + exp + \"/README_\" + exp + \".md\" elif ( LNSVN == True ) and ( CURRCONFIG == False ) and ( release4 == True ): READMEOUT = str ( pathS ) + \"/cfgs/\" + exp + \"/README_\" + exp + \".md\" #if current script is stored in one of the configurations elif ( CURRCONFIG == True ): READMEOUT = str ( pathS ) + \"/README_\" + exp + \".md\" with open ( READMEOUT , \"w\" ) as f : f . write ( readme . render ( _CONFNAME_ = _CONFNAME_ , _CONTACT_ = _CONTACT_ , _PURPOSE_ = _PURPOSE_ , _CURREPO_ = _CURREPO_ , _NEMOREPO_ = _NEMOREPO_ , _NEMOREVISION_ = _NEMOREVISION_ , _NEMOBRANCH_ = _NEMOBRANCH_ , _COMPONENTS_ = _COMPONENTS_ , _REFCONFIG_ = _REFCONFIG_ , _CPPKEYS_ = _CPPKEYS_ , _RESOLUTION_ = _RESOLUTION_ , _GRID_ = _GRID_ , _HGRIDPT_ = _HGRIDPT_ , _VGRIDPTZ_ = _VGRIDPTZ_ , _ATMOS_ = _ATMOS_ , _OCEANRDT_ = _OCEANRDT_ , _NESTNUMBER_ = _NESTNUMBER_ , _PASSIVTRACERS_ = _PASSIVTRACERS_ , list_inputfiles = list_inputfiles (), config_table = config_table (), _zGITSERVER_ = _zGITSERVER_ , _zGITNMSPC_ = _zGITNMSPC_ , _zPAGE_ = _zPAGE_ )) print ( \"README file created\" ) trim ( text ) \ud83d\udd17 If any white spaces are present at the end of a line, the purpose of this function is to remove them Source code in mk_readme/clsmkReadme.py def trim ( text ): '''If any white spaces are present at the end of a line, the purpose of this function is to remove them''' text = text . strip () return text warnmsg ( msg ) \ud83d\udd17 Displays an error message in YELLOW and reset text colour - Message will be passed as a parameter Source code in mk_readme/clsmkReadme.py def warnmsg ( msg ): ''' Displays an error message in YELLOW and reset text colour - Message will be passed as a parameter''' print ( YELLOW + ' \\n WARNING: ' + msg + ' \\n\\n ' + NORMAL ) : : : my_package.my_module.MyClass handler: python selection: members: - method_a - method_b rendering: show_root_heading: false show_source: false : : : my_package.my_module.MyClass handler: python rendering: show_root_heading: false show_source: false : : : MY_PACKAGE.your_module handler: python rendering: show_root_heading: false show_source: false","title":"`mkReadme`"},{"location":"api-mkreadme.html#mkreadme","text":"","title":"mkReadme"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme","text":"Created on Fri Jan 10 10:31:20 2020 @author: luciennemicallef","title":"mk_readme.clsmkReadme.MakeReadme"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.color","text":"This class stores a list of colours and font styles","title":"color"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.ask_exp00","text":"exp is the configuration name Source code in mk_readme/clsmkReadme.py def ask_exp00 ( exp ): '''exp is the configuration name''' '''The purpose of this function is to show all directories for the chosen configuration ''' print ( \" \\n Chosen configuration is : \" , exp ) #list to store all the directories inside this configuration listWithAllDir = [] configPath = getNemoConfig () + \"/\" + exp #print(\"Config path\" , configPath) print ( \" \\n Directories for : \" , exp ) for r , d , f in os . walk ( configPath ): for directory in d : listWithAllDir . append ( directory ) #sort list listWithAllDir . sort () for i in listWithAllDir : print ( i ) choice = input ( \" \\n --> Are you sure that this is the configuration you would like to work with? Proceed with [Y] or [N] \\n\\n \" ) choice = choice . lower () if choice == 'y' : return True else : return False","title":"ask_exp00()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.center","text":"Centers the text to the midddle of the screen Source code in mk_readme/clsmkReadme.py def center ( text ): '''Centers the text to the midddle of the screen''' command = [ 'tput' , 'cols' ] width = int ( subprocess . check_output ( command )) print ( text . center ( width ), \" \\n \" )","title":"center()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.check_confdir","text":"The purpose of this function is to check if the script is in a configuration sub-folder in NEMOGCM/CONFIG Source code in mk_readme/clsmkReadme.py def check_confdir (): '''The purpose of this function is to check if the script is in a configuration sub-folder in NEMOGCM/CONFIG ''' pathLst = [] currentDirectory = os . getcwd () words = currentDirectory . split ( \"/\" , 4 ) for w in words : pathLst . append ( w ) lastElement = str ( pathLst [ len ( pathLst ) - 1 ]) #should be CONFIG print ( \"last Element \" , lastElement ) if ( lastElement != \"CONFIG\" ): errmsg ( \"It seems, we are not in a configuration sub-folder of NEMOGCM/CONFIG. I'm lost. \" + BOLD + \"Please run this script within a configuration folder!\" + NORMAL )","title":"check_confdir()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.check_EXPref","text":"This function will check whether the current location contains, EXP00 and EXPREF folder Source code in mk_readme/clsmkReadme.py def check_EXPref (): '''This function will check whether the current location contains, EXP00 and EXPREF folder''' path = os . getcwd () expRef = False for root , directories , files in os . walk ( path ): for folder in directories : #release 3 if \"EXP00\" in folder : expRef = True break #release 4 elif \"EXPREF\" in folder : expRef = True break return expRef","title":"check_EXPref()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.check_gitorsvn","text":"The purpose of this function is to check whether the current script is stored as a git repo or as an svn repo Source code in mk_readme/clsmkReadme.py def check_gitorsvn (): '''The purpose of this function is to check whether the current script is stored as a git repo or as an svn repo''' '''if LNGIT is True - the script is stored as a git repo''' '''if LNSVN is True - the script is stored as an svn svn repo''' global repo try : repo = git . Repo ( \".\" , search_parent_directories = True ) except git . InvalidGitRepositoryError : print ( BLUE + \"This is not a git repo \\n \" + NORMAL ) else : print ( BLUE + \"This is a Git Repo\" + NORMAL ) global LNGIT LNGIT = True if ( LNGIT == False ): try : repo = subprocess . check_output ( \"svn info | awk '/^Kind:/ {print $2}'\" , shell = True ) . strip () except svn . exception . SvnException : print ( BLUE + \"This is not an svn repo \\n \" + NORMAL ) except OSError as e : print ( \"Error - \" , e ) else : print ( BLUE + \"This is an SVN Repo\" + NORMAL ) global LNSVN LNSVN = True","title":"check_gitorsvn()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.check_inputDef_exists","text":"This function checks whether input.def file exists in the directory of the chosen configuration. If not the script will exit. Source code in mk_readme/clsmkReadme.py def check_inputDef_exists (): '''This function checks whether input.def file exists in the directory of the chosen configuration. If not the script will exit.''' if ( CURRCONFIG == True ): parent = os . path . dirname ( os . getcwd ()) else : parent = os . getcwd () #print(\"Parent \", parent) found = False files = [] #r=root, d=directories, f = files for r , d , f in os . walk ( parent ): for file in f : if 'input.def' in file : found = True files . append ( os . path . join ( r , file )) if found == True : return True else : return False","title":"check_inputDef_exists()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.check_prereq","text":"This function will check that EXP00 or EXPREF directory is present in the current file structure Source code in mk_readme/clsmkReadme.py def check_prereq (): '''This function will check that EXP00 or EXPREF directory is present in the current file structure ''' if ( EXPref != \"EXP00\" ) and ( EXPref != \"EXPREF\" ): errmsg ( \"No EXP00/EXPREF folder with default settings was found. Please create one and re-run this script.\" ) else : cwflag = 0 #check_confdir() git_X = git . __version__ if len ( git_X ) > 0 : sucssmsg ( \"GIT found\" ) else : errmsg ( \"GIT not found\" ) svn_X = svn . __version__ if len ( svn_X ) > 0 : sucssmsg ( \"SVN found\" ) else : errmsg ( \"SVN not found\" ) ssh_X = os . system ( 'ssh -V' ) if len ( str ( ssh_X )) > 0 : sucssmsg ( \"SSH found\" ) else : errmsg ( \"SSH not found\" ) curl_X = pycurl . version if len ( curl_X ) > 0 : sucssmsg ( \"CURL found\" ) else : errmsg ( \"CURL not found\" ) cwflag = cwflag + 1 wget_X = wget . __version__ if len ( wget_X ) > 0 : sucssmsg ( \"WGET found\" ) else : errmsg ( \"WGET not found\" ) cwflag = cwflag + 1 if ( cwflag > 0 ): errmsg ( \"Neither CURL nor WGET was found. Abort\" ) m4_X = os . system ( 'm4 --version' ) if len ( str ( m4_X )) > 0 : sucssmsg ( \"m4 found\" ) else : errmsg ( \"m4 not found\" ) global zGITSERVER zGITSERVER = get_zGITSERVER () global zGITNMSPC zGITNMSPC = get_zGITNMSPC () print ( \"zGITSERVER: \" , zGITSERVER ) print ( \"zGITNMSPC: \" , zGITNMSPC )","title":"check_prereq()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.checkScriptLocation","text":"The purpose of this function is to check whether the script is being run from a particular configuration Source code in mk_readme/clsmkReadme.py def checkScriptLocation (): '''The purpose of this function is to check whether the script is being run from a particular configuration''' path2 = os . getcwd () configName = os . path . basename ( path2 ) #print(\"This script is saved in \", configName) for x in getAllConfigFolders (): if x == configName : global CURRCONFIG CURRCONFIG = True return x","title":"checkScriptLocation()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.chooseConfigFolder","text":"This function will ask the user to select one configuration from the list generated from getAllConfigFolders. The chosen config is stored in a global variable called exp which will be used throughout the script Source code in mk_readme/clsmkReadme.py def chooseConfigFolder (): '''This function will ask the user to select one configuration from the list generated from getAllConfigFolders. The chosen config is stored in a global variable called exp which will be used throughout the script''' valid = False global exp configList = [] print ( \" \\n\\n Config List: \\n \" ) for i in getAllConfigFolders (): configList . append ( i ) print ( i ) while valid == False : exp = input ( \" \\n Choose one of the above configurations : \\n\\n \" ) if exp in configList : valid = True return exp else : print ( \"Invalid entry, input has to match exactly (including capital letters)\" )","title":"chooseConfigFolder()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.config_table","text":"The purpose of this function is to generate the 'Configuration' section in the readme file Source code in mk_readme/clsmkReadme.py def config_table (): '''The purpose of this function is to generate the 'Configuration' section in the readme file ''' configLst = [ [ \"Characteristic\" , \"Specs\" ],[ \"**NEMOGCM repository**\" , _CURREPO_ ], [ \"**Git Branch**\" , _NEMOBRANCH_ ],[ \"**Nemo-ocean repository**\" , _NEMOREPO_ ], [ \"**Nemo-ocean revision**\" , _NEMOREVISION_ ],[ \"**Components**\" , _COMPONENTS_ ], [ \"**Reference Configuration**\" , _REFCONFIG_ ], [ \"**CPP keys**\" , _CPPKEYS_ ], [ \"**Grid**\" , _GRID_ ], [ \"**Resolution**\" , _RESOLUTION_ ], [ \"**Horizontal Gridpoints**\" , _HGRIDPT_ ],[ \"**Vertical Levels**\" , _VGRIDPTZ_ ], [ \"**Atmospheric Condition**\" , _ATMOS_ ],[ \"**Time Step [s]**\" , _OCEANRDT_ ], [ \"**Passive Tracers**\" , _PASSIVTRACERS_ ],[ \"**Number of Nests**\" , _NESTNUMBER_ ], ] markdown = \" \\n \" + str ( \"| \" ) for e in configLst [ 0 ]: to_add = \" \" + str ( e ) + str ( \" |\" ) markdown += to_add markdown += \" \\n \" markdown += '|' for i in range ( len ( configLst [ 0 ])): markdown += str ( \"-------------- | \" ) markdown += \" \\n \" for entry in configLst [ 1 :]: markdown += str ( \"| \" ) for e in entry : to_add = str ( e ) + str ( \" | \" ) markdown += to_add markdown += \" \\n \" return markdown + \" \\n \"","title":"config_table()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.errmsg","text":"Displays an error message in RED and reset text colour - Message will be passed as a parameter Source code in mk_readme/clsmkReadme.py def errmsg ( msg ): ''' Displays an error message in RED and reset text colour - Message will be passed as a parameter''' print ( RED + ' \\n ERROR: ' + msg + ' \\n\\n ' + NORMAL )","title":"errmsg()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.fillenv","text":"This function returns variables which will be used to create the readme file Source code in mk_readme/clsmkReadme.py def fillenv (): '''This function returns variables which will be used to create the readme file''' global _CONFNAME_ _CONFNAME_ = get_confname () global _CONTACT_ _CONTACT_ = get_username () + \" - \" + get_useremail () global _PURPOSE_ _PURPOSE_ = get_purpose () global _CURREPO_ _CURREPO_ = get_currepo () global _NEMOREPO_ _NEMOREPO_ = get_nemorepo () global _NEMOREVISION_ _NEMOREVISION_ = get_nemorevision () global _NEMOBRANCH_ _NEMOBRANCH_ = get_branch () global _COMPONENTS_ _COMPONENTS_ = get_components () global _REFCONFIG_ _REFCONFIG_ = get_refconfig () global _CPPKEYS_ _CPPKEYS_ = get_cppkeys () global _RESOLUTION_ _RESOLUTION_ = get_resolution () global _GRID_ _GRID_ = get_hgridtype () + \", \" + get_vgridtype () global _HGRIDPT_ _HGRIDPT_ = get_hgridpt () global _VGRIDPTZ_ _VGRIDPTZ_ = get_vgridpt () global _ATMOS_ _ATMOS_ = get_atmos () global _OCEANRDT_ _OCEANRDT_ = get_oceanrdt () global _NESTNUMBER_ _NESTNUMBER_ = get_nestnumber () global _PASSIVTRACERS_ _PASSIVTRACERS_ = get_passivetracers () global _zGITSERVER_ _zGITSERVER_ = get_zGITSERVER () global _zGITNMSPC_ _zGITNMSPC_ = get_zGITNMSPC () global _zPAGE_ _zPAGE_ = get_zPAGESRV ()","title":"fillenv()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.get_atmos","text":"This function will return the number of surface boundary condition from namelist_cfg file. Returns unknown if value is not available Source code in mk_readme/clsmkReadme.py def get_atmos (): '''This function will return the number of surface boundary condition from namelist_cfg file. Returns unknown if value is not available''' stringToMatch = '&namsbc ' matchedLine = '' namsbcLst = [] #stores all elements in &namsbc lnLst = [] #stores all ln_ elements nnLst = [] #stores all nn_ elements vaxLst = [] #stores the prefix e.g. blk_core, ana etc.. v = \"\" #returns the line with .true. vax = \"\" default = \"\" #get list of namelists allCFG = getNameLists () #remove empty spaces allCFG = allCFG . replace ( \" \" , \"\" ) print ( \" \\n --> Defining the surface boundary condition. Accept with [ENTER]: \\n\\n \" ) f = open ( allCFG , \"r\" ) for line in f : if stringToMatch in line : matchedLine = line for line in f : if not ( line . startswith ( \"/\" )): namsbcLst . append ( line ) else : break #check for ln_ for item in namsbcLst : if item . find ( \"ln_\" ) != - 1 : lnLst . append ( item ) for i in lnLst : if \"true\" in i : v = i #get last part after the ln_ _index = v . find ( \"_\" ) eqIndex = v . find ( \"=\" ) vax = v [ _index + 1 : eqIndex ] #retrieve the value after _ vax = vax . strip () #remove white spaces vaxLst . append ( vax ) for v in vaxLst : if ( v == \"ana\" ): default = \"Analytical forcing\" #output = BOLD + \"Surface Boundary Condition: \" + NORMAL + \"\" + default #print(output) elif ( v == \"flx\" ): default = \"Flux formulation\" #output = BOLD + \"Surface Boundary Condition: \" + NORMAL + \"\" + default #print(output) elif ( v == \"blk_clio\" ): default = \"CLIO bulk formulation\" #output = BOLD + \"Surface Boundary Condition: \" + NORMAL + \"\" + default #print(output) elif ( v == \"blk_core\" ): default = \"CORE bulk formulation\" #output = BOLD + \"Surface Boundary Condition: \" + NORMAL + \"\" + default #print(output) elif ( v == \"blk_mfs\" ): default = \"MFS bulk formulation\" #output = BOLD + \"Surface Boundary Condition: \" + NORMAL + \"\" + default #print(output) elif ( v == \"cpl\" ): default = \"Coupled to atmosphere\" #output = BOLD + \"Surface Boundary Condition: \" + NORMAL + \"\" + default #print(output) elif ( v == \"mixcpl\" ): default = \"Forced & coupled atmosphere\" #output = BOLD + \"Surface Boundary Condition: \" + NORMAL + \"\" + default #print(output) elif ( v == \"rnf\" ): default = default + \" + separate runoff\" # check for nn_ for itemN in namsbcLst : if itemN . find ( \"nn_fwb\" ) != - 1 : #get the digits between = and . eqIndex = itemN . find ( \"=\" ) dotIndex = itemN . find ( \"!\" ) output = itemN [ eqIndex + 1 : dotIndex ] #retrieve the value after _ output = output . strip () #remove white spaces if default == \"\" : print ( PURPLE + \"Unknown\" + NORMAL ) return \"Unknown\" else : print ( PURPLE + default + \" + Freshwater Budget Correction (Mode \" + output + \")\" + NORMAL ) return str ( default + \" + Freshwater Budget Correction (Mode \" + output + \")\" )","title":"get_atmos()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.get_branch","text":"This function will return the branch number for this repo Source code in mk_readme/clsmkReadme.py def get_branch (): '''This function will return the branch number for this repo''' print ( \" \\n \" ) print ( \"--> Which branch are you using? Try to get it from git/svn. Accept with [ENTER]: \" ) if ( LNGIT == True ): repo = git . Repo ( \".\" , search_parent_directories = True ) default = repo . active_branch print ( PURPLE + str ( default ) + NORMAL ) return default #else: #print (\"LNGIT is false\") if ( LNSVN == True ): getBranchInfo = subprocess . check_output ( \"svn info | awk '/^URL:/ {print $2}'\" , shell = True ) . strip () getBranch = str ( getBranchInfo ) branchSplit = getBranch . split ( '/' ) #Get the last part of the string getBranch = branchSplit [ - 1 ] getBranch = getBranch . replace ( \"'\" , \"\" ) print ( PURPLE + str ( getBranch ) + NORMAL ) return getBranch","title":"get_branch()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.get_components","text":"This function returns the NEMO components for this repo from cfg.txt or ref_cfg.txt Source code in mk_readme/clsmkReadme.py def get_components (): '''This function returns the NEMO components for this repo from cfg.txt or ref_cfg.txt''' cfgPath = \"\" componentsLst = [] findExactComponent = [] componentsLst . append ( ' \\n ' ) print ( \" \\n --> What NEMO components are we using? Try to get a comma-separated list from ../cfg.txt. Accept with [ENTER]: \\n \" ) #get file path for /cfg.txt currentDirectory = getNemoConfig () confName = os . path . basename ( currentDirectory ) if release3 == True : cfgPath = open ( getNemoConfig () + \"/cfg.txt\" , \"r\" ) elif release4 == True : cfgPath = open ( getNemoConfig () + \"/ref_cfgs.txt\" , \"r\" ) for i in cfgPath : if exp in i : componentsLst . append ( i ) #go through the list to check for multiplies if ( len ( componentsLst ) == 1 ): #print(cfgNameLists) output = componentsLst else : #add each item to the list for i in range ( len ( componentsLst )): findExactComponent . append ( componentsLst [ i ]) #Search through each item for the exact configuration name for item in findExactComponent : #for i in item: pathSplit = item . split ( ' ' ) #Get the first element from the last output = str ( pathSplit [ 0 ]) print ( PURPLE + '' . join ([ str ( elem ) for elem in output ]) + NORMAL ) return '' . join ([ str ( elem ) for elem in output ])","title":"get_components()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.get_confname","text":"Returns the configuration name which is the variable stored as 'exp' Source code in mk_readme/clsmkReadme.py def get_confname (): '''Returns the configuration name which is the variable stored as 'exp' ''' print ( \" \\n --> What is the name you want to use for publishing this configuration with DRAKKARshare? Our first guess is, that it's the configuration name in the current path. Accept with [ENTER] or modify accordingly: \\n\\n \" ) currentDirectory = os . getcwd () confName = os . path . basename ( currentDirectory ) pathSplit = currentDirectory . split ( '/' ) print ( PURPLE + \"Configuration's name: \" + exp + \"\" + NORMAL ) #returns the chosen configuration by the use return exp","title":"get_confname()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.get_cppkeys","text":"This function searches for .fcm file and extracts the cpp keys Source code in mk_readme/clsmkReadme.py def get_cppkeys (): '''This function searches for .fcm file and extracts the cpp keys''' lastElement = \"\" cppList = [] cppList2 = [] findExactCPP = [] output = \"\" matchPath = \"\" multiples = False path = getNemoConfig () found = False for ( dirname , dirs , files ) in os . walk ( path ): # for (dirname, dirs, files) in os.walk('.'): for filename in files : if exp in filename : if filename . endswith ( '.fcm' ) : #ADD filename to list cppList . append ( filename ) if len ( cppList ) == 1 : thefile = os . path . join ( dirname , filename ) #open file and read contents f = open ( thefile , \"r\" ) cppkeysContents = f . read () f . close () else : #multiples is used when the config file appears more than once, e.g. ORCA2_LIM multiples = True #add each item to the list if ( multiples == True ): for i in range ( len ( cppList )): findExactCPP . append ( cppList [ i ]) #Search through each item for the exact CPP key for item in findExactCPP : #item e.g. cpp_GYRE_PISCES.fcm, split by first _ and . underscoreIndex = item . find ( \"_\" ) dotIndex = item . find ( \".\" ) res = item [ underscoreIndex + 1 : dotIndex ] if res == exp : found = True break if ( found == True ): matchPath = os . path . join ( path , res , item ) #print(matchPath) x = open ( matchPath , \"r\" ) cppkeysContents = x . read () x . close () #remove bld::tool::fppkeys by replacing this text empty text #sample: bld::tool::fppkeys key_diaeiv key_dynldf_c2d content = cppkeysContents . replace ( ' \\n ' , ' ' ) content = content . replace ( 'bld::tool::fppkeys ' , '' ) return '' . join ( str ( content ))","title":"get_cppkeys()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.get_currepo","text":"The purpose of this function is to display the actual repo from were NEMO was cloned Source code in mk_readme/clsmkReadme.py def get_currepo (): '''The purpose of this function is to display the actual repo from were NEMO was cloned''' print ( \" \\n --> Are we in a git/svn working tree? And from which remote repository was NEMOGCM cloned? Try to get it from git/svn. Accept with [ENTER]: \\n \" ) if ( LNGIT == True ): try : repo = git . Repo ( \".\" , search_parent_directories = True ) remoteLocation = repo . remote ( \"origin\" ) . url default = remoteLocation if ( default != \"\" ) & ( LNGIT == True ): print ( PURPLE + \"This is a GIT Repo \" + NORMAL ) print ( PURPLE + \"Actual Repository = \" + default + \"\" + NORMAL ) return default except git . InvalidGitRepositoryError : print ( PURPLE + \"Not connected to GIT\" + NORMAL ) else : pass if ( LNSVN == True ): try : default = subprocess . check_output ( \"svn info | awk '/^URL:/ {print $2}'\" , shell = True ) . strip () #convert to string default = str ( default ) default = default . replace ( \"'\" , \"\" ) if ( default != \"\" ) & ( LNSVN == True ): print ( PURPLE + \"This is an SVN Repo \" + NORMAL ) print ( PURPLE + \"Actual Repository = \" + str ( default [ 1 :]) + NORMAL ) return default [ 1 :] else : print ( PURPLE + \"Not connected to SVN\" + NORMAL ) except svn . exception . SvnException : print ( \"This is not a working copy of SVN - Not connected to SVN\" ) else : pass","title":"get_currepo()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.get_hgridpt","text":"This function will return the value corresponding to the hortizonatal grid type from namelist_cfg file. Returns unknown if value is not available Source code in mk_readme/clsmkReadme.py def get_hgridpt (): '''This function will return the value corresponding to the hortizonatal grid type from namelist_cfg file. Returns unknown if value is not available''' stringToMatch = 'namcfg' defaultx = \"\" defaulty = \"\" output = 0 #get list of namelists allCFG = getNameLists () #remove empty spaces allCFG = allCFG . replace ( \" \" , \"\" ) # print ( \" \\n --> Number of grid points in the horizontal. Accept with [ENTER]: \\n\\n \" ) f = open ( allCFG , \"r\" ) #print(\"\\n File name: \", line) for line in f : #find the section namcfg if stringToMatch in line : #print(line) for line in f : if \"jpidta\" in line : defaultx = line #continue printing until line matches \"/\" if \"jpjdta\" in line : #if endStringToMatch2 in line: defaulty = line break #extract digits only from defaultX outputX = 0 repl_str = re . compile ( '^\\d+$' ) line = defaultx . split () for word in line : match = re . search ( repl_str , word ) if match : outputX = float ( match . group ()) #extract digits only from defaultY outputY = 0 #repl_str = re.compile('\\d+.?\\d*') repl_str = re . compile ( '^\\d+$' ) #t = r'\\d+.?\\d*' line = defaulty . split () for word in line : match = re . search ( repl_str , word ) if match : outputY = float ( match . group ()) #multiply two points #output = outputX * outputY output = str ( outputX ) + \" x \" + str ( outputY ) #print(BOLD + \"Horizontal Grid Points (I x J):\" +NORMAL+ \" \"+ str(output)) if str ( output ) == \"\" : print ( PURPLE + \"Unknown\" + NORMAL ) return \"Unknown\" else : print ( PURPLE + str ( output ) + NORMAL ) return str ( output )","title":"get_hgridpt()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.get_hgridtype","text":"This function will return the value corresponding to the horizontal grid type from namelist_cfg file. Returns unknown if value is not available Source code in mk_readme/clsmkReadme.py def get_hgridtype (): '''This function will return the value corresponding to the horizontal grid type from namelist_cfg file. Returns unknown if value is not available''' stringToMatch = 'namcfg' matchedLine = '' endStringToMatch = \"/\" endStringToMatch2 = \"cp_cfg\" output = \"\" #get list of namelists allCFG = getNameLists () #remove empty spaces allCFG = allCFG . replace ( \" \" , \"\" ) result = \"\" #default = \"\" print ( \" \\n --> Horizontal grid type, e.g. ORCA for a global tri-polar grid. Accept our guess with [ENTER]: \\n\\n \" ) #go through the list of files with namelist_cfg # for line in allCFG: #for each file read.. f = open ( allCFG , \"r\" ) #print(\"File Name \", line) for line in f : if stringToMatch in line : matchedLine = line #print(\"Matched Line \", matchedLine) for line in f : output = line result = result + line #print(\"Output \", line) #outputS = BOLD + \"Horizontal Grid Type: \"+NORMAL+output #print(outputS) #hGridType.append(outputS) #continue printing until line matches \"/\" #if (line.startswith(\"/\")): if endStringToMatch2 in line : break x = result . split ( \"!\" ) #remove the dashed line newX = \"\" for i in x [ 1 ]: newX = newX + i . replace ( '-' , '' ) #return only the value in the \"\" and do not print cp_cfg _index = newX . find ( \"=\" ) default = newX [ _index + 1 :] #retrieve the value after = default = default . strip () #remove white space print ( PURPLE + default . strip () + NORMAL ) return default . strip ()","title":"get_hgridtype()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.get_nemoGit","text":"This function will search for the git file Source code in mk_readme/clsmkReadme.py def get_nemoGit (): '''This function will search for the git file ''' global nemoGitRepo pathSplit = \"\" #find Nemo/.git proc = subprocess . check_output ([ \"locate\" , \"-r\" , \"\\.git$\" ]) proc = str ( proc ) pathSplit = proc . split ( \" \\\\ n\" ) for p in pathSplit : if \"/NEMOGCM/.git\" in p : nemoGitRepo = p return nemoGitRepo","title":"get_nemoGit()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.get_nemorepo","text":"This function displays the URL of the repository the NEMO was installed from Source code in mk_readme/clsmkReadme.py def get_nemorepo (): '''This function displays the URL of the repository the NEMO was installed from ''' print ( \" \\n\\n\\n --> What is the URL of the repository you installed NEMO from? Try to get it from git/svn. Accept with [ENTER]:\" ) if ( LNGIT == True ): getIndexHash = \"\" #command = '--grep=\"jussieu\" --pretty=oneline --abbrev-commit --reverse | cut -d ' ' -f 3 |head -n 1' proc = subprocess . check_output ([ \"git\" , \"log\" , \"--pretty=oneline\" , \"--abbrev-commit\" , \"--reverse\" ]) proc = str ( proc ) getSvnIDText = proc . find ( 'http' ) getIndexHash = proc . find ( '@' ) getUrl = proc [ getSvnIDText : getIndexHash ] print ( PURPLE + \"\" + getUrl + \"\" + NORMAL ) return ( getUrl ) if ( LNSVN == True ): #command = '--grep=\"jussieu\" --pretty=oneline --abbrev-commit --reverse | cut -d ' ' -f 3 |head -n 1' getURLsvn = subprocess . check_output ( \"svn info | awk '/^URL:/ {print $2}'\" , shell = True ) . strip () getURLsvn = str ( getURLsvn ) getURLsvn = getURLsvn . replace ( \"'\" , \"\" ) print ( PURPLE + \"\" + str ( getURLsvn [ 1 :]) + \"\" + NORMAL ) return ( getURLsvn [ 1 :])","title":"get_nemorepo()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.get_nemorevision","text":"This function will display the revision number for the current NEMO version Source code in mk_readme/clsmkReadme.py def get_nemorevision (): '''This function will display the revision number for the current NEMO version ''' print ( \" \\n\\n\\n --> What is the NEMO revision you're currently using? Try to get it from git/svn history. Accept with [ENTER]:\" ) if ( LNGIT == True ): try : proc = subprocess . check_output ([ \"git\" , \"log\" , \"--pretty=oneline\" , \"--abbrev-commit\" , \"--reverse\" ]) proc = str ( proc ) getSvnIDText = proc . find ( 'http' ) getIndexHash = proc . find ( '#' ) nemoRev1 = proc [ getSvnIDText : getIndexHash ] getAT = nemoRev1 . find ( '@' ) getspace = nemoRev1 . find ( ' ' ) nemoRev2 = nemoRev1 [ getAT + 1 : getspace ] print ( PURPLE + nemoRev2 + NORMAL ) return ( nemoRev2 ) except git . InvalidGitRepositoryError : print ( PURPLE + \"Not connected to GIT\" + NORMAL ) except OSError as e : print ( \"Error - \" , e ) if ( LNSVN == True ): try : nemoRev = subprocess . check_output ( \"svn info | awk '/^Revision:/ {print $2}'\" , shell = True ) . strip () nemoRev = str ( nemoRev ) nemoRev = nemoRev . replace ( \"'\" , \"\" ) print ( PURPLE + str ( nemoRev [ 1 :]) + NORMAL ) return ( nemoRev [ 1 :]) except svn . exception . SvnException : print ( \"This is not an svn repo \\n \" )","title":"get_nemorevision()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.get_nestnumber","text":"This function will ask for user input to enter number of AGRIF Nests. Returns 0 if value is not available Source code in mk_readme/clsmkReadme.py def get_nestnumber (): '''This function will ask for user input to enter number of AGRIF Nests. Returns 0 if value is not available''' default = 0 print ( \" \\n --> How many \" + BOLD + \"AGRIF nests \" + NORMAL + \" are embedded? Accept our guess with [ENTER] or [M]odify accordingly: \\n\\n \" ) print ( PURPLE + \"Nest Number: \" + NORMAL + \"is \" + str ( default )) choice = input () choice = choice . lower () if choice == 'm' : default = input ( \"Input value: \" ) return default else : return default","title":"get_nestnumber()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.get_oceanrdt","text":"This function will return the length of the general ocean time step for dynamics from namelist_cfg file. Returns unknown if value is not available Source code in mk_readme/clsmkReadme.py def get_oceanrdt () : '''This function will return the length of the general ocean time step for dynamics from namelist_cfg file. Returns unknown if value is not available''' stringToMatch = 'namdom' defaultT = \"\" output = 0 allCFG = getNameLists () #remove empty spaces allCFG = allCFG . replace ( \" \" , \"\" ) print ( \" \\n --> The length of the general ocean time step for dynamics. Accept with [ENTER]: \\n\\n \" ) f = open ( allCFG , \"r\" ) for line in f : if stringToMatch in line : #print(line) for line in f : if \"rn_rdt\" in line : defaultT = line #get the digits between = and . eqIndex = defaultT . find ( \"=\" ) dotIndex = defaultT . find ( \".\" ) output = defaultT [ eqIndex + 1 : dotIndex ] #retrieve the value after _ output = output . strip () #remove white spaces #print(BOLD + \"Time Step for Dynamics [sec]: \" + NORMAL + \"\" + str(output)) break #get the digits between = and . eqIndex = defaultT . find ( \"=\" ) dotIndex = defaultT . find ( \".\" ) output = defaultT [ eqIndex + 1 : dotIndex ] #retrieve the value after _ output = output . strip () #remove white spaces if str ( output ) == \"\" : print ( PURPLE + \"Unknown\" + NORMAL ) return \"Unknown\" else : print ( PURPLE + str ( output ) + NORMAL ) return str ( output )","title":"get_oceanrdt()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.get_passivetracers","text":"This function will ask for user input which additional passive tracers are implemented. Returns unknown if value is not available Source code in mk_readme/clsmkReadme.py def get_passivetracers (): '''This function will ask for user input which additional passive tracers are implemented. Returns unknown if value is not available''' default = \"Unknown\" print ( \" \\n --> Which additional passive tracers are implemented? Accept our guess with [ENTER] or [M]odify accordingly: \\n\\n \" ) print ( PURPLE + \"List of passive tracers (TOP): \" + NORMAL + \"is \" + default ) choice = input () choice = choice . lower () if choice == 'm' : default = input ( \"Input value: \" ) return default else : return default","title":"get_passivetracers()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.get_purpose","text":"This function creates a text file to store the purpose of the readme file or reads the existing text file Source code in mk_readme/clsmkReadme.py def get_purpose (): '''This function creates a text file to store the purpose of the readme file or reads the existing text file ''' pathS = pathlib . Path () . absolute () if ( LNGIT == True ) and ( CURRCONFIG == False ): dirName = str ( pathS ) + \"/CONFIG/\" + exp + \"/.includes\" elif ( LNSVN == True ) and ( CURRCONFIG == False ) and ( release3 == True ): dirName = str ( pathS ) + \"/NEMOGCM/CONFIG/\" + exp + \"/.includes\" elif ( LNSVN == True ) and ( CURRCONFIG == False ) and ( release4 == True ): dirName = str ( pathS ) + \"/cfgs/\" + exp + \"/.includes\" #if current script is stored in one of the configurations elif ( CURRCONFIG == True ): dirName = str ( pathS ) + \"/.includes\" try : # Create target Directory os . mkdir ( dirName ) purpose = input ( \" \\n\\n --> What's the purpose of this configuration?: \\n \" ) f = open ( dirName + \"/.recall_purpose.txt\" , \"w\" ) f . write ( purpose ) f = open ( dirName + \"/.recall_purpose.txt\" , \"r\" ) purpose = f . read () print ( PURPLE + purpose + NORMAL ) return ( purpose ) #if file already exists, read the contents and provide an option for modification (overwritten) except FileExistsError : f = open ( dirName + \"/.recall_purpose.txt\" , \"r\" ) #ask if content is as expected print ( \" \\n\\n --> What's the purpose of this configuration? Trying to remember last answer\" ) purpose = f . read () print ( PURPLE + purpose + NORMAL ) choice = input ( \"Accept with [ENTER] or modify accordingly (press [M] to modify): \" ) choice = choice . lower () if choice == 'm' : purpose = input ( \"Enter a new purpose, this will be overwritten: \" ) f = open ( dirName + \"/.recall_purpose.txt\" , \"w\" ) f . write ( purpose ) f = open ( dirName + \"/.recall_purpose.txt\" , \"r\" ) purpose = f . read () print ( PURPLE + purpose + NORMAL ) return ( purpose ) else : return ( purpose ) f . close () else : print ( \"Unable to create this file, check admin rights\" )","title":"get_purpose()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.get_refconfig","text":"This function asks for user input to return the reference configuration for a particular configuration. This may also be left blank Source code in mk_readme/clsmkReadme.py def get_refconfig (): '''This function asks for user input to return the reference configuration for a particular configuration. This may also be left blank ''' zrefconfname = \"\" zrefconfurl = \"\" zrefconfname = input ( \"--> If there is a reference configuration this particular configuration is based on, please type the name. Otherwise leave it blank by typing [ENTER]. \\n \" ) zrefconfurl = input ( \"--> If there is a reference configuration this particular configuration is based on, please type the URL. Otherwise leave it blank by typing [ENTER]. \\n \" ) return zrefconfname + \" - \" + zrefconfurl","title":"get_refconfig()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.get_resolution","text":"This function will return the value corresponding to the resolution of the horizontal grid from namelist_cfg file. Returns unknown if value is not available Source code in mk_readme/clsmkReadme.py def get_resolution (): '''This function will return the value corresponding to the resolution of the horizontal grid from namelist_cfg file. Returns unknown if value is not available ''' stringToMatch = 'namcfg' defaultK = \"\" output = 0 #get list of namelists allCFG = getNameLists () #remove empty spaces allCFG = allCFG . replace ( \" \" , \"\" ) print ( \" \\n --> The resolution of the horizontal grid. Accept with [ENTER]: \\n\\n \" ) f = open ( allCFG , \"r\" ) print ( \"all CFG is \" , allCFG ) for line in f : #find the section namcfg if stringToMatch in line : #print(line) for line in f : if \"jp_cfg\" in line : defaultK = line break #print(defaultK) #extract digits only from defaultK output = 0 repl_str = re . compile ( '^\\d+$' ) line = defaultK . split () for word in line : match = re . search ( repl_str , word ) if match : output = float ( match . group ()) #print(BOLD + \"Vertical Grid Points (K): \" + NORMAL + \"\" + str(output)) print ( PURPLE + str ( output ) + NORMAL ) return str ( output )","title":"get_resolution()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.get_useremail","text":"This function returns the user email, if available in the config file Source code in mk_readme/clsmkReadme.py def get_useremail (): '''This function returns the user email, if available in the config file ''' if ( LNGIT == True ): try : repo = git . Repo ( \".\" , search_parent_directories = True ) print ( \" \\n --> What is your email address? We try to get it from git. Accept with [ENTER] or modify accordingly: \\n\\n \" ) reader = repo . config_reader () default = reader . get_value ( 'user' , 'email' ) output = PURPLE + \"User's email :\" + default + NORMAL print ( output ) return default except : try : choice = input ( \"Config file does not include the email address, please amend accordingly in .git > config. Proceed with [ENTER] to continue with 'Unknown' or abort with CTRL-C: \" ) except KeyboardInterrupt : print ( \"You pressed Ctrl+C!\" ) finally : return \"Unknown\" else : pass if ( LNSVN == True ): try : email = input ( \" \\n --> Enter your email address (temporarily) or press [Ctrl-C] to exit and update through git-init \\n\\n \" ) return email except KeyboardInterrupt : print ( \"Exit.. \" )","title":"get_useremail()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.get_username","text":"This function returns the username, if available in the config file Source code in mk_readme/clsmkReadme.py def get_username (): '''This function returns the username, if available in the config file ''' if ( LNGIT == True ): try : repo = git . Repo ( \".\" , search_parent_directories = True ) print ( \" \\n --> What is your full name? We try to get it from git. Accept with [ENTER] or modify accordingly: \\n\\n \" ) reader = repo . config_reader () default = reader . get_value ( 'user' , 'name' ) output = PURPLE + \"User's Full Name :\" + default + NORMAL # return output print ( output ) return default except : try : choice = input ( \"Config file does not include the user name, please amend accordingly in .git > config. Proceed with [ENTER] to continue with 'Unknown' or abort with CTRL-C: \" ) except KeyboardInterrupt : print ( \"You pressed Ctrl+C!\" ) finally : return \"Unknown\" else : pass if ( LNSVN == True ): try : username = input ( \" \\n --> Enter your full name (temporarily) or press [Ctrl-C] to exit and update through git-init \\n\\n \" ) return username except KeyboardInterrupt : print ( \"Exit..\" )","title":"get_username()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.get_vgridpt","text":"This function will return the number of grid points in vertical grid from namelist_cfg file. Returns unknown if value is not available Source code in mk_readme/clsmkReadme.py def get_vgridpt (): '''This function will return the number of grid points in vertical grid from namelist_cfg file. Returns unknown if value is not available''' stringToMatch = 'namcfg' defaultK = \"\" output = 0 #get list of namelists allCFG = getNameLists () #remove empty spaces allCFG = allCFG . replace ( \" \" , \"\" ) print ( \" \\n --> Number of grid points in the vertical? Accept with [ENTER]: \\n\\n \" ) f = open ( allCFG , \"r\" ) for line in f : #find the section namcfg if stringToMatch in line : #print(line) for line in f : if \"jpkdta\" in line : defaultK = line break #print(defaultK) #extract digits only from defaultK output = 0 repl_str = re . compile ( '^\\d+$' ) line = defaultK . split () for word in line : match = re . search ( repl_str , word ) if match : output = float ( match . group ()) #print(BOLD + \"Vertical Grid Points (K): \" + NORMAL + \"\" + str(output)) if str ( output ) == \"\" : print ( PURPLE + \"Unknown\" + NORMAL ) return \"Unknown\" else : print ( PURPLE + str ( output ) + NORMAL ) return str ( output )","title":"get_vgridpt()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.get_vgridtype","text":"This function will return the value corresponding to the vertical grid type from namelist_cfg file. Returns unknown if value is not available Source code in mk_readme/clsmkReadme.py def get_vgridtype (): '''This function will return the value corresponding to the vertical grid type from namelist_cfg file. Returns unknown if value is not available''' stringToMatch = '&namzgr ' default = \"\" #get list of namelists allCFG = getNameLists () #remove empty spaces allCFG = allCFG . replace ( \" \" , \"\" ) result = \"\" print ( \" \\n --> Vertical grid type. Accept with [ENTER]: \\n\\n \" ) f = open ( allCFG , \"r\" ) for line in f : if line . startswith ( stringToMatch ): # print(\"line is \", line) # comma on the end prevents the double spacing from printing a file line for line in f : # #namzgrLst.append(line) if ( \".true.\" in line ): #print(\"Filtered \", line) #add to list to extract #lnLst.append(line) for ext in line : if ( \"zco\" in line ): default = \"zco (z-coordinate with full steps)\" #print(BOLD + \"Vertical Grid Type: \" + NORMAL + \"\" + default) break elif ( \"zps\" in line ): default = \"zps (z-coordinate with partial steps)\" #print(BOLD + \"Vertical Grid Type: \" + NORMAL + \"\" + default) break elif ( \"sco\" in line ): default = \"sco (s- or hybrid z-s-coordinate)\" #print(BOLD + \"Vertical Grid Type: \" + NORMAL + \"\" + default) break #not clear - refer to bash script elif ( \"isfcav\" in line ): default = \"ice shelf cavity\" #print(BOLD + \"Vertical Grid Type: \" + NORMAL + \"\" + default) break if line . startswith ( \"/\" ): break # stop this inner for loop; outer loop picks up on the next line if default == \"\" : print ( PURPLE + \"Unknown\" + NORMAL ) return \"Unknown\" else : print ( PURPLE + default + NORMAL ) return default","title":"get_vgridtype()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.get_zGITNMSPC","text":"This function returns the value of a variable zGITNMSPC Source code in mk_readme/clsmkReadme.py def get_zGITNMSPC (): '''This function returns the value of a variable zGITNMSPC''' zGITSERVER = get_zGITSERVER () if zGITSERVER == \"gitlab.de\" : zGITNMSPC = \"DRAKKAshare\" elif zGITSERVER == \"git.geomar.de\" : zGITNMSPC = \"NEMO/EXP\" return zGITNMSPC","title":"get_zGITNMSPC()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.get_zGITSERVER","text":"This function returns the value of a variable zGITSERVER Source code in mk_readme/clsmkReadme.py def get_zGITSERVER (): '''This function returns the value of a variable zGITSERVER''' if ( LNGIT == True ): zGITSERVER = \"git.geomar.de\" else : zGITSERVER = \"gitlab.de\" return zGITSERVER","title":"get_zGITSERVER()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.get_zPAGESRV","text":"This function returns the value of a variable zPAGESRV Source code in mk_readme/clsmkReadme.py def get_zPAGESRV (): '''This function returns the value of a variable zPAGESRV''' zGITSERVER = get_zGITSERVER () if zGITSERVER == \"gitlab.de\" : zPAGESRV = \"https://drakkarshare.gitlab.io\" zPAGE = zPAGESRV + \"/\" + _CONFNAME_ elif zGITSERVER == \"git.geomar.de\" : zPAGESRV = \"#\" zPAGE = \"| [Static Page](\" + zPAGESRV + \"/\" + _CONFNAME_ + \")\" return zPAGE","title":"get_zPAGESRV()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.getAllConfigFolders","text":"This function will return a list of configurations, and eventually user will choose which configuration s/he would like to work with: (e.g. AMM12, ORCA2_LIM_CFC_C14b, GYRE, ORCA025.L46.LIM2vp.CORE.XIOS1, ORCA2_LIM etc.. Display only the configurations that include EXP00 folder Source code in mk_readme/clsmkReadme.py def getAllConfigFolders (): '''This function will return a list of configurations, and eventually user will choose which configuration s/he would like to work with: (e.g. AMM12, ORCA2_LIM_CFC_C14b, GYRE, ORCA025.L46.LIM2vp.CORE.XIOS1, ORCA2_LIM etc.. Display only the configurations that include EXP00 folder''' configFolders = [] listWithAllDir = [] listOnlyExp00 = [] configPath = getNemoConfig () #print(\"Config path\" , configPath) for r , d , f in os . walk ( configPath ): for directory in d : if \"EXP00\" in d : #release3 listWithAllDir . append ( os . path . join ( r , directory )) elif \"EXPREF\" in d : #release 4 listWithAllDir . append ( os . path . join ( r , directory )) for i in listWithAllDir : if \"EXP00\" in i : #remove the EXP00 listOnlyExp00 . append ( i ) elif \"EXPREF\" in i : #remove the EXPREF listOnlyExp00 . append ( i ) for c in listOnlyExp00 : last = c . split ( '/' ) configFolders . append ( last [ - 2 ]) #sort configFolders configFolders . sort () return configFolders","title":"getAllConfigFolders()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.getNameLists","text":"This function searches for namelist_cfg file and extracts the namelist path for the chosen configuration Source code in mk_readme/clsmkReadme.py def getNameLists (): ''' This function searches for namelist_cfg file and extracts the namelist path for the chosen configuration''' #to retrieve only the cfg of the chosen configuration cfgNameLists = [] findExactNameList = [] output = \"\" path2 = getNemoConfig () for ( dirname , dirs , files ) in os . walk ( path2 ): #for (dirname, dirs, files) in os.walk('.'): for filename in files : if filename . startswith ( '1_namelist_cfg' ): pass #ignore elif 'namelist_cfg' in filename : thefile = os . path . join ( dirname , filename ) if exp in thefile : cfgNameLists . append ( thefile ) #go through the list to check for entries containing part of the chosen name if ( len ( cfgNameLists ) == 1 ): #print(cfgNameLists) output = cfgNameLists else : #add each item to the list for i in range ( len ( cfgNameLists )): findExactNameList . append ( cfgNameLists [ i ]) #Search through each item for the exact configuration name for item in findExactNameList : #for i in item: pathSplit = item . split ( '/' ) #Get the third element from the last if exp == pathSplit [ - 3 ]: #print(item) output = item #return full path #convert list to str return '' . join ([ str ( elem ) for elem in output ])","title":"getNameLists()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.getNemoConfig","text":"This function will look for the directory 'NEMOGCM/CONFIG' for release 3 and 'cfgs' for release 4 anywhere in the system Source code in mk_readme/clsmkReadme.py def getNemoConfig (): '''This function will look for the directory 'NEMOGCM/CONFIG' for release 3 and 'cfgs' for release 4 anywhere in the system''' global release3 , release4 rootPath = pathlib . Path () . absolute () fname = [] configPath = \"\" for root , d_names , f_names in os . walk ( rootPath ): for f in d_names : fname . append ( os . path . join ( root , f )) for i in fname : if \"NEMOGCM/CONFIG\" in i : configPath = i release3 = True #if this is True, the script is being run as a release 3 break elif \"cfgs\" in i : configPath = i release4 = True #if this is True, the script is being run as a release 4 break path = configPath #if release is 4 remove the last two folders since the file structure is different in rel3 and rel4 if (( release3 == True ) or ( release4 == True )) and ( scriptLoc != None ): pathSplit = os . path . dirname ( path ) pathUpdated , tail = os . path . split ( pathSplit ) return pathUpdated else : return path","title":"getNemoConfig()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.hr","text":"displays a list of * across the page and moves cursor to next line Source code in mk_readme/clsmkReadme.py def hr (): '''displays a list of * across the page and moves cursor to next line''' command = [ 'tput' , 'cols' ] width = int ( subprocess . check_output ( command )) for i in range ( width ): { print ( \"*\" , end = \"\" ) } print ( \" \\n \" )","title":"hr()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.indent","text":"Indents text to the right Source code in mk_readme/clsmkReadme.py def indent ( text ): '''Indents text to the right''' text = textwrap . indent ( text , ' ' * 4 )[ 4 - 1 :] print ( text )","title":"indent()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.list_inputfiles","text":"The purpose of this function is to generate the 'Input Files' section in the readme file Source code in mk_readme/clsmkReadme.py def list_inputfiles (): '''The purpose of this function is to generate the 'Input Files' section in the readme file ''' #count 0 is the header count = 1 col1 = \"\" col2 = \"\" col3 = \"\" path2 = os . getcwd () parent = os . path . dirname ( path2 ) #parent directory #for (dirname, dirs, files) in os.walk('.'): for ( dirname , dirs , files ) in os . walk ( parent ): rowsLst . append ([]) rowsLst . append ([]) rowsLst . append ([]) for filename in files : if filename . endswith ( '.def' ) : thefile = os . path . join ( dirname , filename ) #list path with .def extension with open ( thefile ) as f : url = \"\" infile_nemo = \"\" #print all contents of the file for line in f : line = line . strip () #access only the lines that are not commented and empty if not ( line . startswith ( '#' )): if len ( line ) != 0 : allFieldsFirstLine = line . split ( \",\" ) try : infile_nemo = allFieldsFirstLine [ 0 ] #1st element #print(\"infile_nemo: \" + infile_nemo) col1 = infile_nemo if infile_nemo == \"\" or infile_nemo == \" \\\\ \" : infile_nemo = next ( f ) #move to next line else : infile_nemo = allFieldsFirstLine [ 1 ] except : #print(\"Error for infile_nemo\") print ( \"infile Nemo: \" + infile_nemo ) try : url = allFieldsFirstLine [ 2 ] #tableListing.append(url) if not ( url == \" \\\\ \" or url == \"\" or url == \"' \\' \" ): #print(\"this is the original line\") url = allFieldsFirstLine [ 2 ] else : #print(\"this is the next line\") url = next ( f ) #move to next line #print(\"url: \" + url.strip()) col3 = url . strip () + \" \\n \" except : #two exceptions to cater for in file #./ORCA025.L46.LIM2vp.CFCSF6.JRA.XIOS2/EXP00/input.def #print(\"Skip two lines section\") url = next ( f ) url = next ( f ) #print(\"URL : \", url.strip()) col3 = url . strip () + \" \\n \" #add data to table col1 = col1 . strip () col2 = \"---\" col3 = col3 . strip () if 'thredds' in col3 : col3up = col3 pass elif '@' in col3 : getIndex = col3 . find ( '@' ) col3 = col3 [ getIndex + 1 :] #replace : with / col3 = col3 . replace ( ':' , '/' ) #get last part of the string lastPart = col3 . split ( \"/\" )[ - 1 ] lastIndex = col3 . find ( lastPart ) col3 = col3 [: lastIndex - 1 ] col3up = lastPart + \"<b>\" + \" in \" + \"</b>\" + col3 #col3up = lastPart + \"<b>\" + \" in \" + \"</b>\" + \"<a href=\" + \"'\" + col3 + \"'\" + \">\" + col3 + \"</a>\" rowsLst [ count ] . append ( col1 ) rowsLst [ count ] . append ( col2 ) rowsLst [ count ] . append ( col3up ) count = count + 1 #### Create the table ####### rowsLst [ 0 ] . append ( \"**NEMO Input File**\" ) rowsLst [ 0 ] . append ( \"**Reference (DOI)**\" ) rowsLst [ 0 ] . append ( \"**Download**\" ) #this list will not contain empty tuples and will be used in the markdown template rowsLst2 = [ e for e in rowsLst if e ] return make_markdown_table ( rowsLst2 )","title":"list_inputfiles()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.main","text":"This function will be called if the script is stored in the root Source code in mk_readme/clsmkReadme.py def main (): '''This function will be called if the script is stored in the root''' check_inputDef_exists () #check if input.def is part of this directory if check_inputDef_exists () == True : exp = chooseConfigFolder () #print(ask_exp00()) if ask_exp00 ( exp ) == True : template () else : print ( \"Exiting..Please start again\" ) else : print ( \"Input.def file does not exist, create this file to be able to proceed\" )","title":"main()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.mainconfig","text":"This function will be called if the script is initially saved in one of the configuration folders Source code in mk_readme/clsmkReadme.py def mainconfig (): '''This function will be called if the script is initially saved in one of the configuration folders''' check_inputDef_exists () #check if input.def is part of this directory if check_inputDef_exists () == True : if ask_exp00 ( exp ) == True : template () else : print ( \"Exiting..Please start again\" ) else : print ( \"Input.def file does not exist, create this file to be able to proceed\" )","title":"mainconfig()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.make_markdown_table","text":"This function is used to format the tables in the readme file to replicate the markdown format Source code in mk_readme/clsmkReadme.py def make_markdown_table ( rowsLst2 ): '''This function is used to format the tables in the readme file to replicate the markdown format ''' markdown = \" \\n \" + str ( \"| \" ) for e in rowsLst2 [ 0 ]: to_add = \" \" + str ( e ) + str ( \" |\" ) markdown += to_add markdown += \" \\n \" markdown += '|' for i in range ( len ( rowsLst2 [ 0 ])): markdown += str ( \"-------------- | \" ) markdown += \" \\n \" for entry in rowsLst2 [ 1 :]: markdown += str ( \"| \" ) for e in entry : to_add = str ( e ) + str ( \" | \" ) markdown += to_add markdown += \" \\n \" return markdown + \" \\n \"","title":"make_markdown_table()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.prep_note","text":"The purpose of this function is to display a list of prerequistes to successfully render a readme file Source code in mk_readme/clsmkReadme.py def prep_note (): '''The purpose of this function is to display a list of prerequistes to successfully render a readme file''' uName = os . uname () . nodename uName = str ( uName ) print ( \" \\n \" ) hr () print ( \" \\n \" ) center ( \"Prepare DRAKKARshare upload\" ) print ( \" \\n \" ) hr () print ( \" \\n\\n Before we begin, we have to make sure, that the following \" + ULINE + \"conditions are fulfilled\" + NORMAL + \" and you have the \" + ULINE + \"essential information\" + NORMAL + \" at hand right now:\" ) print ( \" \\n\\n \" ) indent ( \" [ ] \" \"You have access to \" + BOLD + BLACK + \"at least one gitlab server\" + NORMAL + \", like \" + BLUE + zGITSERVER + \"/\" + zGITNMSPC + NORMAL + \" and your \" + BOLD + BLACK + \"public ssh-key \" + NORMAL + \"from this host (\" + uName + \") has been deposited under your gitlab profile.\" ) print ( \" \\n \" ) indent ( \" [ ] \" \"Configuration-specific \" + BOLD + BLACK + \" input files \" + NORMAL + \" are \" + ULINE + \"publicly accessible\" + NORMAL + \" at least for members of a specific gitlab group) and you have a \" + BOLD + BLACK + \" reference\" + NORMAL + \" (e.g. DOI) and a \" + BOLD + BLACK + \" Download-URL \" + NORMAL + \" for each file.\" ) print ( \" \\n \" ) indent ( \" [ ] \" \"You know the \" + BOLD + BLACK + \"NEMO revision\" + NORMAL + \" and the \" + BOLD + BLACK + \"URL\" + NORMAL + \" you've installed it from (if it can't be determined automatically, because you're not within a svn or git working directory)\" ) print ( \" \\n \" ) indent ( \" [ ] \" \"If your configuration is build upon another \" + BOLD + BLACK + \"reference configuration \" + NORMAL + \" you'll need the exact name and a reference URL (e.g. another DRAKKARshare repository)\" ) print ( \" \\n \" ) indent ( \" [ ] \" \"Is INPUT.def part of this configuration? \" ) print ( \" \\n \" ) answer = input ( BOLD + RED + \"Do you confirm, that you meet the conditions above? [Y|N]:\" + NORMAL ) answer = answer . lower () if ( answer == \"n\" ): exit () else : return answer","title":"prep_note()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.sucssmsg","text":"Displays an error message in GREEN and reset text colour - Message will be passed as a parameter Source code in mk_readme/clsmkReadme.py def sucssmsg ( msg ): ''' Displays an error message in GREEN and reset text colour - Message will be passed as a parameter''' print ( GREEN + ' \\n SUCCESS: ' + msg + ' \\n\\n ' + NORMAL )","title":"sucssmsg()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.template","text":"The purpose of this function is to create a markup template with values generated from previous functions Source code in mk_readme/clsmkReadme.py def template (): '''The purpose of this function is to create a markup template with values generated from previous functions''' readme = Template ( \"\"\" # {{_COMPONENTS_}} ___ [Purpose](#purpose) | [Contact](#contact) | [License](#license) | [Configuration](#configuration) | [Input Files](#input-files) | [Diagnostics](#diagnostics) | [Installation](#installation) {{_zPAGE_}} ____ # Purpose {{_PURPOSE_}} # Contact {{_CONTACT_}} # License **By downloading this repository and using this code you agree to the following conditions.** The code in this project is based on the [NEMO](http://www.nemo-ocean.eu) software (Copyright (c) Centre National de la Recherche Scientifique CNRS). The original code as well as the contribution to this code in this project are licensed under the conditions of [CeCILL](http://www.cecill.info). The person stated under '*Contact*' above is the owner of the intellectual property rights of these contributions and **must be informed afore** publishing and **must be cited** in every published work that is based completely or partially on the modifications and additional code provided by this configuration. Usage is at one's own risk. # Configuration {{config_table}} The default experiment settings can be found in the [EXP00](EXP00) folder. The modified code is located in the [MY_SRC](MY_SRC) directory. # Input Files * **NEMO Input File:** File names as they are expected by NEMO * **Reference:** Citation for an article or report, webpage or even better: DOI * **Download:** Link for direct downloading the file (no user-interaction preferred to make it script-compliant) The actual file names should follow the *Guidelines for Naming DRAKKAR Input File Names*: \"\\`NemoName\\` \\\\ _\\`NemoVersion\\` \\\\ _\\`ConfigGrid\\` \\\\ _\\`Version\\`.nc\" {{list_inputfiles}} # Diagnostics See [DIAG](DIAG) for some standard diagnostics from a simulation with this configuraton. # Installation There are plenty of ways how to install a local copy of this configuration: 1. You can [clone it with git](#install-with-git) (regardless of whether your NEMOGCM path is already under git control or not). 2. Or you just download an archive from the web interface. In some cases there are different versions of the same configuration in separate branches (e.g. to reflect different NEMO revisions); **check the branches/tags** menu on the web interface or use the git branch and checkout commands to select the version you're interested in. <!--For further details, please read the [HELP pages](https://gitlab.com/DRAKKARshare/help/edit/master/GetConfiguration.md).--> ## Install with \\`git\\` **{- IMPORTANT: -}** The following guidelines assume, that you're already registered at https://{{_zGITSERVER_}} and your public SSH key has been deposited under your gitlab profile. #### (A) NEMOGCM already under git control If your **NEMOGCM installation is already under git control** you cannot clone a different repository into the existing working copy. Instead, you can use \\`git subtree\\` to inject files from another remote repository into a particular sub-folder of your existing working tree. Within NEMOGCM directory: **Option - With git commands** ~~~bash cd NEMOGCM git remote add -f remote_{{_CONFNAME_}} git@{{_zGITSERVER_}}:{{_zGITNMSPC_}}/{{_CONFNAME_}}.git # add remote git subtree add --prefix CONFIG/{{_CONFNAME_}} remote_{{_CONFNAME_}} {{_NEMOBRANCH_}}:-master --squash # donwload master branch into sub-folder cd CONFIG/{{_CONFNAME_}} remote_{{_CONFNAME_}} cat cfg.txt >> ../cfg.txt ~~~ > In this case, you keep the information from where you have downloaded the reference configuration (see \\`git remote -v\\`). Or even shorter, without keeping remote source information (not recommended): ~~~bash cd NEMOGCM git subtree add --prefix CONFIG/{{_CONFNAME_}} git@{{_zGITSERVER_}}:{{_zGITNMSPC_}}/{{_CONFNAME_}}.git {{_NEMOBRANCH_}}:-master --squash cd CONFIG/{{_CONFNAME_}} remote_{{_CONFNAME_}} cat cfg.txt >> ../cfg.txt ~~~ #### (B) NEMOGCM not under git control If your NEMOGCM installation **is not under git control already**, you can clone this configuration using the URL specified on the project's front page: ~~~bash cd NEMOGCM/CONFIG git clone git@{{_zGITSERVER_}}:{{_zGITNMSPC_}}/{{_CONFNAME_}}.git cat {{_CONFNAME_}}/cfg.txt >> cfg.txt ~~~ This wil create a new configuration folder, which can be used as a reference case for \\`makenemo -r\\`. Make sure, you add this confiuration to the local registry file \\`cfg.txt\\` before invoking \\`makenemo\\`. #### Other revisions The revision that will be installed, is the most recent one from the **master** branch. If you're seeking another branch/revision of this configuration (e.g. an older one), you can browse available branches/tags via the web-interface or list alternative branches on the command line and swap available branches/tags easily with \\`checkout\\`: ~~~bash cd {{_CONFNAME_}} git branches -r git checkout otherBranch ~~~ Note: *origin/HEAD* in the output listing is not a branch in its own but points to the default branch (master branch in most cases). \"\"\" ) fillenv () pathS = pathlib . Path () . absolute () if ( LNGIT == True ) and ( CURRCONFIG == False ): READMEOUT = str ( pathS ) + \"/CONFIG/\" + exp + \"/README_\" + exp + \".md\" elif ( LNSVN == True ) and ( CURRCONFIG == False ) and ( release3 == True ): READMEOUT = str ( pathS ) + \"/NEMOGCM/CONFIG/\" + exp + \"/README_\" + exp + \".md\" elif ( LNSVN == True ) and ( CURRCONFIG == False ) and ( release4 == True ): READMEOUT = str ( pathS ) + \"/cfgs/\" + exp + \"/README_\" + exp + \".md\" #if current script is stored in one of the configurations elif ( CURRCONFIG == True ): READMEOUT = str ( pathS ) + \"/README_\" + exp + \".md\" with open ( READMEOUT , \"w\" ) as f : f . write ( readme . render ( _CONFNAME_ = _CONFNAME_ , _CONTACT_ = _CONTACT_ , _PURPOSE_ = _PURPOSE_ , _CURREPO_ = _CURREPO_ , _NEMOREPO_ = _NEMOREPO_ , _NEMOREVISION_ = _NEMOREVISION_ , _NEMOBRANCH_ = _NEMOBRANCH_ , _COMPONENTS_ = _COMPONENTS_ , _REFCONFIG_ = _REFCONFIG_ , _CPPKEYS_ = _CPPKEYS_ , _RESOLUTION_ = _RESOLUTION_ , _GRID_ = _GRID_ , _HGRIDPT_ = _HGRIDPT_ , _VGRIDPTZ_ = _VGRIDPTZ_ , _ATMOS_ = _ATMOS_ , _OCEANRDT_ = _OCEANRDT_ , _NESTNUMBER_ = _NESTNUMBER_ , _PASSIVTRACERS_ = _PASSIVTRACERS_ , list_inputfiles = list_inputfiles (), config_table = config_table (), _zGITSERVER_ = _zGITSERVER_ , _zGITNMSPC_ = _zGITNMSPC_ , _zPAGE_ = _zPAGE_ )) print ( \"README file created\" )","title":"template()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.trim","text":"If any white spaces are present at the end of a line, the purpose of this function is to remove them Source code in mk_readme/clsmkReadme.py def trim ( text ): '''If any white spaces are present at the end of a line, the purpose of this function is to remove them''' text = text . strip () return text","title":"trim()"},{"location":"api-mkreadme.html#mk_readme.clsmkReadme.MakeReadme.warnmsg","text":"Displays an error message in YELLOW and reset text colour - Message will be passed as a parameter Source code in mk_readme/clsmkReadme.py def warnmsg ( msg ): ''' Displays an error message in YELLOW and reset text colour - Message will be passed as a parameter''' print ( YELLOW + ' \\n WARNING: ' + msg + ' \\n\\n ' + NORMAL ) : : : my_package.my_module.MyClass handler: python selection: members: - method_a - method_b rendering: show_root_heading: false show_source: false : : : my_package.my_module.MyClass handler: python rendering: show_root_heading: false show_source: false : : : MY_PACKAGE.your_module handler: python rendering: show_root_heading: false show_source: false","title":"warnmsg()"},{"location":"getothers.html","text":"Via other resources \ud83d\udd17","title":"others"},{"location":"getothers.html#via-other-resources","text":"","title":"Via other resources"},{"location":"getsimulation.html","text":"Get a Simulation Package \ud83d\udd17","title":"Get a Simulation Package"},{"location":"getsimulation.html#get-a-simulation-package","text":"","title":"Get a Simulation Package"},{"location":"gettingstarted.html","text":"Getting Started \ud83d\udd17 Note The working environment structure can differ significantly between different users. Hence there is no \"one-click & go\" solution for publishing a simulation package. SIMSAR follows rather a \"recipe\" guided approach and provides the user with batch scripts or other tools where feasible. Assuming the path to your copy of the NEMO repository is NEMO/release-4.0 in your $HOME directory, let's go into the respective experiment folder of the simulation you want to publish (e.g. experiment MyExp1 under configuration My_Config ): cd ~/NEMO/release-4.0/cfgs/My_Config/MyEXP1 From this directory go through the steps below: Step-1: List input data files \ud83d\udd17 First, we need a list of the required input data files for your simulation together with some detailed meta-data, like sources, references and check-sums. SIMSAR expects this list in a special file, the input.def file. If this file does not exists yet, please create it. You'll find more information about the file format and how to create it in the \" Citable Input Data \" section of this guide. Just click on these buttons for further details: How to refer to Input Data The \"input.def\" file Check Now you should have an input.def file in your experiment folder that looks similar to the example below. #-------------------------------------------------------------------------------------- # NEMO Input File Definition # # <NEMO-FileName>, <'DOI|Reference SHA256=xxxx...'>, <URI>[,<URI>[,...]] # # Each 'Reference' can also contain a SHA256-hash for verifying the file. This entry # is separated with spaces and has the preceding key-word SHA256= without any blanks # # You can use hash character (#) to comment the rest of the line out # Long lines can be split by backslashes (\\); trailing comments (#) are allowed. # #-------------------------------------------------------------------------------------- # <NEMO-FileName>, <'DOI|Reference SHA256=xxxx...'>, <URI>[,<URI>[,...]] coordinates.nc, SHA256 = 288b021a8595efeee8de7c4fb665d3037bd356a72ca13e591bb81acc5c3ceeb5 ,\\ https://data.myserver.org/ORCA025/coordinates__3.6.0_ORCA025_v1.0.1.nc reshape_jra55_orca025_bilin.nc, SHA256 = 645de13bb1cbe652c1c2fa3913523d42adf4ec04fd3f55f20766a43abbd00e50 ,\\ git@git.myserver.org:ORCA025/reshape_jra.git/reshape_jra_bilin__v1.0.1.nc reshape_jra55_orca025_bicub.nc, SHA256 = 91edfbc233a48d6aaa266d7aca71665f420da9957d3d124e9864e91e0012e10f ,\\ git@git.myserver.org:ORCA025/reshape_jra.git/reshape_jra_bicub__v1.0.1.nc Important Make sure, that the sources in this list (the URLs) are publicly accessible (or grant permissions respectively). Step-2: Create a Simulation Package \ud83d\udd17 A Simulation Package consists of the code (reference to the NEMO revision + the user code modifications), the build settings and the runtime environment (namelists + input files). The package can be optionally extended with output data or figures for evaluation (or a reference to them) and testing/analysis routines. In order to create the simulation package, you'll need to go through these three sub-steps: Get some of the meta-information ready that we cannot detect automatically Preparation Create a README file that summarizes the characteristics of the simulation (involves automatic detection as well as an interactive user dialog) Create a README (mkReadme) Create a separate local git repository containing a clean copy of the relevant files for the simulation package that can be easily reviewed before submission to a remote respoitory Bundle up Check Now you should have a clean simulation repository in a separate directory looking similar to this: tree /tmp/My_Config-MyExp1 /tmp/My_Config-MyExp1/ | -MY_SRC/ | -sbcblk.F90 | -MyExp1/ | -iodef.xml | -input.def | -namelist_cfg | -namelist_ice_cfg | -namelist_ice_ref | -namelist_ref | -cpp_MyConfig.fcm | -README.md | -ref_cfgs.input Step-3: Publish \ud83d\udd17 Via Git \ud83d\udd17 Allows others to contribute to the development of a simulation (if desired). publish via git Tip Maybe you want to indicate a persistent handler (e.g. DOI) in the README file. In this case, try to get a preliminary identifier from the service provider, modify the README accordingly, then commit to the remote repository and finally register this commit with the handler provider. + Add Static Webpage (optional) \ud83d\udd17 Can be also used with the \"unsupported configuration\" switch makenemo -u to import this simulation into NEMO. add static webpage + Persistent Handler (optional) \ud83d\udd17 If the simulation you've just published is used for some (printed) publication or if you want colleagues to be able to cite your simulation correctly (e.g. because they are using the model output from your run), you should link the repository (and/or the static pages) to some kind of persistant handler, like a DOI. Get a DOI","title":"Getting Started"},{"location":"gettingstarted.html#getting-started","text":"Note The working environment structure can differ significantly between different users. Hence there is no \"one-click & go\" solution for publishing a simulation package. SIMSAR follows rather a \"recipe\" guided approach and provides the user with batch scripts or other tools where feasible. Assuming the path to your copy of the NEMO repository is NEMO/release-4.0 in your $HOME directory, let's go into the respective experiment folder of the simulation you want to publish (e.g. experiment MyExp1 under configuration My_Config ): cd ~/NEMO/release-4.0/cfgs/My_Config/MyEXP1 From this directory go through the steps below:","title":"Getting Started"},{"location":"gettingstarted.html#step-1-list-input-data-files","text":"First, we need a list of the required input data files for your simulation together with some detailed meta-data, like sources, references and check-sums. SIMSAR expects this list in a special file, the input.def file. If this file does not exists yet, please create it. You'll find more information about the file format and how to create it in the \" Citable Input Data \" section of this guide. Just click on these buttons for further details: How to refer to Input Data The \"input.def\" file Check Now you should have an input.def file in your experiment folder that looks similar to the example below. #-------------------------------------------------------------------------------------- # NEMO Input File Definition # # <NEMO-FileName>, <'DOI|Reference SHA256=xxxx...'>, <URI>[,<URI>[,...]] # # Each 'Reference' can also contain a SHA256-hash for verifying the file. This entry # is separated with spaces and has the preceding key-word SHA256= without any blanks # # You can use hash character (#) to comment the rest of the line out # Long lines can be split by backslashes (\\); trailing comments (#) are allowed. # #-------------------------------------------------------------------------------------- # <NEMO-FileName>, <'DOI|Reference SHA256=xxxx...'>, <URI>[,<URI>[,...]] coordinates.nc, SHA256 = 288b021a8595efeee8de7c4fb665d3037bd356a72ca13e591bb81acc5c3ceeb5 ,\\ https://data.myserver.org/ORCA025/coordinates__3.6.0_ORCA025_v1.0.1.nc reshape_jra55_orca025_bilin.nc, SHA256 = 645de13bb1cbe652c1c2fa3913523d42adf4ec04fd3f55f20766a43abbd00e50 ,\\ git@git.myserver.org:ORCA025/reshape_jra.git/reshape_jra_bilin__v1.0.1.nc reshape_jra55_orca025_bicub.nc, SHA256 = 91edfbc233a48d6aaa266d7aca71665f420da9957d3d124e9864e91e0012e10f ,\\ git@git.myserver.org:ORCA025/reshape_jra.git/reshape_jra_bicub__v1.0.1.nc Important Make sure, that the sources in this list (the URLs) are publicly accessible (or grant permissions respectively).","title":"Step-1: List input data files"},{"location":"gettingstarted.html#step-2-create-a-simulation-package","text":"A Simulation Package consists of the code (reference to the NEMO revision + the user code modifications), the build settings and the runtime environment (namelists + input files). The package can be optionally extended with output data or figures for evaluation (or a reference to them) and testing/analysis routines. In order to create the simulation package, you'll need to go through these three sub-steps: Get some of the meta-information ready that we cannot detect automatically Preparation Create a README file that summarizes the characteristics of the simulation (involves automatic detection as well as an interactive user dialog) Create a README (mkReadme) Create a separate local git repository containing a clean copy of the relevant files for the simulation package that can be easily reviewed before submission to a remote respoitory Bundle up Check Now you should have a clean simulation repository in a separate directory looking similar to this: tree /tmp/My_Config-MyExp1 /tmp/My_Config-MyExp1/ | -MY_SRC/ | -sbcblk.F90 | -MyExp1/ | -iodef.xml | -input.def | -namelist_cfg | -namelist_ice_cfg | -namelist_ice_ref | -namelist_ref | -cpp_MyConfig.fcm | -README.md | -ref_cfgs.input","title":"Step-2: Create a Simulation Package"},{"location":"gettingstarted.html#step-3-publish","text":"","title":"Step-3: Publish"},{"location":"gettingstarted.html#via-git","text":"Allows others to contribute to the development of a simulation (if desired). publish via git Tip Maybe you want to indicate a persistent handler (e.g. DOI) in the README file. In this case, try to get a preliminary identifier from the service provider, modify the README accordingly, then commit to the remote repository and finally register this commit with the handler provider.","title":"Via Git"},{"location":"gettingstarted.html#add-static-webpage-optional","text":"Can be also used with the \"unsupported configuration\" switch makenemo -u to import this simulation into NEMO. add static webpage","title":"+ Add Static Webpage (optional)"},{"location":"gettingstarted.html#persistent-handler-optional","text":"If the simulation you've just published is used for some (printed) publication or if you want colleagues to be able to cite your simulation correctly (e.g. because they are using the model output from your run), you should link the repository (and/or the static pages) to some kind of persistant handler, like a DOI. Get a DOI","title":"+ Persistent Handler (optional)"},{"location":"getviacloud.html","text":"Via Cloud \ud83d\udd17","title":"file exchange"},{"location":"getviacloud.html#via-cloud","text":"","title":"Via Cloud"},{"location":"getviagit.html","text":"Via GIT \ud83d\udd17","title":"git"},{"location":"getviagit.html#via-git","text":"","title":"Via GIT"},{"location":"getvianemo.html","text":"Get via maenemo -u \ud83d\udd17","title":"HTML (git pages)"},{"location":"getvianemo.html#get-via-maenemo-u","text":"","title":"Get via maenemo -u"},{"location":"input_def.html","text":"The input.def File \ud83d\udd17 The input.def file is an additional file that is not part of the original NEMO framework. It lists all the input data files needed for a specific simulation, each with their file names as expected by NEMO (hard coded or by namelist parameter) one or multiple remote sources (file name may differ from the NEMO name) a SHA256 checksum (optional) a reference , like a publication or the data file's DOI/POI (optional) Info input.def is read by the mkReadme python script. File Format \ud83d\udd17 The file is a simple ASCII text file with: each record representing one input file a record may consist of multiple continuing lines (use \\ and a line break at the end of a line to continue in the next line instead of a simple line break) each record consists of three or more comma separated columns: The file name as expected by NEMO A SHA256 checksum (preceded with ' sha256= ') and/or a Reference Text at least one source URL (optional) additional URLs, if available (also comma separated) lines that start with a ' # ' are completely treated as comments (may be preceded with blanks; continuing lines ('\\') must start with a hash character as well) Example \ud83d\udd17 See the example/template file docs/input.def : Example input.def #-------------------------------------------------------------------------------------- # NEMO Input File Definition # # <NEMO-FileName>, <'DOI|Reference SHA256=xxxx...'>, <URI>[,<URI>[,...]] # # Each 'Reference' can also contain a SHA256-hash for verifying the file. This entry # is separated with spaces and has the preceding key-word SHA256= without any blanks # # You can use hash character (#) to comment the rest of the line out # Long lines can be split by backslashes (\\); trailing comments (#) are allowed. # #-------------------------------------------------------------------------------------- # <NEMO-FileName>, <'DOI|Reference SHA256=xxxx...'>, <URI>[,<URI>[,...]] coordinates.nc, SHA256=288b021a8595efeee8de7c4fb665d3037bd356a72ca13e591bb81acc5c3ceeb5 ,\\ https://data.myserver.org/ORCA025/coordinates__3.6.0_ORCA025_v1.0.1.nc reshape_jra55_orca025_bilin.nc, SHA256=645de13bb1cbe652c1c2fa3913523d42adf4ec04fd3f55f20766a43abbd00e50 ,\\ git@git.myserver.org:ORCA025/reshape_jra.git/reshape_jra_bilin__v1.0.1.nc reshape_jra55_orca025_bicub.nc, SHA256=91edfbc233a48d6aaa266d7aca71665f420da9957d3d124e9864e91e0012e10f ,\\ git@git.myserver.org:ORCA025/reshape_jra.git/reshape_jra_bicub__v1.0.1.nc","title":"The \"input.def\" file"},{"location":"input_def.html#the-inputdef-file","text":"The input.def file is an additional file that is not part of the original NEMO framework. It lists all the input data files needed for a specific simulation, each with their file names as expected by NEMO (hard coded or by namelist parameter) one or multiple remote sources (file name may differ from the NEMO name) a SHA256 checksum (optional) a reference , like a publication or the data file's DOI/POI (optional) Info input.def is read by the mkReadme python script.","title":"The input.def File"},{"location":"input_def.html#file-format","text":"The file is a simple ASCII text file with: each record representing one input file a record may consist of multiple continuing lines (use \\ and a line break at the end of a line to continue in the next line instead of a simple line break) each record consists of three or more comma separated columns: The file name as expected by NEMO A SHA256 checksum (preceded with ' sha256= ') and/or a Reference Text at least one source URL (optional) additional URLs, if available (also comma separated) lines that start with a ' # ' are completely treated as comments (may be preceded with blanks; continuing lines ('\\') must start with a hash character as well)","title":"File Format"},{"location":"input_def.html#example","text":"See the example/template file docs/input.def : Example input.def #-------------------------------------------------------------------------------------- # NEMO Input File Definition # # <NEMO-FileName>, <'DOI|Reference SHA256=xxxx...'>, <URI>[,<URI>[,...]] # # Each 'Reference' can also contain a SHA256-hash for verifying the file. This entry # is separated with spaces and has the preceding key-word SHA256= without any blanks # # You can use hash character (#) to comment the rest of the line out # Long lines can be split by backslashes (\\); trailing comments (#) are allowed. # #-------------------------------------------------------------------------------------- # <NEMO-FileName>, <'DOI|Reference SHA256=xxxx...'>, <URI>[,<URI>[,...]] coordinates.nc, SHA256=288b021a8595efeee8de7c4fb665d3037bd356a72ca13e591bb81acc5c3ceeb5 ,\\ https://data.myserver.org/ORCA025/coordinates__3.6.0_ORCA025_v1.0.1.nc reshape_jra55_orca025_bilin.nc, SHA256=645de13bb1cbe652c1c2fa3913523d42adf4ec04fd3f55f20766a43abbd00e50 ,\\ git@git.myserver.org:ORCA025/reshape_jra.git/reshape_jra_bilin__v1.0.1.nc reshape_jra55_orca025_bicub.nc, SHA256=91edfbc233a48d6aaa266d7aca71665f420da9957d3d124e9864e91e0012e10f ,\\ git@git.myserver.org:ORCA025/reshape_jra.git/reshape_jra_bicub__v1.0.1.nc","title":"Example"},{"location":"inputdata.html","text":"Input Data \ud83d\udd17","title":"How to refer to Input Data"},{"location":"inputdata.html#input-data","text":"","title":"Input Data"},{"location":"mkReadme.html","text":"Create the README file with mkReadme \ud83d\udd17 mkReadme helps you creating a README file that summerizes the characteristics of a simulation (an experiment with a specific configuration) as Markdown file ( README.md ). Step-by-Step \ud83d\udd17 Example \ud83d\udd17","title":"Create a README (mkReadme)"},{"location":"mkReadme.html#create-the-readme-file-with-mkreadme","text":"mkReadme helps you creating a README file that summerizes the characteristics of a simulation (an experiment with a specific configuration) as Markdown file ( README.md ).","title":"Create the README file with mkReadme"},{"location":"mkReadme.html#step-by-step","text":"","title":"Step-by-Step"},{"location":"mkReadme.html#example","text":"","title":"Example"},{"location":"notes.html","text":"Hidden Notes \ud83d\udd17 Note Warning Info Success Question Fail Danger Bug \u2013 .icons/material/account-circle.svg \u2013 .icons/fontawesome/regular/laugh-wink.svg \u2013 .icons/octicons/octoface-16.svg","title":"Hidden Notes"},{"location":"notes.html#hidden-notes","text":"Note Warning Info Success Question Fail Danger Bug \u2013 .icons/material/account-circle.svg \u2013 .icons/fontawesome/regular/laugh-wink.svg \u2013 .icons/octicons/octoface-16.svg","title":"Hidden Notes"},{"location":"overview.html","text":"Introduction \ud83d\udd17 Modeling the Ocean \ud83d\udd17 Ocean models of today are highly complex computer programs based on mathematical formulations of physical, chemical and biological interrelations. They are essential tools to investigate processes in the ocean from large scales to micro-structures which effect the climate physics, environmental conditions, economic developments and finally the human well-being. They can help to understand processes that lead to events in the past as well as to current changes. And it places an instrument to our disposal to look into the future using projections and forecasts. Reproducibility \ud83d\udd17 The results and the conclusions of a scientific analysis are the most important outcome in the wake of an ocean simulation effort. But the interpretation of the results must be verifiable and the simulation itself thus reproducible. Therefore, the knowledge about how the simulation was created and run is of equal importance and cannot be neglected. To fulfil this obligation of reproducibility every component of and input for a simulation must be documented in a well-defined, reliable, citable and thus sharable way. What is sharing for you? Publishing? Collaborating? \ud83d\udd17 If you want to share a simulation with others you may either want to just document what you have done and provide this information to others. Or you may want to develop a configuration together with contributions from different groups. While the former can be implemented quite easily: Just put the necessary information into one archive and extract some of the meta data for a summary. The latter (collaboration) needs a more complex solution: You'll have to make sure, that the development is version controlled and each contributor can be identified (not only to track bugs but also to acknowledge and to give credit for their contributions). NEMO \ud83d\udd17 The NEMO framework ( nemo-ocean.eu ) provides the code and tools to compile a computer program in order to simulate the ocean and its diverse components. Besides the physical ocean, also a sea-ice and a biogeochemical tracer module can both be included. The final program code is assembled during the compilation process and factors in additional pre-compiler choices (like model functionalities, competing parametrization and algorithms) and code modifications made by the user. The setup for such a specific executable program is called a \" configuration \". Although the same configuration can be compiled using different compilers for different machines, the same executable can be used however to run different \" experiments \". These experiments or \"runs\" differ on parameter choices made in separate namelist files, which are evaluated during run-time. They may also start from different initial conditions (e.g. the ocean state, like temperature, salinity and current velocities) and may respond to different boundary condition data (like geothermal bottom heat or atmospheric forcing), all read from external input data sets . NEMO is shipped with several build-in configurations including example parameter sets to demonstrate different kinds of application. The necessary input data files for these configurations can be downloaded from a data repository (see link in the cited NEMO documentation). Test Cases NEMO also provides a bunch of idealized test cases . Each in the shape of a configuration folder they reside in a separate NEMO directory and are meant to test certain features, algorithms and functionalities of the code. The full collection can be retrieved from a separate git repository which is open to contributions from the community. Missing User Configuration Documentation While the build-in configurations in NEMO are sufficiently documented, version-controlled and even the input files are linked to a permanent object identifier, there is no recommended way of keeping records of user configurations. NEMO-SIMSAR \ud83d\udd17 NEMO-SIMSAR aims to fill the gap of documenting NEMO simulations and introduces a consistent concept and provides recipes and tools. The concept behind NEMO-SIMSAR does not only emphasize univocally citable input data sets but also introduces a more comprehensive definition of a simulation package and its components than the original concept of configurations and experiments does in NEMO. The preferred repository system for publishing your simulation with SIMSAR is git (other platforms and protocols might be applicable, too). The figure below illustrates the workflow: User A (Simulation Manager X) has a copy of the NEMO framework repository containing several experiments under different configurations User A creates one ore more Simulation Packages and publishes them each in separate git project. Creating additional static pages from the git project in order to support the makenemo -u switch is optional. User B, also having a copy of the NEMO framework repository, clones one or more of these git projects to work with. In this case, User B could also contribute to a simulation package by uploading their own version and submitting a merge request to the respective git project. User B could also import a simulation package using the static pages version of the git project and the \"unsupported configuration\" switch with the build tool: makenemo -u . In this case no contributions could be made directly to the simulation project unless the simulation package is re-imported invoking step 3. DOIs could refer either to the git project version or the static pages version. In a two-level-access approach a DOI could refer to the static page version which in turn provides a link to the original repository. Getting Started","title":"Introduction"},{"location":"overview.html#introduction","text":"","title":"Introduction"},{"location":"overview.html#modeling-the-ocean","text":"Ocean models of today are highly complex computer programs based on mathematical formulations of physical, chemical and biological interrelations. They are essential tools to investigate processes in the ocean from large scales to micro-structures which effect the climate physics, environmental conditions, economic developments and finally the human well-being. They can help to understand processes that lead to events in the past as well as to current changes. And it places an instrument to our disposal to look into the future using projections and forecasts.","title":"Modeling the Ocean"},{"location":"overview.html#reproducibility","text":"The results and the conclusions of a scientific analysis are the most important outcome in the wake of an ocean simulation effort. But the interpretation of the results must be verifiable and the simulation itself thus reproducible. Therefore, the knowledge about how the simulation was created and run is of equal importance and cannot be neglected. To fulfil this obligation of reproducibility every component of and input for a simulation must be documented in a well-defined, reliable, citable and thus sharable way.","title":"Reproducibility"},{"location":"overview.html#what-is-sharing-for-you-publishing-collaborating","text":"If you want to share a simulation with others you may either want to just document what you have done and provide this information to others. Or you may want to develop a configuration together with contributions from different groups. While the former can be implemented quite easily: Just put the necessary information into one archive and extract some of the meta data for a summary. The latter (collaboration) needs a more complex solution: You'll have to make sure, that the development is version controlled and each contributor can be identified (not only to track bugs but also to acknowledge and to give credit for their contributions).","title":"What is sharing for you? Publishing? Collaborating?"},{"location":"overview.html#nemo","text":"The NEMO framework ( nemo-ocean.eu ) provides the code and tools to compile a computer program in order to simulate the ocean and its diverse components. Besides the physical ocean, also a sea-ice and a biogeochemical tracer module can both be included. The final program code is assembled during the compilation process and factors in additional pre-compiler choices (like model functionalities, competing parametrization and algorithms) and code modifications made by the user. The setup for such a specific executable program is called a \" configuration \". Although the same configuration can be compiled using different compilers for different machines, the same executable can be used however to run different \" experiments \". These experiments or \"runs\" differ on parameter choices made in separate namelist files, which are evaluated during run-time. They may also start from different initial conditions (e.g. the ocean state, like temperature, salinity and current velocities) and may respond to different boundary condition data (like geothermal bottom heat or atmospheric forcing), all read from external input data sets . NEMO is shipped with several build-in configurations including example parameter sets to demonstrate different kinds of application. The necessary input data files for these configurations can be downloaded from a data repository (see link in the cited NEMO documentation). Test Cases NEMO also provides a bunch of idealized test cases . Each in the shape of a configuration folder they reside in a separate NEMO directory and are meant to test certain features, algorithms and functionalities of the code. The full collection can be retrieved from a separate git repository which is open to contributions from the community. Missing User Configuration Documentation While the build-in configurations in NEMO are sufficiently documented, version-controlled and even the input files are linked to a permanent object identifier, there is no recommended way of keeping records of user configurations.","title":"NEMO"},{"location":"overview.html#nemo-simsar","text":"NEMO-SIMSAR aims to fill the gap of documenting NEMO simulations and introduces a consistent concept and provides recipes and tools. The concept behind NEMO-SIMSAR does not only emphasize univocally citable input data sets but also introduces a more comprehensive definition of a simulation package and its components than the original concept of configurations and experiments does in NEMO. The preferred repository system for publishing your simulation with SIMSAR is git (other platforms and protocols might be applicable, too). The figure below illustrates the workflow: User A (Simulation Manager X) has a copy of the NEMO framework repository containing several experiments under different configurations User A creates one ore more Simulation Packages and publishes them each in separate git project. Creating additional static pages from the git project in order to support the makenemo -u switch is optional. User B, also having a copy of the NEMO framework repository, clones one or more of these git projects to work with. In this case, User B could also contribute to a simulation package by uploading their own version and submitting a merge request to the respective git project. User B could also import a simulation package using the static pages version of the git project and the \"unsupported configuration\" switch with the build tool: makenemo -u . In this case no contributions could be made directly to the simulation project unless the simulation package is re-imported invoking step 3. DOIs could refer either to the git project version or the static pages version. In a two-level-access approach a DOI could refer to the static page version which in turn provides a link to the original repository. Getting Started","title":"NEMO-SIMSAR"},{"location":"publish_cloud.html","text":"Publish via cloud \ud83d\udd17","title":"Publish via cloud"},{"location":"publish_cloud.html#publish-via-cloud","text":"","title":"Publish via cloud"},{"location":"publish_git.html","text":"Publish via GIT \ud83d\udd17","title":"via git"},{"location":"publish_git.html#publish-via-git","text":"","title":"Publish via GIT"}]}